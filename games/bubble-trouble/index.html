<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Bubble Trouble</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Righteous&family=Fredoka:wght@400;600;700&family=Josefin+Sans:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --acid-orange: #ff6b00;
            --electric-purple: #9b30ff;
            --lime-green: #39ff14;
            --hot-magenta: #ff1493;
            --sunshine-yellow: #ffed00;
            --cosmic-blue: #00bfff;
            --tangerine: #ff9966;
            --grape: #6b3fa0;
            --deep-violet: #1a0033;
            --darker-violet: #0f001f;
            --cream: #fff8dc;
            --font-display: 'Righteous', cursive;
            --font-heading: 'Fredoka', sans-serif;
            --font-body: 'Josefin Sans', sans-serif;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            background: var(--darker-violet);
            overflow: hidden;
            font-family: var(--font-body);
            color: var(--cream);
            width: 100vw;
            height: 100vh;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }

        canvas {
            display: block;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* HUD */
        #hud {
            position: fixed;
            top: 0; left: 0; right: 0;
            display: none;
            justify-content: space-between;
            align-items: flex-start;
            padding: 10px 20px;
            pointer-events: none;
            z-index: 10;
        }

        .hud-panel {
            background: rgba(26, 0, 51, 0.7);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(155, 48, 255, 0.3);
            border-radius: 10px;
            padding: 6px 14px;
        }

        .hud-level {
            font-family: var(--font-display);
            font-size: 1.1rem;
            color: var(--sunshine-yellow);
            text-shadow: 0 0 10px rgba(255, 237, 0, 0.4);
        }

        .hud-score {
            font-family: var(--font-display);
            font-size: 1.4rem;
            color: var(--lime-green);
            text-shadow: 0 0 15px rgba(57, 255, 20, 0.4);
        }

        .hud-timer {
            font-family: var(--font-heading);
            font-size: 1.1rem;
            color: var(--cream);
        }

        .hud-timer.warning { color: var(--acid-orange); }
        .hud-timer.danger { color: var(--hot-magenta); animation: timerPulse 0.5s ease-in-out infinite; }

        .hud-center {
            text-align: center;
        }

        .hud-lives {
            font-family: var(--font-heading);
            font-size: 0.85rem;
            color: var(--hot-magenta);
            margin-top: 2px;
        }

        .hud-powerup-indicator {
            font-family: var(--font-heading);
            font-size: 0.75rem;
            color: var(--cosmic-blue);
            margin-top: 3px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .hud-powerup-indicator.active { opacity: 1; }

        @keyframes timerPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Title Screen */
        #title-screen {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            background: linear-gradient(180deg, var(--darker-violet) 0%, var(--deep-violet) 50%, #2a0045 100%);
        }

        .title-logo {
            font-family: var(--font-display);
            font-size: clamp(2.8rem, 9vw, 5.5rem);
            background: linear-gradient(135deg, var(--acid-orange), var(--hot-magenta), var(--electric-purple), var(--cosmic-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(0 0 30px rgba(155, 48, 255, 0.5));
            margin-bottom: 8px;
            text-align: center;
        }

        .title-sub {
            font-family: var(--font-heading);
            font-size: clamp(0.85rem, 2.2vw, 1.1rem);
            color: rgba(255,248,220,0.4);
            margin-bottom: 35px;
        }

        .title-start {
            font-family: var(--font-heading);
            font-size: 1.1rem;
            color: var(--sunshine-yellow);
            animation: pulse 2s ease-in-out infinite;
        }

        .title-highscore {
            font-family: var(--font-body);
            font-size: 0.85rem;
            color: var(--lime-green);
            margin-top: 16px;
            opacity: 0.7;
        }

        .title-controls {
            font-family: var(--font-body);
            font-size: 0.75rem;
            color: rgba(255,248,220,0.3);
            margin-top: 28px;
            text-align: center;
            line-height: 1.9;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.04); }
        }

        /* Level Complete */
        #level-screen {
            position: fixed;
            inset: 0;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            background: rgba(15, 0, 31, 0.88);
            backdrop-filter: blur(6px);
            -webkit-backdrop-filter: blur(6px);
        }

        .level-title {
            font-family: var(--font-display);
            font-size: clamp(1.8rem, 5vw, 3rem);
            color: var(--sunshine-yellow);
            text-shadow: 0 0 30px rgba(255, 237, 0, 0.4);
            margin-bottom: 10px;
        }

        .level-bonus {
            font-family: var(--font-heading);
            font-size: 1rem;
            color: var(--lime-green);
            margin-bottom: 25px;
        }

        .level-continue {
            font-family: var(--font-heading);
            font-size: 0.95rem;
            color: rgba(255,248,220,0.6);
            animation: pulse 2s ease-in-out infinite;
        }

        /* Game Over */
        #gameover-screen {
            position: fixed;
            inset: 0;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            background: rgba(15, 0, 31, 0.92);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }

        .gameover-title {
            font-family: var(--font-display);
            font-size: clamp(2rem, 6vw, 3.5rem);
            color: var(--hot-magenta);
            text-shadow: 0 0 30px rgba(255, 20, 147, 0.4);
            margin-bottom: 25px;
        }

        .gameover-stats {
            background: rgba(26, 0, 51, 0.6);
            border: 1px solid rgba(155, 48, 255, 0.3);
            border-radius: 14px;
            padding: 20px 36px;
            margin-bottom: 25px;
            min-width: 240px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            gap: 25px;
        }

        .stat-label {
            font-size: 0.85rem;
            color: rgba(255,248,220,0.5);
        }

        .stat-value {
            font-family: var(--font-heading);
            font-size: 1.05rem;
            font-weight: 700;
            color: var(--lime-green);
        }

        .stat-row.highlight .stat-value {
            color: var(--sunshine-yellow);
            font-size: 1.2rem;
        }

        .stat-row.new-best .stat-value::after {
            content: ' NEW!';
            font-size: 0.65rem;
            color: var(--hot-magenta);
        }

        .gameover-restart {
            font-family: var(--font-heading);
            font-size: 0.95rem;
            color: rgba(255,248,220,0.6);
            animation: pulse 2s ease-in-out infinite;
        }

        /* Pause */
        #pause-overlay {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 15;
            background: rgba(15, 0, 31, 0.7);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }

        .pause-text {
            font-family: var(--font-display);
            font-size: 3rem;
            color: var(--electric-purple);
            text-shadow: 0 0 30px rgba(155, 48, 255, 0.5);
        }

        /* Mobile controls */
        #mobile-controls {
            position: fixed;
            bottom: 10px;
            left: 0; right: 0;
            display: none;
            justify-content: space-between;
            padding: 0 15px;
            z-index: 10;
            pointer-events: none;
        }

        .mobile-btn-group {
            display: flex;
            gap: 10px;
            pointer-events: auto;
        }

        .mobile-btn {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            border: 2px solid rgba(155, 48, 255, 0.4);
            background: rgba(26, 0, 51, 0.6);
            backdrop-filter: blur(6px);
            -webkit-backdrop-filter: blur(6px);
            color: var(--cream);
            font-size: 1.6rem;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }

        .mobile-btn:active {
            background: rgba(155, 48, 255, 0.3);
        }

        .mobile-btn-shoot {
            width: 80px;
            height: 80px;
            border-color: rgba(255, 20, 147, 0.4);
            font-family: var(--font-heading);
            font-size: 0.8rem;
        }

        @media (pointer: coarse) {
            #mobile-controls { display: flex; }
        }
    </style>
</head>
<body>
    <canvas id="game"></canvas>

    <div id="hud">
        <div class="hud-panel">
            <div class="hud-level" id="hud-level">Level 1</div>
            <div class="hud-lives" id="hud-lives"></div>
        </div>
        <div class="hud-panel hud-center">
            <div class="hud-timer" id="hud-timer">1:00</div>
            <div class="hud-powerup-indicator" id="hud-powerup">FREEZE</div>
        </div>
        <div class="hud-panel">
            <div class="hud-score" id="hud-score">0</div>
        </div>
    </div>

    <div id="title-screen">
        <div class="title-logo">Bubble Trouble</div>
        <div class="title-sub">Psychedelic Edition</div>
        <div class="title-start">Press Space or Tap to Start</div>
        <div class="title-highscore" id="title-highscore"></div>
        <div class="title-controls">
            A/D or Arrows = Move &bull; W/Up/Space = Shoot<br>
            P = Pause &bull; Pop all the bubbles!
        </div>
    </div>

    <div id="level-screen">
        <div class="level-title" id="level-title">Level Complete!</div>
        <div class="level-bonus" id="level-bonus">Time Bonus: +500</div>
        <div class="level-continue">Press Space or Tap to Continue</div>
    </div>

    <div id="gameover-screen">
        <div class="gameover-title">Game Over</div>
        <div class="gameover-stats" id="gameover-stats"></div>
        <div class="gameover-restart">Press Space or Tap to Retry</div>
    </div>

    <div id="pause-overlay">
        <div class="pause-text">PAUSED</div>
    </div>

    <div id="mobile-controls">
        <div class="mobile-btn-group">
            <button class="mobile-btn" id="btn-left">&larr;</button>
            <button class="mobile-btn" id="btn-right">&rarr;</button>
        </div>
        <button class="mobile-btn mobile-btn-shoot" id="btn-shoot">FIRE</button>
    </div>

    <script>
    (function() {
        'use strict';

        // ===================== CANVAS SETUP =====================
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        // Arena is fixed aspect ratio, scaled to fit
        const ARENA_W = 800;
        const ARENA_H = 500;
        const FLOOR_H = 40;
        const CEIL_H = 8;
        let scale = 1;
        let offsetX = 0, offsetY = 0;

        function resize() {
            const vw = window.innerWidth;
            const vh = window.innerHeight;
            scale = Math.min(vw / ARENA_W, vh / ARENA_H);
            canvas.width = ARENA_W * scale;
            canvas.height = ARENA_H * scale;
            canvas.style.width = canvas.width + 'px';
            canvas.style.height = canvas.height + 'px';
        }
        resize();
        window.addEventListener('resize', resize);

        // ===================== COLORS =====================
        const COLORS = {
            acidOrange: '#ff6b00',
            electricPurple: '#9b30ff',
            limeGreen: '#39ff14',
            hotMagenta: '#ff1493',
            sunshineYellow: '#ffed00',
            cosmicBlue: '#00bfff',
            tangerine: '#ff9966',
            grape: '#6b3fa0',
            deepViolet: '#1a0033',
            cream: '#fff8dc'
        };

        // Bubble size tiers: color, radius, bounce height, speed, points
        const BUBBLE_TIERS = [
            { radius: 40, bounceH: 340, speed: 80,  color: COLORS.acidOrange,     glow: 'rgba(255,107,0,0.5)',    points: 10  },
            { radius: 30, bounceH: 280, speed: 100,  color: COLORS.hotMagenta,     glow: 'rgba(255,20,147,0.5)',   points: 25  },
            { radius: 22, bounceH: 220, speed: 120, color: COLORS.electricPurple,  glow: 'rgba(155,48,255,0.5)',   points: 50  },
            { radius: 15, bounceH: 160, speed: 140, color: COLORS.limeGreen,       glow: 'rgba(57,255,20,0.5)',    points: 100 },
            { radius: 10, bounceH: 110, speed: 160, color: COLORS.sunshineYellow,  glow: 'rgba(255,237,0,0.5)',    points: 200 }
        ];

        // ===================== GAME STATE =====================
        const STATE = { TITLE: 0, PLAYING: 1, LEVEL_COMPLETE: 2, GAMEOVER: 3, PAUSED: 4 };
        let state = STATE.TITLE;

        // Player
        const PLAYER_SPEED = 250;
        const PLAYER_W = 28;
        const PLAYER_H = 36;
        let player = {};

        // Harpoons
        let harpoons = [];
        const HARPOON_SPEED = 500;
        const HARPOON_WIDTH = 3;
        let maxHarpoons = 1;

        // Bubbles
        let bubblesList = [];
        const GRAVITY = 600;

        // Particles
        let particles = [];

        // Background
        let bgStars = [];
        let tripPhase = 0;

        // Power-ups
        let powerupItems = [];
        let activePower = null;
        let powerTimer = 0;

        // Game tracking
        let score = 0;
        let lives = 3;
        let currentLevel = 0;
        let levelTime = 0;
        let levelTimeMax = 0;
        let bubblesPopped = 0;
        let totalBubblesPopped = 0;
        let highScore = parseInt(localStorage.getItem('bubbleTroubleHigh') || '0');
        let highLevel = parseInt(localStorage.getItem('bubbleTroubleHighLvl') || '0');

        // Freeze power-up
        let freezeTimer = 0;

        // Screen shake
        let shakeAmount = 0;
        let shakeDuration = 0;

        // Death invulnerability
        let invulnTimer = 0;

        // ===================== AUDIO =====================
        let audioCtx = null;

        function ensureAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function playTone(freq, dur, type, vol, rampTo) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type || 'sine';
            osc.frequency.value = freq;
            if (rampTo) osc.frequency.exponentialRampToValueAtTime(rampTo, audioCtx.currentTime + dur);
            gain.gain.setValueAtTime(vol || 0.08, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + dur);
        }

        function playNoise(dur, vol) {
            if (!audioCtx) return;
            const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * dur, audioCtx.sampleRate);
            const d = buf.getChannelData(0);
            for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
            const src = audioCtx.createBufferSource();
            src.buffer = buf;
            const gain = audioCtx.createGain();
            const filt = audioCtx.createBiquadFilter();
            filt.type = 'bandpass';
            filt.frequency.value = 1200;
            gain.gain.setValueAtTime(vol || 0.04, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
            src.connect(filt);
            filt.connect(gain);
            gain.connect(audioCtx.destination);
            src.start();
        }

        const sfx = {
            shoot() {
                playTone(280, 0.12, 'triangle', 0.07);
                playTone(560, 0.06, 'sine', 0.04);
            },
            pop(tier) {
                const freqs = [300, 450, 600, 800, 1100];
                const f = freqs[tier] || 600;
                playTone(f, 0.12, 'sine', 0.1);
                playTone(f * 1.5, 0.08, 'triangle', 0.05);
                playNoise(0.06, 0.06);
            },
            death() {
                playTone(200, 0.3, 'sawtooth', 0.08, 80);
                playNoise(0.2, 0.08);
            },
            levelComplete() {
                const notes = [523, 659, 784, 1047];
                notes.forEach((n, i) => {
                    setTimeout(() => playTone(n, 0.15, 'sine', 0.08), i * 80);
                });
            },
            powerup() {
                playTone(800, 0.08, 'sine', 0.07);
                setTimeout(() => playTone(1000, 0.08, 'sine', 0.07), 60);
                setTimeout(() => playTone(1200, 0.1, 'sine', 0.06), 120);
            },
            freeze() {
                playTone(1500, 0.3, 'sine', 0.06, 800);
                playTone(1200, 0.25, 'triangle', 0.04, 600);
            },
            tick() {
                playTone(1000, 0.03, 'square', 0.04);
            }
        };

        // ===================== BACKGROUND =====================
        function initBackground() {
            bgStars = [];
            for (let i = 0; i < 50; i++) {
                bgStars.push({
                    x: Math.random() * ARENA_W,
                    y: Math.random() * ARENA_H,
                    r: 0.5 + Math.random() * 2,
                    hue: Math.random() * 360,
                    speed: 0.2 + Math.random() * 0.5,
                    phase: Math.random() * Math.PI * 2
                });
            }
        }

        function drawBackground(dt) {
            tripPhase += dt * 0.4;

            // Deep gradient
            const grad = ctx.createLinearGradient(0, 0, 0, ARENA_H);
            const hueShift = Math.sin(tripPhase * 0.3) * 15;
            grad.addColorStop(0, `hsl(${270 + hueShift}, 100%, 4%)`);
            grad.addColorStop(0.5, `hsl(${280 + hueShift}, 80%, 8%)`);
            grad.addColorStop(1, `hsl(${290 + hueShift}, 70%, 12%)`);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, ARENA_W, ARENA_H);

            // Subtle radial glow blobs
            ctx.globalAlpha = 0.03;
            for (let i = 0; i < 3; i++) {
                const cx = ARENA_W / 2 + Math.sin(tripPhase * 0.5 + i * 2.1) * ARENA_W * 0.35;
                const cy = ARENA_H / 2 + Math.cos(tripPhase * 0.3 + i * 1.7) * ARENA_H * 0.3;
                const r = 120 + Math.sin(tripPhase + i) * 40;
                const hue = (i * 120 + tripPhase * 20) % 360;
                const rg = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
                rg.addColorStop(0, `hsla(${hue}, 100%, 60%, 1)`);
                rg.addColorStop(1, `hsla(${hue}, 100%, 60%, 0)`);
                ctx.fillStyle = rg;
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // Stars
            for (const s of bgStars) {
                s.phase += s.speed * dt;
                const alpha = 0.3 + Math.sin(s.phase) * 0.3;
                const hue = (s.hue + tripPhase * 10) % 360;
                ctx.fillStyle = `hsla(${hue}, 100%, 70%, ${alpha})`;
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
                ctx.fill();
            }

            // Floor
            const floorGrad = ctx.createLinearGradient(0, ARENA_H - FLOOR_H, 0, ARENA_H);
            floorGrad.addColorStop(0, 'rgba(107,63,160,0.4)');
            floorGrad.addColorStop(1, 'rgba(107,63,160,0.15)');
            ctx.fillStyle = floorGrad;
            ctx.fillRect(0, ARENA_H - FLOOR_H, ARENA_W, FLOOR_H);

            // Floor line
            ctx.strokeStyle = `hsla(${(280 + hueShift) % 360}, 80%, 50%, 0.5)`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, ARENA_H - FLOOR_H);
            ctx.lineTo(ARENA_W, ARENA_H - FLOOR_H);
            ctx.stroke();

            // Ceiling line
            ctx.strokeStyle = `hsla(${(300 + hueShift) % 360}, 80%, 50%, 0.3)`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, CEIL_H);
            ctx.lineTo(ARENA_W, CEIL_H);
            ctx.stroke();

            // Side walls subtle glow
            ctx.strokeStyle = `hsla(${(260 + hueShift) % 360}, 80%, 40%, 0.2)`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(1, CEIL_H);
            ctx.lineTo(1, ARENA_H - FLOOR_H);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(ARENA_W - 1, CEIL_H);
            ctx.lineTo(ARENA_W - 1, ARENA_H - FLOOR_H);
            ctx.stroke();
        }

        // ===================== LEVELS =====================
        // Each level: array of {tier, x, dir} where dir is 1 or -1
        const LEVELS = [
            // Level 1: One big bubble
            { time: 45, bubbles: [{ tier: 0, x: 400, dir: 1 }] },
            // Level 2: Two big bubbles
            { time: 50, bubbles: [{ tier: 0, x: 250, dir: 1 }, { tier: 0, x: 550, dir: -1 }] },
            // Level 3: One big + two medium
            { time: 50, bubbles: [{ tier: 0, x: 400, dir: -1 }, { tier: 2, x: 150, dir: 1 }, { tier: 2, x: 650, dir: -1 }] },
            // Level 4: Three big bubbles
            { time: 55, bubbles: [{ tier: 0, x: 200, dir: 1 }, { tier: 0, x: 400, dir: -1 }, { tier: 0, x: 600, dir: 1 }] },
            // Level 5: Two big + small fast ones
            { time: 55, bubbles: [{ tier: 0, x: 300, dir: 1 }, { tier: 0, x: 500, dir: -1 }, { tier: 3, x: 100, dir: 1 }, { tier: 3, x: 700, dir: -1 }] },
            // Level 6: Large bubble chaos
            { time: 60, bubbles: [{ tier: 1, x: 150, dir: 1 }, { tier: 1, x: 350, dir: -1 }, { tier: 1, x: 550, dir: 1 }, { tier: 1, x: 700, dir: -1 }] },
            // Level 7: One huge + many smalls
            { time: 55, bubbles: [{ tier: 0, x: 400, dir: 1 }, { tier: 3, x: 100, dir: -1 }, { tier: 3, x: 200, dir: 1 }, { tier: 3, x: 600, dir: -1 }, { tier: 3, x: 700, dir: 1 }] },
            // Level 8: Four big bubbles
            { time: 65, bubbles: [{ tier: 0, x: 150, dir: 1 }, { tier: 0, x: 350, dir: -1 }, { tier: 0, x: 500, dir: 1 }, { tier: 0, x: 700, dir: -1 }] },
            // Level 9: Mixed madness
            { time: 60, bubbles: [{ tier: 0, x: 400, dir: 1 }, { tier: 1, x: 200, dir: -1 }, { tier: 1, x: 600, dir: 1 }, { tier: 2, x: 100, dir: 1 }, { tier: 2, x: 700, dir: -1 }] },
            // Level 10: The gauntlet - five big
            { time: 75, bubbles: [{ tier: 0, x: 100, dir: 1 }, { tier: 0, x: 250, dir: -1 }, { tier: 0, x: 400, dir: 1 }, { tier: 0, x: 550, dir: -1 }, { tier: 0, x: 700, dir: 1 }] },
            // Level 11: Speed run - many mediums
            { time: 55, bubbles: [{ tier: 2, x: 100, dir: 1 }, { tier: 2, x: 200, dir: -1 }, { tier: 2, x: 350, dir: 1 }, { tier: 2, x: 500, dir: -1 }, { tier: 2, x: 650, dir: 1 }, { tier: 2, x: 750, dir: -1 }] },
            // Level 12: Boss level
            { time: 80, bubbles: [{ tier: 0, x: 200, dir: 1 }, { tier: 0, x: 400, dir: -1 }, { tier: 0, x: 600, dir: 1 }, { tier: 1, x: 100, dir: -1 }, { tier: 1, x: 700, dir: 1 }] }
        ];

        // ===================== INIT =====================
        function initGame() {
            score = 0;
            lives = 3;
            currentLevel = 0;
            totalBubblesPopped = 0;
            initBackground();
            loadLevel(0);
        }

        function loadLevel(idx) {
            currentLevel = idx;
            const lvl = LEVELS[idx % LEVELS.length];
            // Scale difficulty for repeated loops
            const loop = Math.floor(idx / LEVELS.length);

            player = {
                x: ARENA_W / 2,
                y: ARENA_H - FLOOR_H - PLAYER_H / 2,
                vx: 0
            };

            harpoons = [];
            bubblesList = [];
            particles = [];
            powerupItems = [];
            activePower = null;
            powerTimer = 0;
            freezeTimer = 0;
            maxHarpoons = 1;
            invulnTimer = 0;

            levelTime = lvl.time;
            levelTimeMax = lvl.time;
            bubblesPopped = 0;

            for (const b of lvl.bubbles) {
                const tier = BUBBLE_TIERS[b.tier];
                const speedMult = 1 + loop * 0.15;
                bubblesList.push(createBubble(b.tier, b.x, ARENA_H - FLOOR_H - tier.radius - 50, b.dir * tier.speed * speedMult));
            }
        }

        function createBubble(tierIdx, x, y, vx) {
            const tier = BUBBLE_TIERS[tierIdx];
            // Calculate vy for proper bounce height using vÂ² = 2gh
            const vy = -Math.sqrt(2 * GRAVITY * tier.bounceH);
            return {
                tier: tierIdx,
                x: x,
                y: y,
                vx: vx || (Math.random() > 0.5 ? 1 : -1) * tier.speed,
                vy: vy * (0.5 + Math.random() * 0.5), // Start at random point in bounce
                radius: tier.radius,
                color: tier.color,
                glow: tier.glow,
                phase: Math.random() * Math.PI * 2,
                trail: []
            };
        }

        // ===================== PARTICLES =====================
        function spawnPopParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                const a = (Math.PI * 2 / count) * i + Math.random() * 0.3;
                const speed = 80 + Math.random() * 150;
                particles.push({
                    x, y,
                    vx: Math.cos(a) * speed,
                    vy: Math.sin(a) * speed - 40,
                    r: 2 + Math.random() * 4,
                    color: color,
                    life: 0.4 + Math.random() * 0.3,
                    maxLife: 0.7,
                    type: 'circle'
                });
            }
            // Ring burst
            particles.push({
                x, y,
                vx: 0, vy: 0,
                r: 5,
                color: color,
                life: 0.3,
                maxLife: 0.3,
                type: 'ring',
                maxR: 60
            });
        }

        function spawnScoreText(x, y, text, color) {
            particles.push({
                x, y,
                vx: (Math.random() - 0.5) * 20,
                vy: -60,
                r: 0,
                color: color || COLORS.cream,
                life: 0.9,
                maxLife: 0.9,
                type: 'text',
                text: text
            });
        }

        function spawnDeathEffect(x, y) {
            for (let i = 0; i < 20; i++) {
                const a = Math.random() * Math.PI * 2;
                const speed = 50 + Math.random() * 200;
                particles.push({
                    x, y,
                    vx: Math.cos(a) * speed,
                    vy: Math.sin(a) * speed - 80,
                    r: 1 + Math.random() * 3,
                    color: [COLORS.hotMagenta, COLORS.acidOrange, COLORS.sunshineYellow][Math.floor(Math.random() * 3)],
                    life: 0.5 + Math.random() * 0.4,
                    maxLife: 0.9,
                    type: 'circle'
                });
            }
        }

        // ===================== POWERUP SYSTEM =====================
        const POWER_TYPES = ['double', 'freeze', 'shield', 'slow'];
        const POWER_COLORS = {
            double: COLORS.cosmicBlue,
            freeze: COLORS.sunshineYellow,
            shield: COLORS.limeGreen,
            slow: COLORS.tangerine
        };
        const POWER_NAMES = {
            double: 'DOUBLE HARPOON',
            freeze: 'FREEZE',
            shield: 'SHIELD',
            slow: 'SLOW MOTION'
        };

        function maybeSpawnPowerup(x, y) {
            if (Math.random() > 0.12) return;
            const type = POWER_TYPES[Math.floor(Math.random() * POWER_TYPES.length)];
            powerupItems.push({
                x, y,
                vy: -40,
                type,
                phase: 0,
                life: 5
            });
        }

        // ===================== DRAWING =====================
        function drawPlayer() {
            if (invulnTimer > 0 && Math.sin(invulnTimer * 20) > 0) return;

            const px = player.x;
            const py = player.y;

            ctx.save();
            ctx.translate(px, py);

            // Shield glow
            if (activePower === 'shield') {
                ctx.strokeStyle = 'rgba(57,255,20,0.4)';
                ctx.lineWidth = 2;
                ctx.shadowColor = COLORS.limeGreen;
                ctx.shadowBlur = 12;
                ctx.beginPath();
                ctx.arc(0, 0, 22, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            // Body - trippy character
            const bodyHue = (tripPhase * 30) % 360;

            // Legs
            ctx.fillStyle = `hsl(${bodyHue + 180}, 80%, 50%)`;
            ctx.fillRect(-8, 8, 6, 12);
            ctx.fillRect(2, 8, 6, 12);

            // Body
            const bodyGrad = ctx.createLinearGradient(0, -14, 0, 10);
            bodyGrad.addColorStop(0, `hsl(${bodyHue}, 100%, 60%)`);
            bodyGrad.addColorStop(1, `hsl(${bodyHue + 40}, 100%, 50%)`);
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.roundRect(-10, -10, 20, 20, 4);
            ctx.fill();

            // Head
            ctx.fillStyle = `hsl(${bodyHue + 60}, 80%, 70%)`;
            ctx.beginPath();
            ctx.arc(0, -16, 8, 0, Math.PI * 2);
            ctx.fill();

            // Eyes (two dots)
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-3, -17, 2.5, 0, Math.PI * 2);
            ctx.arc(3, -17, 2.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = COLORS.deepViolet;
            ctx.beginPath();
            ctx.arc(-3, -17, 1.2, 0, Math.PI * 2);
            ctx.arc(3, -17, 1.2, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawBubble(b) {
            // Trail
            ctx.globalAlpha = 0.15;
            for (let i = 0; i < b.trail.length; i++) {
                const t = b.trail[i];
                const alpha = (i / b.trail.length) * 0.15;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = b.color;
                ctx.beginPath();
                ctx.arc(t.x, t.y, b.radius * 0.8, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            b.phase += 0.05;

            // Glow
            ctx.shadowColor = b.glow;
            ctx.shadowBlur = 15 + Math.sin(b.phase) * 5;

            // Main bubble
            const grad = ctx.createRadialGradient(
                b.x - b.radius * 0.3, b.y - b.radius * 0.3, b.radius * 0.1,
                b.x, b.y, b.radius
            );
            const baseColor = b.color;
            grad.addColorStop(0, 'rgba(255,255,255,0.3)');
            grad.addColorStop(0.4, baseColor);
            grad.addColorStop(1, baseColor);
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
            ctx.fill();

            // Inner psychedelic swirl
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 0.2;
            const swirlHue = (b.phase * 50) % 360;
            ctx.strokeStyle = `hsl(${swirlHue}, 100%, 70%)`;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            for (let a = 0; a < Math.PI * 2; a += 0.1) {
                const r = b.radius * 0.6 * (0.7 + 0.3 * Math.sin(a * 3 + b.phase * 2));
                const sx = b.x + Math.cos(a) * r;
                const sy = b.y + Math.sin(a) * r;
                if (a === 0) ctx.moveTo(sx, sy);
                else ctx.lineTo(sx, sy);
            }
            ctx.closePath();
            ctx.stroke();
            ctx.globalAlpha = 1;

            // Highlight
            ctx.fillStyle = 'rgba(255,255,255,0.35)';
            ctx.beginPath();
            ctx.ellipse(b.x - b.radius * 0.3, b.y - b.radius * 0.35, b.radius * 0.25, b.radius * 0.15, -0.5, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawHarpoon(h) {
            // Trippy rainbow line
            const hue = (tripPhase * 60 + h.y) % 360;
            ctx.save();
            ctx.shadowColor = `hsla(${hue}, 100%, 60%, 0.6)`;
            ctx.shadowBlur = 8;
            ctx.strokeStyle = `hsl(${hue}, 100%, 65%)`;
            ctx.lineWidth = HARPOON_WIDTH;
            ctx.beginPath();
            ctx.moveTo(h.x, h.base);
            ctx.lineTo(h.x, h.y);
            ctx.stroke();

            // Tip
            ctx.fillStyle = COLORS.cream;
            ctx.beginPath();
            ctx.moveTo(h.x, h.y - 6);
            ctx.lineTo(h.x - 4, h.y + 2);
            ctx.lineTo(h.x + 4, h.y + 2);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        function drawPowerup(p) {
            ctx.save();
            ctx.translate(p.x, p.y + Math.sin(p.phase * 3) * 4);
            ctx.shadowColor = POWER_COLORS[p.type];
            ctx.shadowBlur = 12;

            // Spinning star shape
            const rot = p.phase * 2;
            ctx.fillStyle = POWER_COLORS[p.type];
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const a = rot + (Math.PI * 2 / 5) * i - Math.PI / 2;
                const aInner = rot + (Math.PI * 2 / 5) * (i + 0.5) - Math.PI / 2;
                ctx.lineTo(Math.cos(a) * 10, Math.sin(a) * 10);
                ctx.lineTo(Math.cos(aInner) * 5, Math.sin(aInner) * 5);
            }
            ctx.closePath();
            ctx.fill();

            // Letter
            ctx.shadowBlur = 0;
            ctx.fillStyle = COLORS.deepViolet;
            ctx.font = 'bold 8px Fredoka';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(p.type[0].toUpperCase(), 0, 1);
            ctx.restore();
        }

        function drawParticles() {
            for (const p of particles) {
                const alpha = Math.max(0, p.life / p.maxLife);
                ctx.globalAlpha = alpha;

                if (p.type === 'circle') {
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.r * alpha, 0, Math.PI * 2);
                    ctx.fill();
                } else if (p.type === 'ring') {
                    const ringR = p.maxR * (1 - alpha);
                    ctx.strokeStyle = p.color;
                    ctx.lineWidth = 2 * alpha;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, ringR, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (p.type === 'text') {
                    ctx.fillStyle = p.color;
                    ctx.font = 'bold 14px Fredoka';
                    ctx.textAlign = 'center';
                    ctx.fillText(p.text, p.x, p.y);
                }
            }
            ctx.globalAlpha = 1;
        }

        // ===================== INPUT =====================
        const keys = {};

        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;

            if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
                e.preventDefault();
                if (state === STATE.TITLE) { startGame(); return; }
                if (state === STATE.GAMEOVER) { startGame(); return; }
                if (state === STATE.LEVEL_COMPLETE) { nextLevel(); return; }
                if (state === STATE.PLAYING) shoot();
            }

            if (e.code === 'KeyP' || e.code === 'Escape') {
                togglePause();
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // Mobile controls
        const btnLeft = document.getElementById('btn-left');
        const btnRight = document.getElementById('btn-right');
        const btnShoot = document.getElementById('btn-shoot');
        let mobileLeft = false, mobileRight = false;

        function addMobileEvents(btn, onStart, onEnd) {
            btn.addEventListener('pointerdown', (e) => { e.preventDefault(); onStart(); });
            btn.addEventListener('pointerup', (e) => { e.preventDefault(); onEnd(); });
            btn.addEventListener('pointerleave', (e) => { e.preventDefault(); onEnd(); });
            btn.addEventListener('pointercancel', (e) => { e.preventDefault(); onEnd(); });
        }

        addMobileEvents(btnLeft, () => { mobileLeft = true; }, () => { mobileLeft = false; });
        addMobileEvents(btnRight, () => { mobileRight = true; }, () => { mobileRight = false; });
        addMobileEvents(btnShoot, () => {
            if (state === STATE.TITLE) startGame();
            else if (state === STATE.GAMEOVER) startGame();
            else if (state === STATE.LEVEL_COMPLETE) nextLevel();
            else if (state === STATE.PLAYING) shoot();
        }, () => {});

        // Tap to start on title/gameover
        canvas.addEventListener('pointerdown', (e) => {
            if (state === STATE.TITLE) { ensureAudio(); startGame(); }
            else if (state === STATE.GAMEOVER) startGame();
            else if (state === STATE.LEVEL_COMPLETE) nextLevel();
        });

        function shoot() {
            if (harpoons.length >= maxHarpoons) return;
            harpoons.push({
                x: player.x,
                y: ARENA_H - FLOOR_H,
                base: ARENA_H - FLOOR_H
            });
            sfx.shoot();
        }

        // ===================== UPDATE =====================
        function update(dt) {
            if (state !== STATE.PLAYING) return;

            // Player movement
            let moveDir = 0;
            if (keys['ArrowLeft'] || keys['KeyA'] || mobileLeft) moveDir -= 1;
            if (keys['ArrowRight'] || keys['KeyD'] || mobileRight) moveDir += 1;
            player.x += moveDir * PLAYER_SPEED * dt;
            player.x = Math.max(PLAYER_W / 2 + 4, Math.min(ARENA_W - PLAYER_W / 2 - 4, player.x));

            // Invulnerability
            if (invulnTimer > 0) invulnTimer -= dt;

            // Freeze
            const timeScale = freezeTimer > 0 ? 0.0 : (activePower === 'slow' ? 0.4 : 1.0);
            if (freezeTimer > 0) freezeTimer -= dt;

            // Timer
            levelTime -= dt;
            if (levelTime <= 0) {
                levelTime = 0;
                playerDeath();
                return;
            }

            // Tick sound at 10 seconds
            if (levelTime <= 10 && levelTime > 0 && Math.floor(levelTime + dt) !== Math.floor(levelTime)) {
                sfx.tick();
            }

            // Harpoons
            for (let i = harpoons.length - 1; i >= 0; i--) {
                const h = harpoons[i];
                h.y -= HARPOON_SPEED * dt;
                if (h.y <= CEIL_H) {
                    harpoons.splice(i, 1);
                }
            }

            // Bubbles
            for (let bi = bubblesList.length - 1; bi >= 0; bi--) {
                const b = bubblesList[bi];

                // Physics (affected by freeze/slow)
                b.vy += GRAVITY * dt * timeScale;
                b.x += b.vx * dt * timeScale;
                b.y += b.vy * dt * timeScale;

                // Trail
                if (timeScale > 0) {
                    b.trail.push({ x: b.x, y: b.y });
                    if (b.trail.length > 6) b.trail.shift();
                }

                // Floor bounce
                const floorY = ARENA_H - FLOOR_H - b.radius;
                if (b.y >= floorY) {
                    b.y = floorY;
                    // Consistent bounce height
                    const tier = BUBBLE_TIERS[b.tier];
                    b.vy = -Math.sqrt(2 * GRAVITY * tier.bounceH);
                }

                // Ceiling bounce
                if (b.y - b.radius <= CEIL_H) {
                    b.y = CEIL_H + b.radius;
                    b.vy = Math.abs(b.vy) * 0.8;
                }

                // Wall bounce
                if (b.x - b.radius <= 0) {
                    b.x = b.radius;
                    b.vx = Math.abs(b.vx);
                }
                if (b.x + b.radius >= ARENA_W) {
                    b.x = ARENA_W - b.radius;
                    b.vx = -Math.abs(b.vx);
                }

                // Harpoon collision
                for (let hi = harpoons.length - 1; hi >= 0; hi--) {
                    const h = harpoons[hi];
                    // Line-circle collision
                    if (h.x >= b.x - b.radius && h.x <= b.x + b.radius &&
                        h.y <= b.y + b.radius && h.base >= b.y - b.radius) {
                        const dx = h.x - b.x;
                        const dy = Math.max(h.y, b.y) - b.y;
                        if (dx * dx + dy * dy <= b.radius * b.radius ||
                            Math.abs(dx) <= b.radius) {
                            // Pop!
                            popBubble(bi);
                            harpoons.splice(hi, 1);
                            break;
                        }
                    }
                }

                // Player collision
                if (invulnTimer <= 0 && activePower !== 'shield') {
                    const dx = b.x - player.x;
                    const dy = b.y - player.y;
                    const pr = 12; // player collision radius
                    if (dx * dx + dy * dy < (b.radius + pr) * (b.radius + pr)) {
                        playerDeath();
                        return;
                    }
                } else if (activePower === 'shield') {
                    const dx = b.x - player.x;
                    const dy = b.y - player.y;
                    const pr = 12;
                    if (dx * dx + dy * dy < (b.radius + pr) * (b.radius + pr)) {
                        activePower = null;
                        powerTimer = 0;
                        document.getElementById('hud-powerup').classList.remove('active');
                        popBubble(bi);
                        shakeAmount = 4;
                        shakeDuration = 0.15;
                        break;
                    }
                }
            }

            // Power-up items
            for (let i = powerupItems.length - 1; i >= 0; i--) {
                const p = powerupItems[i];
                p.vy += 120 * dt;
                p.y += p.vy * dt;
                p.phase += dt;
                p.life -= dt;

                // Floor
                if (p.y >= ARENA_H - FLOOR_H - 10) {
                    p.y = ARENA_H - FLOOR_H - 10;
                    p.vy = 0;
                }

                if (p.life <= 0) {
                    powerupItems.splice(i, 1);
                    continue;
                }

                // Collect
                const dx = p.x - player.x;
                const dy = p.y - player.y;
                if (dx * dx + dy * dy < 25 * 25) {
                    collectPowerup(p);
                    powerupItems.splice(i, 1);
                }
            }

            // Active power-up timer
            if (activePower && activePower !== 'shield') {
                powerTimer -= dt;
                if (powerTimer <= 0) {
                    if (activePower === 'double') maxHarpoons = 1;
                    activePower = null;
                    document.getElementById('hud-powerup').classList.remove('active');
                }
            }

            // Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                if (p.type !== 'ring') {
                    p.x += p.vx * dt;
                    p.y += p.vy * dt;
                    p.vy += 100 * dt; // particle gravity
                }
                p.life -= dt;
                if (p.life <= 0) particles.splice(i, 1);
            }

            // Screen shake
            if (shakeDuration > 0) {
                shakeDuration -= dt;
                shakeAmount *= 0.92;
            }

            // Check level complete
            if (bubblesList.length === 0) {
                completeLevel();
                return;
            }

            // Update HUD
            updateHUD();
        }

        function popBubble(idx) {
            const b = bubblesList[idx];
            const tier = BUBBLE_TIERS[b.tier];

            sfx.pop(b.tier);
            spawnPopParticles(b.x, b.y, b.color, 10 + (4 - b.tier) * 3);
            spawnScoreText(b.x, b.y - 20, '+' + tier.points, b.color);

            score += tier.points;
            bubblesPopped++;
            totalBubblesPopped++;

            maybeSpawnPowerup(b.x, b.y);

            // Split into two smaller bubbles
            if (b.tier < BUBBLE_TIERS.length - 1) {
                const newTier = b.tier + 1;
                const nt = BUBBLE_TIERS[newTier];
                const splitSpeed = nt.speed;

                // Left bubble
                const b1 = createBubble(newTier, b.x - 10, b.y, -splitSpeed);
                b1.vy = -Math.sqrt(2 * GRAVITY * nt.bounceH) * 0.7;
                bubblesList.push(b1);

                // Right bubble
                const b2 = createBubble(newTier, b.x + 10, b.y, splitSpeed);
                b2.vy = -Math.sqrt(2 * GRAVITY * nt.bounceH) * 0.7;
                bubblesList.push(b2);
            }

            bubblesList.splice(idx, 1);

            shakeAmount = 3 + (4 - b.tier);
            shakeDuration = 0.12;
        }

        function collectPowerup(p) {
            sfx.powerup();
            spawnPopParticles(p.x, p.y, POWER_COLORS[p.type], 8);

            if (p.type === 'freeze') {
                freezeTimer = 4;
                sfx.freeze();
            } else if (p.type === 'double') {
                maxHarpoons = 2;
                activePower = 'double';
                powerTimer = 10;
            } else if (p.type === 'shield') {
                activePower = 'shield';
                powerTimer = 999;
            } else if (p.type === 'slow') {
                activePower = 'slow';
                powerTimer = 6;
            }

            const hudPow = document.getElementById('hud-powerup');
            hudPow.textContent = POWER_NAMES[p.type];
            hudPow.classList.add('active');
            if (p.type === 'freeze') {
                setTimeout(() => {
                    if (!activePower) hudPow.classList.remove('active');
                }, 4000);
            }
        }

        function playerDeath() {
            sfx.death();
            spawnDeathEffect(player.x, player.y);
            shakeAmount = 10;
            shakeDuration = 0.3;
            lives--;

            if (lives <= 0) {
                setTimeout(() => showGameOver(), 800);
            } else {
                // Reset position, brief invulnerability
                invulnTimer = 2;
                player.x = ARENA_W / 2;
                harpoons = [];
                activePower = null;
                powerTimer = 0;
                freezeTimer = 0;
                maxHarpoons = 1;
                document.getElementById('hud-powerup').classList.remove('active');
            }
        }

        function completeLevel() {
            sfx.levelComplete();
            const timeBonus = Math.floor(levelTime * 15);
            score += timeBonus;

            state = STATE.LEVEL_COMPLETE;
            document.getElementById('level-title').textContent =
                currentLevel >= LEVELS.length - 1 && Math.floor(currentLevel / LEVELS.length) === 0
                    ? 'All Levels Clear!'
                    : 'Level ' + (currentLevel + 1) + ' Complete!';
            document.getElementById('level-bonus').textContent = 'Time Bonus: +' + timeBonus;
            document.getElementById('level-screen').style.display = 'flex';
        }

        function updateHUD() {
            document.getElementById('hud-score').textContent = score.toLocaleString();
            document.getElementById('hud-level').textContent = 'Level ' + (currentLevel + 1);

            const secs = Math.ceil(levelTime);
            const mins = Math.floor(secs / 60);
            const sec = secs % 60;
            const timerEl = document.getElementById('hud-timer');
            timerEl.textContent = mins + ':' + sec.toString().padStart(2, '0');
            timerEl.className = 'hud-timer' + (secs <= 5 ? ' danger' : secs <= 15 ? ' warning' : '');

            // Lives as hearts
            document.getElementById('hud-lives').textContent = '\u2665'.repeat(lives);
        }

        // ===================== SCREENS =====================
        function showTitle() {
            state = STATE.TITLE;
            document.getElementById('title-screen').style.display = 'flex';
            document.getElementById('gameover-screen').style.display = 'none';
            document.getElementById('level-screen').style.display = 'none';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('pause-overlay').style.display = 'none';

            const hs = document.getElementById('title-highscore');
            if (highScore > 0) {
                hs.textContent = 'Best: ' + highScore.toLocaleString() + ' (Level ' + highLevel + ')';
            }
        }

        function startGame() {
            ensureAudio();
            initGame();
            state = STATE.PLAYING;
            document.getElementById('title-screen').style.display = 'none';
            document.getElementById('gameover-screen').style.display = 'none';
            document.getElementById('level-screen').style.display = 'none';
            document.getElementById('hud').style.display = 'flex';
            document.getElementById('pause-overlay').style.display = 'none';
            updateHUD();
        }

        function nextLevel() {
            document.getElementById('level-screen').style.display = 'none';
            loadLevel(currentLevel + 1);
            state = STATE.PLAYING;
            updateHUD();
        }

        function showGameOver() {
            state = STATE.GAMEOVER;
            document.getElementById('hud').style.display = 'none';

            const newBest = score > highScore;
            if (newBest) {
                highScore = score;
                highLevel = currentLevel + 1;
                localStorage.setItem('bubbleTroubleHigh', highScore.toString());
                localStorage.setItem('bubbleTroubleHighLvl', highLevel.toString());
            }

            const stats = document.getElementById('gameover-stats');
            stats.innerHTML = `
                <div class="stat-row highlight ${newBest ? 'new-best' : ''}">
                    <span class="stat-label">Score</span>
                    <span class="stat-value">${score.toLocaleString()}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Best</span>
                    <span class="stat-value">${highScore.toLocaleString()}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Level</span>
                    <span class="stat-value">${currentLevel + 1}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Bubbles Popped</span>
                    <span class="stat-value">${totalBubblesPopped}</span>
                </div>
            `;
            document.getElementById('gameover-screen').style.display = 'flex';
        }

        function togglePause() {
            if (state === STATE.PLAYING) {
                state = STATE.PAUSED;
                document.getElementById('pause-overlay').style.display = 'flex';
            } else if (state === STATE.PAUSED) {
                state = STATE.PLAYING;
                document.getElementById('pause-overlay').style.display = 'none';
            }
        }

        // ===================== RENDER LOOP =====================
        let lastTime = 0;

        function gameLoop(timestamp) {
            const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
            lastTime = timestamp;

            update(dt);

            ctx.save();
            ctx.scale(scale, scale);

            // Screen shake
            if (shakeDuration > 0) {
                ctx.translate(
                    (Math.random() - 0.5) * shakeAmount * 2,
                    (Math.random() - 0.5) * shakeAmount * 2
                );
            }

            drawBackground(dt);

            if (state === STATE.PLAYING || state === STATE.PAUSED) {
                // Bubbles
                for (const b of bubblesList) drawBubble(b);

                // Harpoons
                for (const h of harpoons) drawHarpoon(h);

                // Power-up items
                for (const p of powerupItems) drawPowerup(p);

                // Player
                drawPlayer();

                // Particles
                drawParticles();

                // Freeze overlay
                if (freezeTimer > 0) {
                    ctx.fillStyle = `rgba(0,191,255,${0.05 + Math.sin(freezeTimer * 5) * 0.03})`;
                    ctx.fillRect(0, 0, ARENA_W, ARENA_H);
                }
            }

            ctx.restore();

            requestAnimationFrame(gameLoop);
        }

        // ===================== START =====================
        initBackground();
        showTitle();
        requestAnimationFrame(gameLoop);

    })();
    </script>
</body>
</html>
