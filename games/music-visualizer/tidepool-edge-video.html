<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tidepool at the Edge of the World — Music Video</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background: #0a1a1f;
            color: #fff;
            font-family: 'Cinzel', serif;
        }
        #viz-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: block;
            cursor: pointer;
        }
        .play-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            background: rgba(10,26,31,0.92);
            cursor: pointer;
            transition: opacity 0.5s;
        }
        .play-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .play-title {
            font-size: clamp(18px, 4vw, 42px);
            font-weight: 700;
            letter-spacing: 0.06em;
            color: #7ec8a0;
            text-shadow: 0 0 30px rgba(126,200,160,0.5), 0 0 60px rgba(126,200,160,0.2);
            margin-bottom: 12px;
            text-align: center;
            padding: 0 20px;
        }
        .play-sub {
            font-size: clamp(11px, 1.8vw, 16px);
            color: rgba(255,255,255,0.45);
            margin-bottom: 40px;
            font-weight: 400;
        }
        .play-btn {
            width: 80px; height: 80px;
            border: 3px solid #7ec8a0;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: pulse 2s ease-in-out infinite;
        }
        .play-btn::after {
            content: '';
            display: block;
            width: 0; height: 0;
            border-style: solid;
            border-width: 18px 0 18px 30px;
            border-color: transparent transparent transparent #7ec8a0;
            margin-left: 6px;
        }
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(126,200,160,0.4); }
            50% { box-shadow: 0 0 0 20px rgba(126,200,160,0); }
        }
        .back-link {
            position: fixed;
            top: 12px; left: 12px;
            z-index: 30;
            color: rgba(255,255,255,0.4);
            text-decoration: none;
            font-size: 13px;
            padding: 6px 10px;
            border-radius: 6px;
            background: rgba(0,0,0,0.4);
            transition: color 0.2s;
            font-family: sans-serif;
        }
        .back-link:hover { color: rgba(255,255,255,0.8); }
    </style>
</head>
<body>
    <a href="music-videos/index.html" class="back-link">&larr; Music Videos</a>
    <canvas id="viz-canvas"></canvas>
    <div class="play-overlay" id="play-overlay">
        <div class="play-title">Tidepool at the Edge of the World</div>
        <div class="play-sub">a celtic coastal exploration</div>
        <div class="play-btn"></div>
    </div>

    <script src="../audio-tracker/playback-engine.js"></script>
    <script src="engine.js"></script>
    <script>
    // ── Tidepool at the Edge of the World — Video Renderer ──
    window.Renderers['tidepool-edge-video'] = (function() {
        "use strict";

        var W = 0, H = 0;
        var analysis = null;

        // ── Celtic Palette ──
        var COL = {
            sky:        '#0a1a2e',
            skyHorizon: '#1a3a4a',
            seaDeep:    '#0c2233',
            seaMid:     '#1a4455',
            seaLight:   '#2a6b6b',
            foam:       '#d4e8e0',
            rock:       '#3a3a3a',
            rockLight:  '#5a5a55',
            rockDark:   '#1a1a18',
            moss:       '#4a7a3a',
            pool:       '#1a5566',
            poolLight:  '#2a8899',
            anemone1:   '#cc4466',
            anemone2:   '#e8a040',
            starfish:   '#d46633',
            fish:       '#55ccdd',
            kelp:       '#2a6633',
            sand:       '#8a7a5a',
            voidBlack:  '#020208',
            starWhite:  '#e8e8ff',
            titleGreen: '#7ec8a0'
        };

        // ── State ──
        var lastBeat = -1;
        var beatPulse = 0;
        var sectionMood = 'shore';
        var lastSeqIndex = -1;
        var elapsed = 0;

        // Wave state
        var wavePhase = 0;
        var foamParticles = [];

        // Tidepool creatures
        var tidepools = [];
        var sailors = [];
        var stars = [];

        // Camera / pullback
        var cameraZoom = 1.0;
        var cameraZoomTarget = 1.0;
        var cameraY = 0;
        var cameraYTarget = 0;
        var titleAlpha = 0;
        var titleTarget = 0;

        // Ripple effects on beats
        var ripples = [];

        // Void reveal
        var voidReveal = 0;
        var voidRevealTarget = 0;

        // ── Section mapping ──
        // Based on pattern names in the song sequence:
        // 0-3: Shore Approach (intro)
        // 4-7: Tidepool Discovery
        // 8-14: Colors of the Pool
        // 15-18: Rising Tide
        // 19-26: Sea Shanty
        // 27-34: Cliff's Edge
        // 35-39: World's End
        // 40-43: Shore Return / Fade
        function mapSection(seqIndex) {
            if (seqIndex <= 3)  return 'shore';
            if (seqIndex <= 7)  return 'tidepool';
            if (seqIndex <= 14) return 'colors';
            if (seqIndex <= 18) return 'risingtide';
            if (seqIndex <= 26) return 'shanty';
            if (seqIndex <= 34) return 'cliff';
            if (seqIndex <= 39) return 'worldsend';
            return 'fade';
        }

        // ── Helpers ──
        function lerp(a, b, t) { return a + (b - a) * t; }
        function lerpSmooth(current, target, speed, dt) {
            return current + (target - current) * (1 - Math.exp(-speed * dt));
        }
        function hexToRgb(hex) {
            return {
                r: parseInt(hex.slice(1,3), 16),
                g: parseInt(hex.slice(3,5), 16),
                b: parseInt(hex.slice(5,7), 16)
            };
        }
        function rgba(hex, a) {
            var c = hexToRgb(hex);
            return 'rgba(' + c.r + ',' + c.g + ',' + c.b + ',' + a + ')';
        }

        // ── Init ──
        function init(ctx, width, height, anal) {
            W = width; H = height;
            analysis = anal;
            lastBeat = -1;
            beatPulse = 0;
            sectionMood = 'shore';
            lastSeqIndex = -1;
            elapsed = 0;
            wavePhase = 0;
            cameraZoom = 1.0;
            cameraZoomTarget = 1.0;
            cameraY = 0;
            cameraYTarget = 0;
            titleAlpha = 0;
            titleTarget = 0;
            voidReveal = 0;
            voidRevealTarget = 0;
            ripples = [];

            initFoam();
            initTidepools();
            initSailors();
            initStars();
        }

        function resize(width, height) {
            W = width; H = height;
            initTidepools();
            initSailors();
        }

        // ── Foam particles ──
        function initFoam() {
            foamParticles = [];
            for (var i = 0; i < 60; i++) {
                foamParticles.push({
                    x: Math.random() * 2000,
                    y: Math.random() * 30,
                    size: 1 + Math.random() * 3,
                    speed: 10 + Math.random() * 30,
                    alpha: 0.3 + Math.random() * 0.5,
                    phase: Math.random() * Math.PI * 2
                });
            }
        }

        // ── Tidepools ──
        function initTidepools() {
            tidepools = [];
            var poolCount = 5;
            for (var i = 0; i < poolCount; i++) {
                var pool = {
                    x: W * (0.15 + i * 0.15 + (Math.random() - 0.5) * 0.05),
                    y: H * (0.55 + Math.random() * 0.12),
                    rx: 25 + Math.random() * 35,
                    ry: 12 + Math.random() * 18,
                    creatures: []
                };
                // Add creatures
                var numCreatures = 2 + Math.floor(Math.random() * 4);
                for (var j = 0; j < numCreatures; j++) {
                    var type = ['anemone', 'starfish', 'fish', 'kelp'][Math.floor(Math.random() * 4)];
                    pool.creatures.push({
                        type: type,
                        ox: (Math.random() - 0.5) * pool.rx * 1.2,
                        oy: (Math.random() - 0.5) * pool.ry * 0.8,
                        size: 3 + Math.random() * 5,
                        phase: Math.random() * Math.PI * 2,
                        color: type === 'anemone' ? (Math.random() > 0.5 ? COL.anemone1 : COL.anemone2) :
                               type === 'starfish' ? COL.starfish :
                               type === 'fish' ? COL.fish : COL.kelp
                    });
                }
                tidepools.push(pool);
            }
        }

        // ── Sailors ──
        function initSailors() {
            sailors = [];
            for (var i = 0; i < 6; i++) {
                sailors.push({
                    x: W * (0.2 + i * 0.1),
                    baseY: H * 0.42,
                    armPhase: Math.random() * Math.PI * 2,
                    armSpeed: 1.5 + Math.random() * 0.5,
                    height: 30 + Math.random() * 10,
                    active: false
                });
            }
        }

        // ── Stars (for void) ──
        function initStars() {
            stars = [];
            for (var i = 0; i < 200; i++) {
                stars.push({
                    x: Math.random(),
                    y: Math.random(),
                    size: 0.5 + Math.random() * 2,
                    twinkle: Math.random() * Math.PI * 2,
                    speed: 0.5 + Math.random() * 2
                });
            }
        }

        // ── Draw sky ──
        function drawSky(ctx, energy) {
            var grad = ctx.createLinearGradient(0, 0, 0, H * 0.5);
            if (sectionMood === 'worldsend' || sectionMood === 'fade') {
                grad.addColorStop(0, COL.voidBlack);
                grad.addColorStop(0.6, '#0a0a18');
                grad.addColorStop(1, COL.skyHorizon);
            } else {
                grad.addColorStop(0, COL.sky);
                grad.addColorStop(0.7, COL.skyHorizon);
                grad.addColorStop(1, '#2a5a6a');
            }
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, W, H * 0.55);

            // Stars visible in darker sections
            var starAlpha = 0;
            if (sectionMood === 'shore') starAlpha = 0.3;
            else if (sectionMood === 'cliff' || sectionMood === 'worldsend') starAlpha = 0.6 + voidReveal * 0.4;
            else if (sectionMood === 'fade') starAlpha = 0.8;
            else starAlpha = 0.15;

            if (starAlpha > 0.01) {
                ctx.save();
                for (var i = 0; i < stars.length; i++) {
                    var s = stars[i];
                    var twinkle = 0.5 + 0.5 * Math.sin(s.twinkle + elapsed * s.speed);
                    ctx.globalAlpha = starAlpha * twinkle * s.size * 0.4;
                    ctx.fillStyle = COL.starWhite;
                    ctx.beginPath();
                    ctx.arc(s.x * W, s.y * H * 0.45, s.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }
        }

        // ── Draw ocean waves ──
        function drawOcean(ctx, energy) {
            var horizonY = H * 0.38;
            var shoreY = H * 0.52;

            // Draw several wave layers
            for (var layer = 0; layer < 4; layer++) {
                var layerT = layer / 3;
                var y = lerp(horizonY, shoreY, layerT);
                var amp = 3 + layer * 4 + energy * 6;
                var freq = 0.008 - layer * 0.001;
                var speed = wavePhase * (0.8 + layer * 0.3);

                var deepC = hexToRgb(COL.seaDeep);
                var lightC = hexToRgb(COL.seaLight);
                var t = layerT;
                var r = Math.round(lerp(deepC.r, lightC.r, t));
                var g = Math.round(lerp(deepC.g, lightC.g, t));
                var b = Math.round(lerp(deepC.b, lightC.b, t));

                ctx.fillStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
                ctx.beginPath();
                ctx.moveTo(0, H);
                for (var x = 0; x <= W; x += 4) {
                    var wave = Math.sin(x * freq + speed) * amp
                             + Math.sin(x * freq * 2.3 + speed * 1.7) * amp * 0.3
                             + beatPulse * 4 * Math.sin(x * 0.02 + speed * 3);
                    ctx.lineTo(x, y + wave);
                }
                ctx.lineTo(W, H);
                ctx.closePath();
                ctx.fill();

                // Foam on wave crests (top 2 layers only)
                if (layer <= 1) {
                    ctx.save();
                    ctx.globalAlpha = 0.3 + energy * 0.2;
                    ctx.strokeStyle = COL.foam;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    for (var fx = 0; fx <= W; fx += 4) {
                        var fwave = Math.sin(fx * freq + speed) * amp
                                  + Math.sin(fx * freq * 2.3 + speed * 1.7) * amp * 0.3;
                        if (fx === 0) ctx.moveTo(fx, y + fwave);
                        else ctx.lineTo(fx, y + fwave);
                    }
                    ctx.stroke();
                    ctx.restore();
                }
            }

            // Shore foam particles
            ctx.save();
            for (var fi = 0; fi < foamParticles.length; fi++) {
                var fp = foamParticles[fi];
                var fpx = ((fp.x + elapsed * fp.speed) % (W + 40)) - 20;
                var fpy = shoreY - 5 + fp.y + Math.sin(fp.phase + elapsed * 2) * 3;
                ctx.globalAlpha = fp.alpha * (0.3 + energy * 0.3);
                ctx.fillStyle = COL.foam;
                ctx.beginPath();
                ctx.arc(fpx, fpy, fp.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        // ── Draw rocky coastline ──
        function drawRocks(ctx, energy) {
            var baseY = H * 0.52;

            // Main rock formation - jagged coastline
            ctx.fillStyle = COL.rock;
            ctx.beginPath();
            ctx.moveTo(0, H);
            ctx.lineTo(0, baseY - 20);

            // Rocky profile
            var rockPoints = [
                [0.0, -20], [0.04, -35], [0.08, -15], [0.12, -45],
                [0.16, -25], [0.20, -50], [0.24, -30], [0.28, -55],
                [0.32, -20], [0.36, -40], [0.40, -15], [0.44, -35],
                [0.48, -10], [0.52, -30], [0.56, -5], [0.60, -25],
                [0.64, -8], [0.68, -15], [0.72, 0], [0.76, -10],
                [0.80, 5], [0.84, -5], [0.88, 10], [0.92, 0],
                [0.96, 5], [1.0, 0]
            ];

            for (var ri = 0; ri < rockPoints.length; ri++) {
                var rp = rockPoints[ri];
                ctx.lineTo(rp[0] * W, baseY + rp[1]);
            }
            ctx.lineTo(W, H);
            ctx.closePath();
            ctx.fill();

            // Rock highlights
            ctx.save();
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = COL.rockLight;
            for (var hi = 0; hi < rockPoints.length - 1; hi++) {
                var hp = rockPoints[hi];
                if (hp[1] < -20) {
                    ctx.beginPath();
                    ctx.arc(hp[0] * W + 5, baseY + hp[1] + 5, 8 + Math.random() * 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.restore();

            // Moss patches
            ctx.save();
            ctx.globalAlpha = 0.4;
            ctx.fillStyle = COL.moss;
            for (var mi = 0; mi < 8; mi++) {
                var mx = W * (0.05 + mi * 0.12);
                var my = baseY - 10 + Math.sin(mi * 1.7) * 15;
                ctx.beginPath();
                ctx.ellipse(mx, my, 12 + mi * 2, 4, 0.2, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        // ── Draw tidepools with creatures ──
        function drawTidepools(ctx, energy) {
            var poolVisible = (sectionMood === 'tidepool' || sectionMood === 'colors' ||
                              sectionMood === 'risingtide');
            var poolAlpha = poolVisible ? 1.0 : (sectionMood === 'shore' ? 0.3 : 0.2);

            for (var pi = 0; pi < tidepools.length; pi++) {
                var pool = tidepools[pi];
                ctx.save();

                // Pool water
                ctx.globalAlpha = poolAlpha;
                ctx.fillStyle = COL.pool;
                ctx.beginPath();
                ctx.ellipse(pool.x, pool.y, pool.rx, pool.ry, 0, 0, Math.PI * 2);
                ctx.fill();

                // Pool water shimmer
                ctx.fillStyle = COL.poolLight;
                ctx.globalAlpha = poolAlpha * (0.2 + beatPulse * 0.3);
                ctx.beginPath();
                ctx.ellipse(pool.x - pool.rx * 0.2, pool.y - pool.ry * 0.2,
                           pool.rx * 0.4, pool.ry * 0.3, 0.3, 0, Math.PI * 2);
                ctx.fill();

                // Rock rim
                ctx.globalAlpha = poolAlpha;
                ctx.strokeStyle = COL.rockDark;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.ellipse(pool.x, pool.y, pool.rx + 2, pool.ry + 2, 0, 0, Math.PI * 2);
                ctx.stroke();

                // Creatures
                if (poolVisible) {
                    for (var ci = 0; ci < pool.creatures.length; ci++) {
                        var cr = pool.creatures[ci];
                        var cx = pool.x + cr.ox;
                        var cy = pool.y + cr.oy;
                        var anim = Math.sin(cr.phase + elapsed * 2);

                        ctx.globalAlpha = poolAlpha * 0.9;
                        ctx.fillStyle = cr.color;

                        if (cr.type === 'anemone') {
                            // Waving tentacles
                            ctx.save();
                            ctx.lineWidth = 1.5;
                            ctx.strokeStyle = cr.color;
                            for (var t = 0; t < 5; t++) {
                                var ta = (t / 4 - 0.5) * 0.8;
                                var sway = Math.sin(cr.phase + elapsed * 3 + t * 0.7) * 4 * (1 + energy * 0.5);
                                ctx.beginPath();
                                ctx.moveTo(cx + ta * cr.size * 2, cy + cr.size);
                                ctx.quadraticCurveTo(
                                    cx + ta * cr.size * 2 + sway, cy - cr.size * 0.5,
                                    cx + ta * cr.size * 2 + sway * 1.5, cy - cr.size * 1.5
                                );
                                ctx.stroke();
                            }
                            // Base
                            ctx.fillStyle = cr.color;
                            ctx.globalAlpha = poolAlpha * 0.6;
                            ctx.beginPath();
                            ctx.ellipse(cx, cy + cr.size, cr.size * 1.2, cr.size * 0.4, 0, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        } else if (cr.type === 'starfish') {
                            // 5-pointed star shape
                            ctx.save();
                            ctx.translate(cx, cy);
                            ctx.rotate(cr.phase + elapsed * 0.2);
                            ctx.beginPath();
                            for (var si = 0; si < 10; si++) {
                                var angle = (si / 10) * Math.PI * 2 - Math.PI / 2;
                                var rad = si % 2 === 0 ? cr.size * 1.2 : cr.size * 0.5;
                                if (si === 0) ctx.moveTo(Math.cos(angle) * rad, Math.sin(angle) * rad);
                                else ctx.lineTo(Math.cos(angle) * rad, Math.sin(angle) * rad);
                            }
                            ctx.closePath();
                            ctx.fill();
                            ctx.restore();
                        } else if (cr.type === 'fish') {
                            // Simple swimming fish
                            var swimX = cx + Math.sin(cr.phase + elapsed * 3) * 8;
                            var dir = Math.cos(cr.phase + elapsed * 3) > 0 ? 1 : -1;
                            ctx.save();
                            ctx.translate(swimX, cy);
                            ctx.scale(dir, 1);
                            // Body
                            ctx.beginPath();
                            ctx.ellipse(0, 0, cr.size * 1.5, cr.size * 0.7, 0, 0, Math.PI * 2);
                            ctx.fill();
                            // Tail
                            ctx.beginPath();
                            ctx.moveTo(-cr.size * 1.5, 0);
                            ctx.lineTo(-cr.size * 2.5, -cr.size * 0.8);
                            ctx.lineTo(-cr.size * 2.5, cr.size * 0.8);
                            ctx.closePath();
                            ctx.fill();
                            // Eye
                            ctx.fillStyle = '#fff';
                            ctx.beginPath();
                            ctx.arc(cr.size * 0.6, -cr.size * 0.15, cr.size * 0.2, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        } else if (cr.type === 'kelp') {
                            // Wavy kelp strand
                            ctx.save();
                            ctx.strokeStyle = cr.color;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(cx, cy + cr.size * 2);
                            var ksway = Math.sin(cr.phase + elapsed * 1.5) * 5;
                            ctx.quadraticCurveTo(
                                cx + ksway, cy,
                                cx + ksway * 0.5, cy - cr.size * 2
                            );
                            ctx.stroke();
                            // Leaf blobs
                            ctx.fillStyle = cr.color;
                            ctx.globalAlpha = poolAlpha * 0.7;
                            ctx.beginPath();
                            ctx.ellipse(cx + ksway * 0.3, cy - cr.size, cr.size * 0.6, cr.size * 0.3, ksway * 0.1, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        }
                    }
                }

                ctx.restore();
            }
        }

        // ── Draw beat ripples ──
        function drawRipples(ctx) {
            ctx.save();
            for (var i = ripples.length - 1; i >= 0; i--) {
                var rip = ripples[i];
                rip.radius += rip.speed;
                rip.alpha -= 0.015;
                if (rip.alpha <= 0) {
                    ripples.splice(i, 1);
                    continue;
                }
                ctx.globalAlpha = rip.alpha;
                ctx.strokeStyle = COL.poolLight;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(rip.x, rip.y, rip.radius, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.restore();
        }

        // ── Draw sailors (sea shanty section) ──
        function drawSailors(ctx, energy) {
            var shantyActive = (sectionMood === 'shanty');
            var sailorAlpha = shantyActive ? 1.0 : 0;

            if (sailorAlpha < 0.01) return;

            ctx.save();
            ctx.globalAlpha = sailorAlpha;

            for (var i = 0; i < sailors.length; i++) {
                var s = sailors[i];
                var figH = s.height;
                var sx = s.x;
                var sy = s.baseY;

                // Sway with beat
                var sway = Math.sin(s.armPhase + elapsed * s.armSpeed) * 8 * energy;
                var armAngle = Math.sin(s.armPhase + elapsed * s.armSpeed * 0.8) * 0.6;
                var bodyLean = sway * 0.15;

                // Silhouette color - dark with slight highlight
                ctx.fillStyle = '#1a2833';
                ctx.strokeStyle = '#1a2833';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';

                // Head
                ctx.beginPath();
                ctx.arc(sx + bodyLean, sy - figH * 0.85, figH * 0.12, 0, Math.PI * 2);
                ctx.fill();

                // Body
                ctx.beginPath();
                ctx.moveTo(sx + bodyLean, sy - figH * 0.72);
                ctx.lineTo(sx + bodyLean * 0.5, sy - figH * 0.2);
                ctx.stroke();

                // Left arm - swaying in unison
                ctx.beginPath();
                ctx.moveTo(sx + bodyLean * 0.8 - figH * 0.12, sy - figH * 0.6);
                ctx.lineTo(
                    sx + bodyLean - figH * 0.25 + Math.sin(armAngle) * figH * 0.15,
                    sy - figH * 0.6 - Math.cos(armAngle) * figH * 0.25
                );
                ctx.stroke();

                // Right arm - swaying opposite
                ctx.beginPath();
                ctx.moveTo(sx + bodyLean * 0.8 + figH * 0.12, sy - figH * 0.6);
                ctx.lineTo(
                    sx + bodyLean + figH * 0.25 + Math.sin(-armAngle) * figH * 0.15,
                    sy - figH * 0.6 - Math.cos(-armAngle) * figH * 0.25
                );
                ctx.stroke();

                // Legs
                ctx.beginPath();
                ctx.moveTo(sx + bodyLean * 0.5, sy - figH * 0.2);
                ctx.lineTo(sx - figH * 0.08, sy);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(sx + bodyLean * 0.5, sy - figH * 0.2);
                ctx.lineTo(sx + figH * 0.08, sy);
                ctx.stroke();
            }
            ctx.restore();
        }

        // ── Draw cliff edge (world's edge reveal) ──
        function drawCliffEdge(ctx, energy) {
            if (voidReveal < 0.01) return;

            var cliffX = W * (0.85 - voidReveal * 0.15);
            var cliffTopY = H * 0.52;

            ctx.save();

            // Void below the cliff
            var voidGrad = ctx.createLinearGradient(cliffX, cliffTopY, cliffX, H);
            voidGrad.addColorStop(0, COL.voidBlack);
            voidGrad.addColorStop(1, COL.voidBlack);
            ctx.fillStyle = voidGrad;
            ctx.globalAlpha = voidReveal;
            ctx.fillRect(cliffX, cliffTopY - 10, W - cliffX + 10, H - cliffTopY + 20);

            // Stars in the void below
            ctx.fillStyle = COL.starWhite;
            for (var i = 0; i < stars.length; i++) {
                var st = stars[i];
                var stx = cliffX + st.x * (W - cliffX);
                var sty = cliffTopY + st.y * (H - cliffTopY);
                var twinkle = 0.3 + 0.7 * Math.sin(st.twinkle + elapsed * st.speed * 1.5);
                ctx.globalAlpha = voidReveal * twinkle * 0.8;
                ctx.beginPath();
                ctx.arc(stx, sty, st.size * 0.8, 0, Math.PI * 2);
                ctx.fill();
            }

            // Cliff face - sheer drop
            ctx.globalAlpha = voidReveal;
            var faceGrad = ctx.createLinearGradient(cliffX - 15, 0, cliffX + 5, 0);
            faceGrad.addColorStop(0, COL.rock);
            faceGrad.addColorStop(0.5, COL.rockDark);
            faceGrad.addColorStop(1, COL.voidBlack);
            ctx.fillStyle = faceGrad;
            ctx.fillRect(cliffX - 15, cliffTopY - 30, 20, H - cliffTopY + 40);

            // Jagged cliff edge detail
            ctx.strokeStyle = COL.rockLight;
            ctx.lineWidth = 2;
            ctx.globalAlpha = voidReveal * 0.6;
            ctx.beginPath();
            ctx.moveTo(cliffX - 5, cliffTopY - 30);
            for (var j = 0; j < 15; j++) {
                var jy = cliffTopY - 20 + j * ((H - cliffTopY + 30) / 14);
                var jx = cliffX - 5 + (Math.random() - 0.5) * 8;
                ctx.lineTo(jx, jy);
            }
            ctx.stroke();

            // Waterfall going over the edge
            if (energy > 0.3) {
                ctx.globalAlpha = voidReveal * energy * 0.4;
                ctx.strokeStyle = COL.seaLight;
                ctx.lineWidth = 3;
                for (var w = 0; w < 3; w++) {
                    ctx.beginPath();
                    var wx = cliffX - 8 + w * 5;
                    ctx.moveTo(wx, cliffTopY);
                    ctx.quadraticCurveTo(
                        wx + 10 + Math.sin(elapsed * 3 + w) * 5,
                        cliffTopY + (H - cliffTopY) * 0.5,
                        wx + 20,
                        H
                    );
                    ctx.stroke();
                }
            }

            ctx.restore();
        }

        // ── Draw title ──
        function drawTitle(ctx) {
            if (titleAlpha < 0.01) return;

            ctx.save();
            ctx.globalAlpha = titleAlpha;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            var fontSize = Math.max(14, Math.min(W * 0.032, 38));
            ctx.font = '700 ' + fontSize + 'px "Cinzel", serif';
            ctx.fillStyle = COL.titleGreen;
            ctx.shadowColor = COL.titleGreen;
            ctx.shadowBlur = 30;
            ctx.fillText('TIDEPOOL AT THE EDGE OF THE WORLD', W * 0.5, H * 0.15);

            // Subtle underline
            ctx.strokeStyle = COL.titleGreen;
            ctx.lineWidth = 1;
            ctx.globalAlpha = titleAlpha * 0.4;
            ctx.shadowBlur = 10;
            var tw = ctx.measureText('TIDEPOOL AT THE EDGE OF THE WORLD').width;
            ctx.beginPath();
            ctx.moveTo(W * 0.5 - tw * 0.5, H * 0.15 + fontSize * 0.7);
            ctx.lineTo(W * 0.5 + tw * 0.5, H * 0.15 + fontSize * 0.7);
            ctx.stroke();

            ctx.restore();
        }

        // ── Draw camera zoom effect (world pulling back) ──
        function applyCamera(ctx) {
            if (Math.abs(cameraZoom - 1.0) < 0.001 && Math.abs(cameraY) < 0.5) return;

            ctx.translate(W * 0.5, H * 0.5);
            ctx.scale(cameraZoom, cameraZoom);
            ctx.translate(-W * 0.5, -H * 0.5 + cameraY);
        }

        // ── Main render ──
        function render(frameData) {
            var ctx = frameData.ctx;
            var dt = frameData.dt || 1/60;
            var cursor = frameData.cursor;

            elapsed += dt;
            wavePhase += dt * 1.2;

            // ── Background fill ──
            ctx.fillStyle = COL.voidBlack;
            ctx.fillRect(0, 0, W, H);

            if (!cursor) {
                // Idle state
                ctx.save();
                drawSky(ctx, 0);
                drawOcean(ctx, 0);
                drawRocks(ctx, 0);
                ctx.restore();
                return;
            }

            var beat = cursor.beat;
            var seqIdx = cursor.seqIndex;
            var energy = analysis ? (analysis.energy[cursor.timelineIndex] || 0) : 0;

            // ── Section transitions ──
            var newSection = mapSection(seqIdx);
            if (seqIdx !== lastSeqIndex) {
                sectionMood = newSection;
                lastSeqIndex = seqIdx;
            }

            // ── Beat pulse ──
            if (beat !== lastBeat) {
                beatPulse = 1;

                // Add ripples to random tidepools on beats
                if (tidepools.length > 0 && (sectionMood === 'tidepool' || sectionMood === 'colors')) {
                    var poolIdx = Math.floor(Math.random() * tidepools.length);
                    ripples.push({
                        x: tidepools[poolIdx].x,
                        y: tidepools[poolIdx].y,
                        radius: 3,
                        speed: 1.5 + energy * 2,
                        alpha: 0.6 + energy * 0.3
                    });
                }

                // Ocean ripples during shanty
                if (sectionMood === 'shanty') {
                    ripples.push({
                        x: W * (0.2 + Math.random() * 0.6),
                        y: H * (0.42 + Math.random() * 0.08),
                        radius: 5,
                        speed: 2 + energy,
                        alpha: 0.4
                    });
                }

                lastBeat = beat;
            }

            beatPulse *= Math.exp(-8 * dt);

            // ── Section-specific targets ──
            switch (sectionMood) {
                case 'shore':
                    cameraZoomTarget = 1.0;
                    cameraYTarget = 0;
                    titleTarget = 0.6;
                    voidRevealTarget = 0;
                    break;
                case 'tidepool':
                    cameraZoomTarget = 1.05;
                    cameraYTarget = 20;
                    titleTarget = 0;
                    voidRevealTarget = 0;
                    break;
                case 'colors':
                    cameraZoomTarget = 1.1;
                    cameraYTarget = 30;
                    titleTarget = 0;
                    voidRevealTarget = 0;
                    break;
                case 'risingtide':
                    cameraZoomTarget = 1.0;
                    cameraYTarget = 10;
                    titleTarget = 0.4;
                    voidRevealTarget = 0;
                    break;
                case 'shanty':
                    cameraZoomTarget = 1.0;
                    cameraYTarget = -10;
                    titleTarget = 0.8;
                    voidRevealTarget = 0;
                    break;
                case 'cliff':
                    var cliffProgress = (seqIdx - 27) / 7;
                    cameraZoomTarget = 1.0 - cliffProgress * 0.15;
                    cameraYTarget = -20 - cliffProgress * 30;
                    titleTarget = 0.5;
                    voidRevealTarget = Math.min(1, cliffProgress * 1.3);
                    break;
                case 'worldsend':
                    cameraZoomTarget = 0.75;
                    cameraYTarget = -60;
                    titleTarget = 1.0;
                    voidRevealTarget = 1.0;
                    break;
                case 'fade':
                    cameraZoomTarget = 0.65;
                    cameraYTarget = -80;
                    titleTarget = 0;
                    voidRevealTarget = 1.0;
                    break;
            }

            // ── Smooth transitions ──
            cameraZoom = lerpSmooth(cameraZoom, cameraZoomTarget, 1.5, dt);
            cameraY = lerpSmooth(cameraY, cameraYTarget, 1.5, dt);
            titleAlpha = lerpSmooth(titleAlpha, titleTarget, 3, dt);
            voidReveal = lerpSmooth(voidReveal, voidRevealTarget, 2, dt);

            // ── Draw scene ──
            ctx.save();
            applyCamera(ctx);

            drawSky(ctx, energy);
            drawOcean(ctx, energy);
            drawRocks(ctx, energy);
            drawTidepools(ctx, energy);
            drawRipples(ctx);
            drawSailors(ctx, energy);
            drawCliffEdge(ctx, energy);

            ctx.restore();

            // Title drawn outside camera transform
            drawTitle(ctx);

            // ── Fade overlay for fade section ──
            if (sectionMood === 'fade') {
                var fadeProgress = 0;
                if (seqIdx >= 40) {
                    fadeProgress = Math.min(1, (seqIdx - 40) / 3);
                }
                if (fadeProgress > 0.01) {
                    ctx.save();
                    ctx.globalAlpha = fadeProgress * 0.8;
                    ctx.fillStyle = COL.voidBlack;
                    ctx.fillRect(0, 0, W, H);
                    ctx.restore();
                }
            }
        }

        return {
            name: 'Tidepool at the Edge of the World',
            init: init,
            render: render,
            resize: resize
        };
    })();

    // ── Page bootstrap ──
    (function() {
        var canvas = document.getElementById('viz-canvas');
        var overlay = document.getElementById('play-overlay');

        Visualizer.init(canvas);
        Visualizer.setRenderer('tidepool-edge-video');

        function loadAndPlay(json) {
            Visualizer.loadSong(json);
            Visualizer.play();
        }

        function fetchSong() {
            var url = '../audio-tracker/songs/tidepool-at-the-edge-of-the-world.json';
            if (window.fetch && location.protocol !== 'file:') {
                return fetch(url).then(function(r) { return r.json(); });
            }
            return new Promise(function(resolve, reject) {
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.onload = function() {
                    if (xhr.status === 200 || xhr.status === 0) {
                        resolve(JSON.parse(xhr.responseText));
                    } else {
                        reject(new Error('XHR failed: ' + xhr.status));
                    }
                };
                xhr.onerror = function() { reject(new Error('XHR error')); };
                xhr.send();
            });
        }

        overlay.addEventListener('click', function() {
            overlay.classList.add('hidden');
            fetchSong().then(loadAndPlay).catch(function(err) {
                console.error('Failed to load song:', err);
                overlay.classList.remove('hidden');
            });
        });

        canvas.addEventListener('click', function() {
            if (overlay.classList.contains('hidden')) {
                if (Visualizer.isPlaying()) {
                    Visualizer.stop();
                } else {
                    Visualizer.play();
                }
            }
        });
    })();
    </script>
</body>
</html>
