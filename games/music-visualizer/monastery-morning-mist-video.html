<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monastery of the Morning Mist — Music Video</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background: #0d1117;
            color: #e8dcc8;
            font-family: 'Noto Serif JP', serif;
        }
        #viz-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: block;
            cursor: pointer;
        }
        .play-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            background: rgba(13,17,23,0.94);
            cursor: pointer;
            transition: opacity 0.5s;
        }
        .play-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .play-title {
            font-size: clamp(18px, 4.5vw, 42px);
            font-weight: 700;
            letter-spacing: 0.06em;
            color: #c9a84c;
            text-shadow: 0 0 30px rgba(201,168,76,0.4), 0 0 60px rgba(201,168,76,0.15);
            margin-bottom: 12px;
        }
        .play-sub {
            font-size: clamp(11px, 1.8vw, 16px);
            color: rgba(232,220,200,0.45);
            margin-bottom: 40px;
        }
        .play-btn {
            width: 80px; height: 80px;
            border: 2px solid #c9a84c;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: pulse 3s ease-in-out infinite;
        }
        .play-btn::after {
            content: '';
            display: block;
            width: 0; height: 0;
            border-style: solid;
            border-width: 16px 0 16px 26px;
            border-color: transparent transparent transparent #c9a84c;
            margin-left: 5px;
        }
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(201,168,76,0.3); }
            50% { box-shadow: 0 0 0 18px rgba(201,168,76,0); }
        }
        .back-link {
            position: fixed;
            top: 12px; left: 12px;
            z-index: 30;
            color: rgba(232,220,200,0.35);
            text-decoration: none;
            font-size: 13px;
            padding: 6px 10px;
            border-radius: 6px;
            background: rgba(0,0,0,0.4);
            transition: color 0.2s;
        }
        .back-link:hover { color: rgba(232,220,200,0.8); }
    </style>
</head>
<body>
    <a href="music-videos/index.html" class="back-link">&larr; Music Videos</a>
    <canvas id="viz-canvas"></canvas>
    <div class="play-overlay" id="play-overlay">
        <div class="play-title">Monastery of the Morning Mist</div>
        <div class="play-sub">a mountain dawn music video</div>
        <div class="play-btn"></div>
    </div>

    <script src="../audio-tracker/playback-engine.js"></script>
    <script src="engine.js"></script>
    <script>
    // ── Monastery of the Morning Mist Video Renderer ──────────────
    window.Renderers['monastery-morning-mist-video'] = (function() {
        "use strict";

        var W = 0, H = 0;
        var analysis = null;

        // ── Color Palette ──
        var COL = {
            nightSky:    '#0d1117',
            dawnLow:     '#1a1520',
            dawnMid:     '#3d2233',
            dawnWarm:    '#8b4a2f',
            dawnGold:    '#c9a84c',
            dawnPink:    '#d4856a',
            skyBlue:     '#5a7fa0',
            dayLight:    '#b8cce0',
            fog:         '#8a9aaa',
            fogLight:    '#c4cdd6',
            mountain:    '#2a3040',
            mountainMid: '#3a4558',
            mountainFar: '#4a5568',
            bamboo:      '#3a5a3a',
            bambooBright:'#5a8a4a',
            temple:      '#1e1e28',
            templeRoof:  '#6b3a3a',
            templeWood:  '#4a3a2e',
            bell:        '#c9a84c',
            monk:        '#8b6914',
            monkRobe:    '#b85c1a',
            grass:       '#2a4a2a',
            water:       '#2a3a5a',
            valleyGreen: '#4a7a4a',
            snow:        '#dde8f0'
        };

        // ── State ──
        var lastBeat = -1;
        var beatPulse = 0;
        var bellPulse = 0;
        var sectionMood = 'mist';
        var lastSeqIndex = -1;

        // Fog particles
        var fogParticles = [];
        var NUM_FOG = 120;

        // Bamboo stalks
        var bambooStalks = [];
        var NUM_BAMBOO = 30;

        // Monks
        var monks = [];
        var NUM_MONKS = 7;

        // Mountain layers
        var mountains = [];

        // Scene progression
        var fogDensity = 1.0;
        var fogTarget = 1.0;
        var dawnProgress = 0;
        var dawnTarget = 0;
        var valleyReveal = 0;
        var valleyTarget = 0;
        var titleAlpha = 0;
        var titleTarget = 0;
        var outroFade = 0;

        // ── Section mapping ──
        // seq 0-2: mist (intro, lone flute)
        // seq 3-4: temple (bells join)
        // seq 5-8: chant (monks morning routine, dawn starts)
        // seq 9-12: chant2 (more monks, dawn brightens)
        // seq 13-15: wind (building energy, mountain wind)
        // seq 16-19: wind2 (building peaks)
        // seq 19-22: clearing (valley starts revealing)
        // seq 23-26: clearing2 (full reveal)
        // seq 27-31: panorama (breathtaking valley)
        // seq 32-33: fading (peaceful wind-down)
        // seq 34-36: stillness (outro)
        function mapSection(seqIdx) {
            if (seqIdx <= 2) return 'mist';
            if (seqIdx <= 4) return 'temple';
            if (seqIdx <= 8) return 'chant';
            if (seqIdx <= 12) return 'chant2';
            if (seqIdx <= 15) return 'wind';
            if (seqIdx <= 18) return 'wind2';
            if (seqIdx <= 22) return 'clearing';
            if (seqIdx <= 26) return 'clearing2';
            if (seqIdx <= 31) return 'panorama';
            if (seqIdx <= 33) return 'fading';
            return 'stillness';
        }

        // ── Pseudo-random with seed ──
        function seededRandom(seed) {
            var x = Math.sin(seed * 12.9898 + 78.233) * 43758.5453;
            return x - Math.floor(x);
        }

        // ── Init fog ──
        function initFog() {
            fogParticles = [];
            for (var i = 0; i < NUM_FOG; i++) {
                fogParticles.push({
                    x: Math.random() * W * 1.4 - W * 0.2,
                    y: H * 0.2 + Math.random() * H * 0.7,
                    w: 60 + Math.random() * 200,
                    h: 20 + Math.random() * 60,
                    speed: 5 + Math.random() * 20,
                    alpha: 0.03 + Math.random() * 0.08,
                    layer: Math.floor(Math.random() * 3)
                });
            }
        }

        // ── Init bamboo ──
        function initBamboo() {
            bambooStalks = [];
            for (var i = 0; i < NUM_BAMBOO; i++) {
                var x = W * 0.02 + (i / NUM_BAMBOO) * W * 0.25;
                if (i > NUM_BAMBOO / 2) {
                    x = W * 0.73 + ((i - NUM_BAMBOO / 2) / (NUM_BAMBOO / 2)) * W * 0.25;
                }
                bambooStalks.push({
                    x: x + (Math.random() - 0.5) * 40,
                    height: H * 0.3 + Math.random() * H * 0.4,
                    sway: Math.random() * Math.PI * 2,
                    thickness: 2 + Math.random() * 3,
                    segments: 4 + Math.floor(Math.random() * 4),
                    leaves: 3 + Math.floor(Math.random() * 5)
                });
            }
        }

        // ── Init monks ──
        function initMonks() {
            monks = [];
            for (var i = 0; i < NUM_MONKS; i++) {
                monks.push({
                    x: W * 0.3 + (i / NUM_MONKS) * W * 0.4,
                    baseY: H * 0.68 + (Math.random() - 0.5) * H * 0.06,
                    phase: Math.random() * Math.PI * 2,
                    activity: Math.floor(Math.random() * 4), // 0=standing, 1=bowing, 2=walking, 3=sweeping
                    speed: 0.3 + Math.random() * 0.5,
                    size: 0.8 + Math.random() * 0.4,
                    visible: false,
                    walkDir: Math.random() > 0.5 ? 1 : -1,
                    bowAngle: 0
                });
            }
        }

        // ── Init mountains ──
        function initMountains() {
            mountains = [];
            // 3 mountain layers: far, mid, near
            for (var layer = 0; layer < 3; layer++) {
                var peaks = [];
                var numPeaks = 5 + layer * 3;
                for (var i = 0; i <= numPeaks; i++) {
                    var x = (i / numPeaks) * W;
                    var baseH = H * (0.2 + layer * 0.12);
                    var peakH = baseH + seededRandom(i * 7 + layer * 31) * H * (0.15 - layer * 0.03);
                    peaks.push({ x: x, y: H - peakH });
                }
                mountains.push({ peaks: peaks, layer: layer });
            }
        }

        // ── Lerp ──
        function lerp(a, b, t) { return a + (b - a) * t; }
        function lerpSmooth(current, target, speed, dt) {
            return current + (target - current) * (1 - Math.exp(-speed * dt));
        }

        // ── Draw sky gradient ──
        function drawSky(ctx) {
            var dawn = dawnProgress;

            // Night to dawn gradient
            var topCol = lerpColor(COL.nightSky, COL.skyBlue, dawn * 0.8);
            var midCol = lerpColor(COL.dawnLow, COL.dawnPink, dawn);
            var botCol = lerpColor(COL.dawnMid, COL.dawnGold, dawn);

            var grad = ctx.createLinearGradient(0, 0, 0, H * 0.65);
            grad.addColorStop(0, topCol);
            grad.addColorStop(0.4, midCol);
            grad.addColorStop(0.7, botCol);
            grad.addColorStop(1, lerpColor(COL.dawnWarm, COL.dawnGold, dawn * 0.5));
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, W, H);

            // Sun glow
            if (dawn > 0.2) {
                var sunAlpha = (dawn - 0.2) * 1.25;
                var sunY = H * lerp(0.55, 0.32, Math.min(1, dawn * 1.2));
                var sunX = W * 0.5;
                var sunR = W * 0.15 * sunAlpha;

                var sunGrad = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunR);
                sunGrad.addColorStop(0, 'rgba(255,220,150,' + (sunAlpha * 0.6) + ')');
                sunGrad.addColorStop(0.3, 'rgba(255,180,100,' + (sunAlpha * 0.3) + ')');
                sunGrad.addColorStop(1, 'rgba(255,150,80,0)');
                ctx.fillStyle = sunGrad;
                ctx.fillRect(0, 0, W, H);

                // Sun disc
                if (dawn > 0.5) {
                    var discAlpha = (dawn - 0.5) * 2;
                    ctx.beginPath();
                    ctx.arc(sunX, sunY, W * 0.02 * discAlpha, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255,235,200,' + (discAlpha * 0.8) + ')';
                    ctx.fill();
                }
            }
        }

        // ── Color lerp ──
        function lerpColor(hex1, hex2, t) {
            t = Math.max(0, Math.min(1, t));
            var r1 = parseInt(hex1.slice(1,3),16), g1 = parseInt(hex1.slice(3,5),16), b1 = parseInt(hex1.slice(5,7),16);
            var r2 = parseInt(hex2.slice(1,3),16), g2 = parseInt(hex2.slice(3,5),16), b2 = parseInt(hex2.slice(5,7),16);
            var r = Math.round(lerp(r1,r2,t));
            var g = Math.round(lerp(g1,g2,t));
            var b = Math.round(lerp(b1,b2,t));
            return 'rgb(' + r + ',' + g + ',' + b + ')';
        }

        // ── Draw mountain range ──
        function drawMountains(ctx) {
            for (var mi = 0; mi < mountains.length; mi++) {
                var m = mountains[mi];
                var peaks = m.peaks;
                var depth = 1 - m.layer / 3;
                var col;
                if (dawnProgress < 0.3) {
                    col = lerpColor(COL.mountain, COL.mountainFar, m.layer / 3);
                } else {
                    var dawnFactor = (dawnProgress - 0.3) / 0.7;
                    col = lerpColor(
                        lerpColor(COL.mountain, COL.mountainFar, m.layer / 3),
                        lerpColor(COL.mountainMid, COL.valleyGreen, m.layer / 3),
                        dawnFactor * 0.5
                    );
                }

                ctx.fillStyle = col;
                ctx.beginPath();
                ctx.moveTo(0, H);

                for (var pi = 0; pi < peaks.length; pi++) {
                    if (pi === 0) {
                        ctx.lineTo(peaks[pi].x, peaks[pi].y);
                    } else {
                        var cpx = (peaks[pi-1].x + peaks[pi].x) / 2;
                        ctx.quadraticCurveTo(cpx, peaks[pi-1].y, peaks[pi].x, peaks[pi].y);
                    }
                }
                ctx.lineTo(W, H);
                ctx.closePath();
                ctx.fill();

                // Snow caps on far mountains
                if (m.layer === 0 && dawnProgress > 0.3) {
                    var snowAlpha = Math.min(1, (dawnProgress - 0.3) * 2);
                    ctx.save();
                    ctx.globalAlpha = snowAlpha * 0.5;
                    ctx.fillStyle = COL.snow;
                    for (var si = 0; si < peaks.length; si++) {
                        var pk = peaks[si];
                        if (pk.y < H * 0.35) {
                            ctx.beginPath();
                            ctx.moveTo(pk.x - 15, pk.y + 10);
                            ctx.lineTo(pk.x, pk.y);
                            ctx.lineTo(pk.x + 15, pk.y + 10);
                            ctx.closePath();
                            ctx.fill();
                        }
                    }
                    ctx.restore();
                }
            }
        }

        // ── Draw monastery silhouette ──
        function drawMonastery(ctx, energy) {
            var baseY = H * 0.58;
            var cx = W * 0.5;
            var monW = W * 0.22;
            var monH = H * 0.18;

            var dFactor = Math.min(1, dawnProgress * 2);
            var silCol = lerpColor('#0a0a14', COL.temple, dFactor * 0.6);

            ctx.save();

            // Main building body
            ctx.fillStyle = silCol;
            ctx.fillRect(cx - monW * 0.4, baseY - monH * 0.5, monW * 0.8, monH * 0.5);

            // Pagoda roof layers
            for (var r = 0; r < 3; r++) {
                var roofY = baseY - monH * 0.5 - r * monH * 0.18;
                var roofW = monW * (0.5 - r * 0.1);
                var roofH = monH * 0.12;

                // Roof body
                ctx.fillStyle = lerpColor('#0e0e18', COL.templeRoof, dFactor * 0.5);
                ctx.beginPath();
                ctx.moveTo(cx - roofW, roofY);
                ctx.lineTo(cx + roofW, roofY);
                ctx.lineTo(cx + roofW * 0.7, roofY - roofH);
                ctx.lineTo(cx - roofW * 0.7, roofY - roofH);
                ctx.closePath();
                ctx.fill();

                // Curved eaves
                ctx.strokeStyle = lerpColor('#14141e', COL.templeRoof, dFactor * 0.7);
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(cx - roofW * 1.1, roofY + 2);
                ctx.quadraticCurveTo(cx - roofW * 0.5, roofY - 3, cx, roofY);
                ctx.quadraticCurveTo(cx + roofW * 0.5, roofY - 3, cx + roofW * 1.1, roofY + 2);
                ctx.stroke();
            }

            // Spire
            var spireY = baseY - monH * 0.5 - 3 * monH * 0.18;
            ctx.strokeStyle = lerpColor('#0e0e18', COL.bell, dFactor * 0.4);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cx, spireY);
            ctx.lineTo(cx, spireY - monH * 0.15);
            ctx.stroke();

            // Bell on beat pulse
            if (bellPulse > 0.1) {
                var bellR = 6 + bellPulse * 4;
                ctx.beginPath();
                ctx.arc(cx, spireY - monH * 0.15, bellR, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(201,168,76,' + (bellPulse * 0.6) + ')';
                ctx.fill();

                // Bell ring ripples
                for (var br = 0; br < 3; br++) {
                    var ripR = bellR + br * 15 * (1 - bellPulse);
                    ctx.beginPath();
                    ctx.arc(cx, spireY - monH * 0.15, ripR, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(201,168,76,' + (bellPulse * 0.3 * (1 - br / 3)) + ')';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }

            // Side buildings
            for (var side = -1; side <= 1; side += 2) {
                var sx = cx + side * monW * 0.55;
                var sideH = monH * 0.35;
                ctx.fillStyle = silCol;
                ctx.fillRect(sx - monW * 0.15, baseY - sideH, monW * 0.3, sideH);

                // Side roof
                ctx.fillStyle = lerpColor('#0e0e18', COL.templeRoof, dFactor * 0.4);
                ctx.beginPath();
                ctx.moveTo(sx - monW * 0.2, baseY - sideH);
                ctx.lineTo(sx + monW * 0.2, baseY - sideH);
                ctx.lineTo(sx + monW * 0.15, baseY - sideH - monH * 0.08);
                ctx.lineTo(sx - monW * 0.15, baseY - sideH - monH * 0.08);
                ctx.closePath();
                ctx.fill();
            }

            // Windows (lit if dawn has started)
            if (dawnProgress > 0.1) {
                var winAlpha = Math.min(1, (dawnProgress - 0.1) * 3) * (0.3 + energy * 0.3);
                ctx.fillStyle = 'rgba(255,200,100,' + winAlpha + ')';
                for (var wi = -2; wi <= 2; wi++) {
                    ctx.fillRect(cx + wi * monW * 0.12 - 3, baseY - monH * 0.35, 6, 8);
                }
            }

            ctx.restore();
        }

        // ── Draw bamboo forest ──
        function drawBamboo(ctx, time, energy) {
            ctx.save();
            var windStr = energy * 0.03 + 0.01;

            for (var i = 0; i < bambooStalks.length; i++) {
                var b = bambooStalks[i];
                var sway = Math.sin(time * b.sway * 0.3 + b.sway) * windStr * b.height;
                var alpha = fogDensity > 0.7 ? 0.3 : (0.5 + (1 - fogDensity) * 0.5);

                ctx.globalAlpha = alpha * Math.min(1, dawnProgress * 3 + 0.2);

                // Stalk
                var baseY = H * 0.85;
                ctx.strokeStyle = lerpColor(COL.bamboo, COL.bambooBright, dawnProgress * 0.6);
                ctx.lineWidth = b.thickness;
                ctx.beginPath();
                ctx.moveTo(b.x, baseY);

                var tipX = b.x + sway;
                var tipY = baseY - b.height;
                ctx.quadraticCurveTo(b.x + sway * 0.3, baseY - b.height * 0.5, tipX, tipY);
                ctx.stroke();

                // Segment nodes
                for (var s = 1; s < b.segments; s++) {
                    var nodeT = s / b.segments;
                    var nodeX = b.x + sway * nodeT * nodeT;
                    var nodeY = baseY - b.height * nodeT;
                    ctx.strokeStyle = lerpColor(COL.bamboo, COL.bambooBright, dawnProgress * 0.4);
                    ctx.lineWidth = b.thickness + 1;
                    ctx.beginPath();
                    ctx.moveTo(nodeX - 3, nodeY);
                    ctx.lineTo(nodeX + 3, nodeY);
                    ctx.stroke();
                }

                // Leaves
                ctx.fillStyle = lerpColor(COL.bamboo, COL.bambooBright, dawnProgress * 0.5);
                for (var li = 0; li < b.leaves; li++) {
                    var lt = 0.4 + (li / b.leaves) * 0.6;
                    var lx = b.x + sway * lt * lt;
                    var ly = baseY - b.height * lt;
                    var leafAngle = Math.sin(time + b.sway + li) * 0.3 + (li % 2 === 0 ? -0.8 : 0.8);
                    var leafLen = 8 + Math.random() * 6;

                    ctx.beginPath();
                    ctx.ellipse(
                        lx + Math.cos(leafAngle) * leafLen * 0.5,
                        ly + Math.sin(leafAngle) * leafLen * 0.5,
                        leafLen, 2, leafAngle, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
            }
            ctx.restore();
        }

        // ── Draw monks ──
        function drawMonks(ctx, time, energy) {
            ctx.save();
            for (var i = 0; i < monks.length; i++) {
                var m = monks[i];
                if (!m.visible) continue;

                var figSize = H * 0.06 * m.size;
                var x = m.x;
                var y = m.baseY;

                // Walking motion
                if (m.activity === 2) {
                    x += Math.sin(time * m.speed + m.phase) * 30 * m.walkDir;
                }

                // Bowing
                var bowAngle = 0;
                if (m.activity === 1) {
                    bowAngle = Math.sin(time * 0.5 + m.phase) * 0.3;
                    if (bowAngle < 0) bowAngle = 0;
                }

                ctx.save();
                ctx.translate(x, y);
                if (bowAngle > 0) ctx.rotate(bowAngle);

                // Robe body
                var robeGrad = ctx.createLinearGradient(0, -figSize, 0, 0);
                robeGrad.addColorStop(0, COL.monkRobe);
                robeGrad.addColorStop(1, COL.monk);
                ctx.fillStyle = robeGrad;
                ctx.beginPath();
                ctx.moveTo(-figSize * 0.3, 0);
                ctx.lineTo(-figSize * 0.2, -figSize * 0.7);
                ctx.lineTo(figSize * 0.2, -figSize * 0.7);
                ctx.lineTo(figSize * 0.3, 0);
                ctx.closePath();
                ctx.fill();

                // Head
                ctx.beginPath();
                ctx.arc(0, -figSize * 0.82, figSize * 0.15, 0, Math.PI * 2);
                ctx.fillStyle = '#d4a574';
                ctx.fill();

                // Sweeping arm motion
                if (m.activity === 3) {
                    var sweepX = Math.sin(time * 1.5 + m.phase) * figSize * 0.4;
                    ctx.strokeStyle = COL.templeWood;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(figSize * 0.15, -figSize * 0.5);
                    ctx.lineTo(sweepX + figSize * 0.4, -figSize * 0.1);
                    ctx.stroke();
                }

                // Walk step
                if (m.activity === 2) {
                    var step = Math.sin(time * 2 + m.phase) * figSize * 0.15;
                    ctx.strokeStyle = COL.monk;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(-figSize * 0.1, 0);
                    ctx.lineTo(-figSize * 0.1 + step, figSize * 0.1);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(figSize * 0.1, 0);
                    ctx.lineTo(figSize * 0.1 - step, figSize * 0.1);
                    ctx.stroke();
                }

                ctx.restore();
            }
            ctx.restore();
        }

        // ── Draw fog ──
        function drawFog(ctx, time) {
            if (fogDensity < 0.02) return;

            ctx.save();
            for (var i = 0; i < fogParticles.length; i++) {
                var p = fogParticles[i];
                var layerMult = (p.layer === 0) ? 0.5 : (p.layer === 1 ? 1.0 : 1.5);
                var alpha = p.alpha * fogDensity * layerMult;
                if (alpha < 0.005) continue;

                var px = p.x + time * p.speed * 0.3;
                // Wrap
                if (px > W + p.w) px -= W + p.w * 2;
                if (px < -p.w) px += W + p.w * 2;

                var fogCol = dawnProgress > 0.3
                    ? 'rgba(196,205,214,' + alpha + ')'
                    : 'rgba(138,154,170,' + alpha + ')';

                ctx.fillStyle = fogCol;
                ctx.beginPath();
                ctx.ellipse(px, p.y, p.w, p.h, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        // ── Draw ground ──
        function drawGround(ctx) {
            var groundY = H * 0.78;
            var grad = ctx.createLinearGradient(0, groundY, 0, H);
            var grassCol = lerpColor('#1a2a1a', COL.grass, dawnProgress * 0.7);
            grad.addColorStop(0, grassCol);
            grad.addColorStop(1, lerpColor('#0a1a0a', '#1a3a1a', dawnProgress));
            ctx.fillStyle = grad;
            ctx.fillRect(0, groundY, W, H - groundY);

            // Stone path
            ctx.fillStyle = lerpColor('#1a1a20', '#4a4a50', dawnProgress * 0.5);
            var pathW = W * 0.06;
            ctx.beginPath();
            ctx.moveTo(W * 0.47, groundY);
            ctx.lineTo(W * 0.53, groundY);
            ctx.lineTo(W * 0.54, H);
            ctx.lineTo(W * 0.46, H);
            ctx.closePath();
            ctx.fill();
        }

        // ── Draw valley panorama ──
        function drawValleyPanorama(ctx, energy) {
            if (valleyReveal < 0.01) return;

            ctx.save();
            ctx.globalAlpha = valleyReveal;

            // Expansive valley floor
            var valleyY = H * 0.55;
            var grad = ctx.createLinearGradient(0, valleyY, 0, H * 0.8);
            grad.addColorStop(0, lerpColor(COL.valleyGreen, '#6aaa5a', dawnProgress));
            grad.addColorStop(0.5, lerpColor(COL.grass, '#5a9a4a', dawnProgress));
            grad.addColorStop(1, lerpColor('#2a3a2a', '#4a7a3a', dawnProgress));

            // Overlay the valley scene
            ctx.fillStyle = grad;
            ctx.fillRect(0, valleyY, W, H * 0.3);

            // River
            ctx.strokeStyle = 'rgba(100,160,220,' + (0.3 + energy * 0.2) + ')';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(W * 0.1, valleyY + H * 0.15);
            for (var rx = 0; rx < W; rx += 20) {
                var ry = valleyY + H * 0.15 + Math.sin(rx * 0.01 + energy * 2) * 10;
                ctx.lineTo(rx, ry);
            }
            ctx.stroke();

            // Distant trees
            ctx.fillStyle = lerpColor('#2a5a2a', '#4a8a3a', dawnProgress * 0.7);
            for (var ti = 0; ti < 30; ti++) {
                var tx = seededRandom(ti * 3.7) * W;
                var ty = valleyY + seededRandom(ti * 7.3) * H * 0.2;
                var treeH = 10 + seededRandom(ti * 11.1) * 20;
                ctx.beginPath();
                ctx.moveTo(tx, ty);
                ctx.lineTo(tx - treeH * 0.3, ty + treeH);
                ctx.lineTo(tx + treeH * 0.3, ty + treeH);
                ctx.closePath();
                ctx.fill();
            }

            // Light rays
            if (dawnProgress > 0.5) {
                var rayAlpha = (dawnProgress - 0.5) * 2 * valleyReveal * 0.15;
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                for (var ri = 0; ri < 5; ri++) {
                    var rayX = W * 0.3 + ri * W * 0.1;
                    var rayGrad = ctx.createLinearGradient(rayX, 0, rayX + W * 0.05, H * 0.7);
                    rayGrad.addColorStop(0, 'rgba(255,220,150,' + rayAlpha + ')');
                    rayGrad.addColorStop(1, 'rgba(255,220,150,0)');
                    ctx.fillStyle = rayGrad;
                    ctx.beginPath();
                    ctx.moveTo(rayX - 5, 0);
                    ctx.lineTo(rayX + 5, 0);
                    ctx.lineTo(rayX + W * 0.08, H * 0.7);
                    ctx.lineTo(rayX - W * 0.03, H * 0.7);
                    ctx.closePath();
                    ctx.fill();
                }
                ctx.restore();
            }

            ctx.restore();
        }

        // ── Draw title ──
        function drawTitle(ctx) {
            if (titleAlpha < 0.01) return;

            ctx.save();
            ctx.globalAlpha = titleAlpha;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            var fontSize = Math.max(16, Math.min(W * 0.035, 40));
            ctx.font = '700 ' + fontSize + 'px "Noto Serif JP", serif';

            var y = H * 0.15;
            ctx.shadowColor = 'rgba(201,168,76,0.5)';
            ctx.shadowBlur = 30;
            ctx.fillStyle = COL.dawnGold;
            ctx.fillText('Monastery of the Morning Mist', W / 2, y);

            // Subtle underline
            ctx.strokeStyle = 'rgba(201,168,76,' + (titleAlpha * 0.3) + ')';
            ctx.lineWidth = 1;
            var titleW = ctx.measureText('Monastery of the Morning Mist').width;
            ctx.beginPath();
            ctx.moveTo(W / 2 - titleW * 0.5, y + fontSize * 0.7);
            ctx.lineTo(W / 2 + titleW * 0.5, y + fontSize * 0.7);
            ctx.stroke();

            ctx.restore();
        }

        // ── Draw beat-synced particles ──
        function drawBeatParticles(ctx, energy) {
            if (beatPulse < 0.05) return;

            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            var numParts = Math.floor(energy * 15);
            for (var i = 0; i < numParts; i++) {
                var angle = (i / numParts) * Math.PI * 2;
                var dist = 20 + beatPulse * 50 * (1 + energy);
                var px = W * 0.5 + Math.cos(angle + beatPulse) * dist;
                var py = H * 0.4 + Math.sin(angle + beatPulse) * dist * 0.5;
                var pAlpha = beatPulse * 0.4 * energy;

                ctx.beginPath();
                ctx.arc(px, py, 1 + energy * 2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(201,168,76,' + pAlpha + ')';
                ctx.fill();
            }
            ctx.restore();
        }

        // ── Flash/fade overlay ──
        function drawOverlay(ctx) {
            // Outro fade to white
            if (outroFade > 0.01) {
                ctx.save();
                ctx.globalAlpha = outroFade;
                ctx.fillStyle = '#f0ebe0';
                ctx.fillRect(0, 0, W, H);
                ctx.restore();
            }
        }

        // ── Init ──
        function init(ctx, width, height, anal) {
            W = width; H = height;
            analysis = anal;
            lastBeat = -1;
            beatPulse = 0;
            bellPulse = 0;
            sectionMood = 'mist';
            lastSeqIndex = -1;
            fogDensity = 1.0; fogTarget = 1.0;
            dawnProgress = 0; dawnTarget = 0;
            valleyReveal = 0; valleyTarget = 0;
            titleAlpha = 0; titleTarget = 0;
            outroFade = 0;

            initFog();
            initBamboo();
            initMonks();
            initMountains();
        }

        // ── Resize ──
        function resize(width, height) {
            W = width; H = height;
            initBamboo();
            initMountains();
            initFog();
            initMonks();
        }

        // ── Render ──
        function render(frameData) {
            var ctx = frameData.ctx;
            var dt = frameData.dt || 1/60;
            var cursor = frameData.cursor;
            var time = 0;

            // ── Idle state ──
            if (!cursor) {
                drawSky(ctx);
                drawMountains(ctx);
                drawGround(ctx);
                drawMonastery(ctx, 0);
                drawFog(ctx, 0);
                return;
            }

            time = cursor.elapsed || 0;
            var beat = cursor.beat;
            var seqIdx = cursor.seqIndex;
            var energy = analysis ? (analysis.energy[cursor.timelineIndex] || 0) : 0;

            // ── Section transitions ──
            var newSection = mapSection(seqIdx);
            if (seqIdx !== lastSeqIndex) {
                sectionMood = newSection;
                lastSeqIndex = seqIdx;
            }

            // ── Section-driven targets ──
            switch (sectionMood) {
                case 'mist':
                    fogTarget = 1.0;
                    dawnTarget = 0;
                    valleyTarget = 0;
                    titleTarget = 1;
                    // Only first monk visible, standing
                    for (var mi = 0; mi < monks.length; mi++) monks[mi].visible = false;
                    break;
                case 'temple':
                    fogTarget = 0.85;
                    dawnTarget = 0.1;
                    valleyTarget = 0;
                    titleTarget = 0.6;
                    monks[0].visible = true;
                    monks[0].activity = 0;
                    break;
                case 'chant':
                    fogTarget = 0.65;
                    dawnTarget = 0.25;
                    valleyTarget = 0;
                    titleTarget = 0;
                    for (var ci = 0; ci < 3; ci++) {
                        monks[ci].visible = true;
                        monks[ci].activity = ci === 0 ? 1 : (ci === 1 ? 3 : 2);
                    }
                    break;
                case 'chant2':
                    fogTarget = 0.45;
                    dawnTarget = 0.45;
                    valleyTarget = 0;
                    titleTarget = 0;
                    for (var c2 = 0; c2 < 5; c2++) {
                        monks[c2].visible = true;
                        monks[c2].activity = c2 % 4;
                    }
                    break;
                case 'wind':
                    fogTarget = 0.3;
                    dawnTarget = 0.6;
                    valleyTarget = 0;
                    titleTarget = 0;
                    for (var w1 = 0; w1 < monks.length; w1++) {
                        monks[w1].visible = true;
                        monks[w1].activity = w1 % 4;
                    }
                    break;
                case 'wind2':
                    fogTarget = 0.15;
                    dawnTarget = 0.8;
                    valleyTarget = 0.1;
                    titleTarget = 0;
                    for (var w2 = 0; w2 < monks.length; w2++) monks[w2].visible = true;
                    break;
                case 'clearing':
                    fogTarget = 0.08;
                    dawnTarget = 0.9;
                    valleyTarget = 0.5;
                    titleTarget = 0;
                    for (var cl = 0; cl < monks.length; cl++) {
                        monks[cl].visible = true;
                        monks[cl].activity = 0; // all standing, watching
                    }
                    break;
                case 'clearing2':
                    fogTarget = 0.03;
                    dawnTarget = 1.0;
                    valleyTarget = 0.9;
                    titleTarget = 0;
                    for (var c3 = 0; c3 < monks.length; c3++) monks[c3].visible = true;
                    break;
                case 'panorama':
                    fogTarget = 0.0;
                    dawnTarget = 1.0;
                    valleyTarget = 1.0;
                    titleTarget = 1;
                    for (var pn = 0; pn < monks.length; pn++) monks[pn].visible = true;
                    break;
                case 'fading':
                    fogTarget = 0.15;
                    dawnTarget = 0.85;
                    valleyTarget = 0.7;
                    titleTarget = 0.5;
                    for (var fd = 0; fd < monks.length; fd++) monks[fd].visible = fd < 3;
                    break;
                case 'stillness':
                    fogTarget = 0.5;
                    dawnTarget = 0.6;
                    valleyTarget = 0.3;
                    titleTarget = 0;
                    for (var st = 0; st < monks.length; st++) monks[st].visible = false;
                    outroFade = Math.min(1, outroFade + dt * 0.08);
                    break;
            }

            // ── Smooth transitions ──
            fogDensity = lerpSmooth(fogDensity, fogTarget, 1.5, dt);
            dawnProgress = lerpSmooth(dawnProgress, dawnTarget, 1.2, dt);
            valleyReveal = lerpSmooth(valleyReveal, valleyTarget, 1.0, dt);
            titleAlpha = lerpSmooth(titleAlpha, titleTarget, 2.5, dt);

            // ── Beat pulse ──
            if (beat !== lastBeat) {
                beatPulse = 1;

                // Bell pulse on temple bell notes (check ch1 for bell instrument)
                var notes = frameData.currentNotes;
                if (notes && notes[1] && notes[1].instrument === 1) {
                    bellPulse = 1;
                }
                // Also pulse on taiko
                if (notes && notes[3] && (notes[3].instrument === 5 || notes[3].instrument === 3)) {
                    beatPulse = Math.min(1.5, beatPulse + 0.5);
                }
            }
            lastBeat = beat;

            beatPulse *= Math.exp(-5 * dt);
            bellPulse *= Math.exp(-3 * dt);

            // ── Draw scene (back to front) ──

            // 1. Sky
            drawSky(ctx);

            // 2. Far mountains
            drawMountains(ctx);

            // 3. Valley panorama (between mountains and monastery)
            drawValleyPanorama(ctx, energy);

            // 4. Back fog layer
            ctx.save();
            ctx.globalAlpha = 0.6;
            drawFog(ctx, time * 0.5);
            ctx.restore();

            // 5. Ground
            drawGround(ctx);

            // 6. Monastery
            drawMonastery(ctx, energy);

            // 7. Bamboo forest
            drawBamboo(ctx, time, energy);

            // 8. Monks
            drawMonks(ctx, time, energy);

            // 9. Front fog layer
            ctx.save();
            ctx.globalAlpha = 0.4;
            drawFog(ctx, time);
            ctx.restore();

            // 10. Beat particles (temple bell & taiko accents)
            drawBeatParticles(ctx, energy);

            // 11. Title
            drawTitle(ctx);

            // 12. Overlay (outro fade)
            drawOverlay(ctx);
        }

        return {
            name: 'Monastery of the Morning Mist',
            init: init,
            render: render,
            resize: resize
        };
    })();

    // ── Page bootstrap ──
    (function() {
        var canvas = document.getElementById('viz-canvas');
        var overlay = document.getElementById('play-overlay');

        Visualizer.init(canvas);
        Visualizer.setRenderer('monastery-morning-mist-video');

        function loadAndPlay(json) {
            Visualizer.loadSong(json);
            Visualizer.play();
        }

        function fetchSong() {
            var url = '../audio-tracker/songs/monastery-of-the-morning-mist.json';
            if (window.fetch && location.protocol !== 'file:') {
                return fetch(url).then(function(r) { return r.json(); });
            }
            return new Promise(function(resolve, reject) {
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.onload = function() {
                    if (xhr.status === 200 || xhr.status === 0) {
                        resolve(JSON.parse(xhr.responseText));
                    } else {
                        reject(new Error('XHR failed: ' + xhr.status));
                    }
                };
                xhr.onerror = function() { reject(new Error('XHR error')); };
                xhr.send();
            });
        }

        overlay.addEventListener('click', function() {
            overlay.classList.add('hidden');
            fetchSong().then(loadAndPlay).catch(function(err) {
                console.error('Failed to load song:', err);
                overlay.classList.remove('hidden');
            });
        });

        canvas.addEventListener('click', function() {
            if (overlay.classList.contains('hidden')) {
                if (Visualizer.isPlaying()) {
                    Visualizer.stop();
                } else {
                    Visualizer.play();
                }
            }
        });
    })();
    </script>
</body>
</html>
