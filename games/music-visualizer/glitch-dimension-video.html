<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Glitch Dimension — Music Video</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background: #000;
            color: #fff;
            font-family: 'Share Tech Mono', monospace;
        }
        #viz-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: block;
            cursor: pointer;
        }
        .play-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            background: rgba(0,0,0,0.94);
            cursor: pointer;
            transition: opacity 0.5s;
        }
        .play-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .play-title {
            font-size: clamp(20px, 5vw, 48px);
            font-weight: 700;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: #ff00ff;
            text-shadow: 0 0 30px rgba(255,0,255,0.6), 3px 0 0 #00ffff, -3px 0 0 #ff0044;
            margin-bottom: 12px;
        }
        .play-sub {
            font-size: clamp(12px, 2vw, 18px);
            color: rgba(255,255,255,0.4);
            margin-bottom: 40px;
            letter-spacing: 0.15em;
        }
        .play-btn {
            width: 80px; height: 80px;
            border: 3px solid #00ffff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: pulse 2s ease-in-out infinite;
        }
        .play-btn::after {
            content: '';
            display: block;
            width: 0; height: 0;
            border-style: solid;
            border-width: 18px 0 18px 30px;
            border-color: transparent transparent transparent #00ffff;
            margin-left: 6px;
        }
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(0,255,255,0.4); }
            50% { box-shadow: 0 0 0 20px rgba(0,255,255,0); }
        }
        .back-link {
            position: fixed;
            top: 12px; left: 12px;
            z-index: 30;
            color: rgba(255,255,255,0.4);
            text-decoration: none;
            font-size: 13px;
            padding: 6px 10px;
            border-radius: 6px;
            background: rgba(0,0,0,0.4);
            transition: color 0.2s;
        }
        .back-link:hover { color: rgba(255,255,255,0.8); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&larr; Visualizer</a>
    <canvas id="viz-canvas"></canvas>
    <div class="play-overlay" id="play-overlay">
        <div class="play-title">Glitch Dimension</div>
        <div class="play-sub">reality.exe has stopped responding</div>
        <div class="play-btn"></div>
    </div>

    <script src="../audio-tracker/playback-engine.js"></script>
    <script src="engine.js"></script>
    <script>
    // ── Glitch Dimension Video Renderer ─────────────────────────────
    window.Renderers['glitch-dimension-video'] = (function() {
        "use strict";

        var W = 0, H = 0;
        var analysis = null;

        // ── Palette ──
        var MAGENTA  = [255, 0, 255];
        var CYAN     = [0, 255, 255];
        var ACID     = [0, 255, 68];
        var RED      = [255, 0, 68];
        var WHITE    = [255, 255, 255];

        // ── State ──
        var lastBeat = -1;
        var beatPulse = 0;
        var flashAlpha = 0;
        var sectionMood = 'void';
        var lastSeqIndex = -1;
        var sectionProgress = 0;
        var globalTime = 0;

        // Glitch bars
        var glitchBars = [];
        var pixelBlocks = [];
        var tearLines = [];
        var dimensionWindows = [];
        var fragments = [];
        var rgbSplitAmount = 0;
        var rgbSplitTarget = 0;
        var corruptionLevel = 0;
        var corruptionTarget = 0;
        var scanlineOffset = 0;

        // Title
        var titleAlpha = 0;
        var titleTarget = 0;
        var titleGlitch = 0;

        // Geometry fragments
        var shapes = [];

        // Dimension scenes (offscreen patterns)
        var dimensionPhase = 0;

        // ── Helpers ──
        function rgba(col, a) {
            return 'rgba(' + col[0] + ',' + col[1] + ',' + col[2] + ',' + a + ')';
        }

        function lerp(a, b, t) { return a + (b - a) * t; }

        function lerpExp(current, target, speed, dt) {
            return current + (target - current) * (1 - Math.exp(-speed * dt));
        }

        function rand(min, max) { return min + Math.random() * (max - min); }

        function randInt(min, max) { return Math.floor(rand(min, max + 1)); }

        function hexFromRgb(col) {
            return '#' + ((1 << 24) + (col[0] << 16) + (col[1] << 8) + col[2]).toString(16).slice(1);
        }

        // ── Section mapping ──
        // Sequence: 53 entries
        // 0-2: Void Fragments (sparse intro)
        // 3-5: Gathering Static (building)
        // 6-9: Tritone Groove A (first glitches)
        // 10-12: Tritone Groove B
        // 13: Tritone B -> Drop Fill (transition)
        // 14-17: THE DROP - Ambient Void (dimensional overlap)
        // 18-21: Cathedral Ghosts (ghostly calm)
        // 22-24: Tension Rebuild
        // 25-28: Tension Peak (full corruption)
        // 29-32: CLIMAX - Beautiful Accident (peak chaos)
        // 33-35: Climax Variation - Stretto
        // 36-37: Second Breakdown -> Fragments Stir (new reality seeds)
        // 38-39: Fragments Stir
        // 40-43: Final Surge - Stretto
        // 44-47: Final Surge Apex
        // 48-50: Dissolve
        // 51-52: Void Return
        function mapSection(seqIdx) {
            if (seqIdx <= 2) return 'void';          // normal reality
            if (seqIdx <= 5) return 'static';         // first glitches
            if (seqIdx <= 13) return 'corruption';     // full corruption
            if (seqIdx <= 17) return 'drop';           // dimensional overlap
            if (seqIdx <= 21) return 'cathedral';      // ghostly calm between dimensions
            if (seqIdx <= 24) return 'rebuild';        // tension building
            if (seqIdx <= 28) return 'peak';           // full corruption peak
            if (seqIdx <= 35) return 'climax';         // beautiful accident
            if (seqIdx <= 39) return 'newreality';     // fragments reassembling
            if (seqIdx <= 47) return 'finalsurge';     // ultimate chaos
            return 'dissolve';                         // resolution/new reality
        }

        // ── Glitch bar generation ──
        function spawnGlitchBars(count, intensity) {
            for (var i = 0; i < count; i++) {
                glitchBars.push({
                    y: Math.random() * H,
                    h: rand(1, 6 + intensity * 20),
                    dx: rand(-30, 30) * intensity,
                    life: rand(0.05, 0.2),
                    color: [MAGENTA, CYAN, ACID, RED][randInt(0, 3)]
                });
            }
        }

        function spawnPixelBlocks(count, intensity) {
            for (var i = 0; i < count; i++) {
                var size = rand(10, 40 + intensity * 60);
                pixelBlocks.push({
                    x: Math.random() * W,
                    y: Math.random() * H,
                    w: size,
                    h: size * rand(0.3, 1.5),
                    dx: rand(-200, 200) * intensity,
                    dy: rand(-100, 100) * intensity,
                    life: rand(0.1, 0.4),
                    color: [MAGENTA, CYAN, ACID, RED, WHITE][randInt(0, 4)],
                    alpha: rand(0.3, 0.9)
                });
            }
        }

        function spawnTearLines(count) {
            for (var i = 0; i < count; i++) {
                tearLines.push({
                    y: Math.random() * H,
                    dx: rand(-40, 40),
                    h: rand(1, 4),
                    life: rand(0.05, 0.15)
                });
            }
        }

        function spawnShapes(count, intensity) {
            for (var i = 0; i < count; i++) {
                var type = randInt(0, 3); // 0=triangle, 1=rect, 2=circle, 3=line
                shapes.push({
                    x: Math.random() * W,
                    y: Math.random() * H,
                    size: rand(20, 80 + intensity * 60),
                    type: type,
                    rotation: Math.random() * Math.PI * 2,
                    rotSpeed: rand(-3, 3),
                    vx: rand(-100, 100),
                    vy: rand(-100, 100),
                    life: rand(0.3, 1.5),
                    maxLife: 0,
                    color: [MAGENTA, CYAN, ACID, RED][randInt(0, 3)],
                    alpha: rand(0.2, 0.8),
                    fragmenting: intensity > 0.6,
                    fragmentPhase: 0
                });
                shapes[shapes.length - 1].maxLife = shapes[shapes.length - 1].life;
            }
        }

        function spawnDimensionWindow(intensity) {
            dimensionWindows.push({
                x: rand(W * 0.1, W * 0.9),
                y: rand(H * 0.1, H * 0.9),
                w: rand(60, W * 0.4),
                h: rand(40, H * 0.3),
                life: rand(0.5, 2.0),
                maxLife: 0,
                sceneType: randInt(0, 4),
                phase: Math.random() * Math.PI * 2,
                glitchOffset: 0
            });
            dimensionWindows[dimensionWindows.length - 1].maxLife = dimensionWindows[dimensionWindows.length - 1].life;
        }

        // ── Draw routines ──

        function drawScanlines(ctx, intensity) {
            if (intensity < 0.01) return;
            ctx.save();
            ctx.globalAlpha = intensity * 0.15;
            for (var y = 0; y < H; y += 2) {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, y + scanlineOffset % 2, W, 1);
            }
            ctx.restore();
        }

        function drawRGBSplit(ctx, amount) {
            if (amount < 0.5) return;
            // Draw shifted copies of the canvas
            var dx = amount;
            var dy = amount * 0.3;
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = 0.15;
            // Red channel shift
            ctx.drawImage(ctx.canvas, dx, dy);
            // Cyan shift
            ctx.drawImage(ctx.canvas, -dx, -dy);
            ctx.restore();
        }

        function drawGlitchBars(ctx) {
            ctx.save();
            for (var i = glitchBars.length - 1; i >= 0; i--) {
                var bar = glitchBars[i];
                ctx.fillStyle = rgba(bar.color, 0.3 + bar.life * 2);
                ctx.fillRect(bar.dx, bar.y, W, bar.h);
                // Also draw a shifted copy
                ctx.globalAlpha = 0.15;
                ctx.drawImage(ctx.canvas,
                    0, bar.y, W, bar.h,
                    bar.dx * 2, bar.y - 1, W, bar.h);
                ctx.globalAlpha = 1;
            }
            ctx.restore();
        }

        function drawPixelBlocks(ctx) {
            ctx.save();
            for (var i = 0; i < pixelBlocks.length; i++) {
                var b = pixelBlocks[i];
                ctx.globalAlpha = b.alpha * Math.min(1, b.life * 5);
                ctx.fillStyle = rgba(b.color, 1);
                ctx.fillRect(b.x, b.y, b.w, b.h);
                // Inner detail - pixel sorting look
                ctx.fillStyle = rgba(WHITE, 0.15);
                for (var s = 0; s < b.w; s += 4) {
                    var sh = b.h * Math.random();
                    ctx.fillRect(b.x + s, b.y + (b.h - sh) * 0.5, 2, sh);
                }
            }
            ctx.restore();
        }

        function drawTearLines(ctx) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            for (var i = 0; i < tearLines.length; i++) {
                var t = tearLines[i];
                ctx.fillStyle = rgba(WHITE, 0.6 * t.life * 10);
                ctx.fillRect(0, t.y, W, t.h);
                // Offset shift effect
                ctx.globalAlpha = 0.3;
                ctx.drawImage(ctx.canvas,
                    0, Math.max(0, t.y - 2), W, Math.min(t.h + 4, H - t.y),
                    t.dx, t.y - 2, W, t.h + 4);
                ctx.globalAlpha = 1;
            }
            ctx.restore();
        }

        function drawShapes(ctx) {
            ctx.save();
            for (var i = 0; i < shapes.length; i++) {
                var s = shapes[i];
                var lifeRatio = s.life / s.maxLife;
                var alpha = s.alpha * lifeRatio;
                if (alpha < 0.01) continue;

                ctx.save();
                ctx.translate(s.x, s.y);
                ctx.rotate(s.rotation);
                ctx.globalAlpha = alpha;
                ctx.strokeStyle = rgba(s.color, 1);
                ctx.lineWidth = 2;

                if (s.fragmenting) {
                    // Draw broken/offset versions
                    var fOff = s.fragmentPhase * s.size * 0.3;
                    ctx.save();
                    ctx.translate(fOff, -fOff * 0.5);
                    drawShapeType(ctx, s.type, s.size * 0.6);
                    ctx.restore();
                    ctx.save();
                    ctx.translate(-fOff * 0.7, fOff);
                    ctx.strokeStyle = rgba(CYAN, 0.5);
                    drawShapeType(ctx, s.type, s.size * 0.4);
                    ctx.restore();
                }

                drawShapeType(ctx, s.type, s.size);
                ctx.restore();
            }
            ctx.restore();
        }

        function drawShapeType(ctx, type, size) {
            ctx.beginPath();
            if (type === 0) { // triangle
                ctx.moveTo(0, -size * 0.5);
                ctx.lineTo(-size * 0.43, size * 0.25);
                ctx.lineTo(size * 0.43, size * 0.25);
                ctx.closePath();
            } else if (type === 1) { // rect
                ctx.rect(-size * 0.4, -size * 0.4, size * 0.8, size * 0.8);
            } else if (type === 2) { // circle
                ctx.arc(0, 0, size * 0.4, 0, Math.PI * 2);
            } else { // cross/line
                ctx.moveTo(-size * 0.4, 0);
                ctx.lineTo(size * 0.4, 0);
                ctx.moveTo(0, -size * 0.4);
                ctx.lineTo(0, size * 0.4);
            }
            ctx.stroke();
        }

        function drawDimensionWindows(ctx, energy) {
            ctx.save();
            for (var i = 0; i < dimensionWindows.length; i++) {
                var dw = dimensionWindows[i];
                var lifeRatio = dw.life / dw.maxLife;
                var alpha = Math.min(1, lifeRatio * 3) * Math.min(1, dw.life * 2);

                ctx.save();
                ctx.globalAlpha = alpha * 0.8;

                // Window border - glitchy
                ctx.strokeStyle = rgba(CYAN, 0.7);
                ctx.lineWidth = 2;
                var gx = dw.glitchOffset;
                ctx.strokeRect(dw.x + gx, dw.y, dw.w, dw.h);

                // Inner scene
                ctx.save();
                ctx.beginPath();
                ctx.rect(dw.x + gx, dw.y, dw.w, dw.h);
                ctx.clip();

                drawDimensionScene(ctx, dw, energy);

                ctx.restore();

                // Scanline overlay on window
                ctx.globalAlpha = alpha * 0.1;
                for (var sy = dw.y; sy < dw.y + dw.h; sy += 3) {
                    ctx.fillStyle = '#000';
                    ctx.fillRect(dw.x + gx, sy, dw.w, 1);
                }

                ctx.restore();
            }
            ctx.restore();
        }

        function drawDimensionScene(ctx, dw, energy) {
            var cx = dw.x + dw.w * 0.5 + dw.glitchOffset;
            var cy = dw.y + dw.h * 0.5;
            var t = dw.phase;

            if (dw.sceneType === 0) {
                // Rotating grid
                ctx.strokeStyle = rgba(MAGENTA, 0.4);
                ctx.lineWidth = 1;
                for (var g = -5; g <= 5; g++) {
                    var gx2 = cx + g * 20 * Math.cos(t);
                    ctx.beginPath();
                    ctx.moveTo(gx2, dw.y);
                    ctx.lineTo(gx2 + Math.sin(t) * 40, dw.y + dw.h);
                    ctx.stroke();
                }
            } else if (dw.sceneType === 1) {
                // Pulsing circles
                for (var c = 0; c < 5; c++) {
                    var r = (c + 1) * 15 + Math.sin(t + c) * 10;
                    ctx.strokeStyle = rgba(ACID, 0.3);
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(cx, cy, r, 0, Math.PI * 2);
                    ctx.stroke();
                }
            } else if (dw.sceneType === 2) {
                // Static noise
                ctx.fillStyle = rgba(WHITE, 0.05);
                for (var nx = 0; nx < 30; nx++) {
                    var noiseX = dw.x + Math.random() * dw.w;
                    var noiseY = dw.y + Math.random() * dw.h;
                    ctx.fillRect(noiseX, noiseY, rand(2, 8), rand(1, 3));
                }
            } else if (dw.sceneType === 3) {
                // Inverted color bars
                var barW = dw.w / 8;
                var colors = [MAGENTA, CYAN, ACID, RED, WHITE, MAGENTA, CYAN, ACID];
                for (var b = 0; b < 8; b++) {
                    ctx.fillStyle = rgba(colors[b], 0.2);
                    ctx.fillRect(dw.x + dw.glitchOffset + b * barW, dw.y, barW, dw.h);
                }
            } else {
                // Fractal-like recursive squares
                ctx.strokeStyle = rgba(RED, 0.3);
                ctx.lineWidth = 1;
                for (var sq = 0; sq < 6; sq++) {
                    var ss = dw.w * 0.4 * Math.pow(0.7, sq);
                    ctx.save();
                    ctx.translate(cx, cy);
                    ctx.rotate(t * 0.5 + sq * 0.3);
                    ctx.strokeRect(-ss * 0.5, -ss * 0.5, ss, ss);
                    ctx.restore();
                }
            }
        }

        function drawDataMosh(ctx, intensity) {
            if (intensity < 0.1) return;
            // Simulate data moshing by copying/shifting random horizontal strips
            var numStrips = Math.floor(intensity * 12);
            ctx.save();
            for (var i = 0; i < numStrips; i++) {
                var sy = Math.floor(Math.random() * H);
                var sh = Math.floor(rand(2, 20 + intensity * 30));
                var sdx = Math.floor(rand(-50, 50) * intensity);
                if (sy + sh > H) sh = H - sy;
                if (sh <= 0) continue;
                try {
                    ctx.drawImage(ctx.canvas, 0, sy, W, sh, sdx, sy, W, sh);
                } catch(e) { /* ignore */ }
            }
            ctx.restore();
        }

        function drawCorruptedGrid(ctx, energy, beat) {
            if (corruptionLevel < 0.05) return;
            ctx.save();
            ctx.globalAlpha = corruptionLevel * 0.3;
            ctx.strokeStyle = rgba(MAGENTA, 0.2);
            ctx.lineWidth = 1;

            var gridSize = 40;
            var offset = (beat * 3) % gridSize;

            for (var x = -gridSize + offset; x < W + gridSize; x += gridSize) {
                var wobble = Math.sin(x * 0.01 + globalTime * 2) * corruptionLevel * 20;
                ctx.beginPath();
                ctx.moveTo(x + wobble, 0);
                ctx.lineTo(x - wobble, H);
                ctx.stroke();
            }
            for (var y = -gridSize + offset; y < H + gridSize; y += gridSize) {
                var wobble2 = Math.cos(y * 0.01 + globalTime * 1.5) * corruptionLevel * 15;
                ctx.beginPath();
                ctx.moveTo(0, y + wobble2);
                ctx.lineTo(W, y - wobble2);
                ctx.stroke();
            }
            ctx.restore();
        }

        function drawVoidBackground(ctx, energy) {
            // Deep black with subtle moving noise
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, W, H);

            // Subtle gradient from center
            var grad = ctx.createRadialGradient(W * 0.5, H * 0.5, 0, W * 0.5, H * 0.5, W * 0.6);
            grad.addColorStop(0, 'rgba(20,0,30,' + (0.3 + energy * 0.2) + ')');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, W, H);
        }

        function drawTitle(ctx) {
            if (titleAlpha < 0.01) return;

            var text = 'GLITCH DIMENSION';
            var fontSize = Math.max(16, Math.min(W * 0.05, 60));
            ctx.save();
            ctx.font = '700 ' + fontSize + 'px "Share Tech Mono", monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            var tx = W * 0.5;
            var ty = H * 0.15;

            // Glitch offset for each character
            if (titleGlitch > 0.1) {
                // Draw RGB-split version
                var chars = text.split('');
                var totalW = ctx.measureText(text).width;
                var startX = tx - totalW * 0.5;

                for (var i = 0; i < chars.length; i++) {
                    var cw = ctx.measureText(chars[i]).width;
                    var cx = startX + cw * 0.5;
                    var gOff = (Math.random() - 0.5) * titleGlitch * 8;
                    var gOffY = (Math.random() - 0.5) * titleGlitch * 4;

                    // Red layer
                    ctx.globalAlpha = titleAlpha * 0.6;
                    ctx.fillStyle = rgba(RED, 1);
                    ctx.fillText(chars[i], cx - titleGlitch * 2 + gOff, ty + gOffY);

                    // Cyan layer
                    ctx.fillStyle = rgba(CYAN, 1);
                    ctx.fillText(chars[i], cx + titleGlitch * 2 + gOff, ty - gOffY);

                    // White main
                    ctx.globalAlpha = titleAlpha;
                    ctx.fillStyle = '#fff';
                    ctx.shadowColor = rgba(MAGENTA, 1);
                    ctx.shadowBlur = 20;
                    ctx.fillText(chars[i], cx + gOff, ty);

                    startX += cw;
                }
            } else {
                ctx.globalAlpha = titleAlpha;
                ctx.shadowColor = rgba(MAGENTA, 1);
                ctx.shadowBlur = 30;
                ctx.fillStyle = '#fff';
                ctx.fillText(text, tx, ty);
                // Glow layer
                ctx.globalAlpha = titleAlpha * 0.5;
                ctx.shadowBlur = 60;
                ctx.fillStyle = rgba(MAGENTA, 1);
                ctx.fillText(text, tx, ty);
            }

            ctx.restore();
        }

        function drawFlash(ctx) {
            if (flashAlpha < 0.01) return;
            ctx.save();
            ctx.globalAlpha = flashAlpha;
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, W, H);
            ctx.restore();
        }

        function drawStaticNoise(ctx, intensity) {
            if (intensity < 0.02) return;
            ctx.save();
            ctx.globalAlpha = intensity * 0.3;
            var blockSize = 4;
            var count = Math.floor(W * H * intensity * 0.001);
            for (var i = 0; i < count; i++) {
                var nx = Math.floor(Math.random() * W / blockSize) * blockSize;
                var ny = Math.floor(Math.random() * H / blockSize) * blockSize;
                var bright = Math.random();
                ctx.fillStyle = 'rgba(' + Math.floor(bright * 255) + ',' + Math.floor(bright * 255) + ',' + Math.floor(bright * 255) + ',1)';
                ctx.fillRect(nx, ny, blockSize, blockSize);
            }
            ctx.restore();
        }

        function drawCenterVortex(ctx, energy, beat) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            var cx = W * 0.5;
            var cy = H * 0.5;
            var numRings = 8;
            var maxR = Math.min(W, H) * 0.4;

            for (var i = 0; i < numRings; i++) {
                var t = (i / numRings + globalTime * 0.3) % 1;
                var r = t * maxR;
                var alpha = (1 - t) * energy * 0.15;
                var col = i % 2 === 0 ? MAGENTA : CYAN;

                ctx.strokeStyle = rgba(col, alpha);
                ctx.lineWidth = 1 + energy * 2;
                ctx.beginPath();

                // Distorted circle
                for (var a = 0; a <= Math.PI * 2; a += 0.1) {
                    var distort = Math.sin(a * 3 + globalTime * 5) * r * 0.1 * corruptionLevel;
                    var px = cx + Math.cos(a) * (r + distort);
                    var py = cy + Math.sin(a) * (r + distort);
                    if (a === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.stroke();
            }
            ctx.restore();
        }

        // ── Update routines ──

        function updateParticles(dt) {
            // Update glitch bars
            for (var i = glitchBars.length - 1; i >= 0; i--) {
                glitchBars[i].life -= dt;
                if (glitchBars[i].life <= 0) glitchBars.splice(i, 1);
            }
            // Update pixel blocks
            for (var j = pixelBlocks.length - 1; j >= 0; j--) {
                var pb = pixelBlocks[j];
                pb.life -= dt;
                pb.x += pb.dx * dt;
                pb.y += pb.dy * dt;
                if (pb.life <= 0) pixelBlocks.splice(j, 1);
            }
            // Update tear lines
            for (var k = tearLines.length - 1; k >= 0; k--) {
                tearLines[k].life -= dt;
                if (tearLines[k].life <= 0) tearLines.splice(k, 1);
            }
            // Update shapes
            for (var s = shapes.length - 1; s >= 0; s--) {
                var sh = shapes[s];
                sh.life -= dt;
                sh.x += sh.vx * dt;
                sh.y += sh.vy * dt;
                sh.rotation += sh.rotSpeed * dt;
                if (sh.fragmenting) sh.fragmentPhase += dt * 3;
                if (sh.life <= 0) shapes.splice(s, 1);
            }
            // Update dimension windows
            for (var d = dimensionWindows.length - 1; d >= 0; d--) {
                var dw = dimensionWindows[d];
                dw.life -= dt;
                dw.phase += dt * 2;
                dw.glitchOffset = Math.sin(dw.phase * 8) * corruptionLevel * 5;
                if (dw.life <= 0) dimensionWindows.splice(d, 1);
            }
        }

        // ── Init ──
        function init(ctx, width, height, anal) {
            W = width; H = height;
            analysis = anal;
            lastBeat = -1;
            beatPulse = 0;
            flashAlpha = 0;
            sectionMood = 'void';
            lastSeqIndex = -1;
            globalTime = 0;
            corruptionLevel = 0;
            corruptionTarget = 0;
            rgbSplitAmount = 0;
            rgbSplitTarget = 0;
            titleAlpha = 0;
            titleGlitch = 0;
            glitchBars = [];
            pixelBlocks = [];
            tearLines = [];
            dimensionWindows = [];
            shapes = [];
            scanlineOffset = 0;
        }

        // ── Resize ──
        function resize(width, height) {
            W = width; H = height;
        }

        // ── Main render ──
        function render(frameData) {
            var ctx = frameData.ctx;
            var dt = frameData.dt || 1/60;
            var cursor = frameData.cursor;

            globalTime += dt;
            scanlineOffset += dt * 30;

            // ── Background ──
            drawVoidBackground(ctx, 0);

            if (!cursor) {
                // Idle state - subtle static
                drawStaticNoise(ctx, 0.05);
                drawScanlines(ctx, 0.3);
                return;
            }

            var beat = cursor.beat;
            var seqIdx = cursor.seqIndex;
            var energy = analysis ? (analysis.energy[cursor.timelineIndex] || 0) : 0;

            // ── Section transitions ──
            var newSection = mapSection(seqIdx);
            if (seqIdx !== lastSeqIndex) {
                sectionMood = newSection;
                sectionProgress = 0;

                // Section-change flash
                if (lastSeqIndex >= 0) {
                    flashAlpha = 0.2 + energy * 0.2;
                    spawnGlitchBars(5 + Math.floor(energy * 10), energy);
                    spawnTearLines(3 + Math.floor(energy * 5));
                }

                lastSeqIndex = seqIdx;
            }
            sectionProgress += dt;

            // ── Set corruption/glitch targets by section ──
            switch (sectionMood) {
                case 'void':
                    corruptionTarget = 0.02;
                    rgbSplitTarget = 0;
                    titleTarget = 0;
                    break;
                case 'static':
                    corruptionTarget = 0.15 + energy * 0.2;
                    rgbSplitTarget = energy * 3;
                    titleTarget = 0.6;
                    break;
                case 'corruption':
                    corruptionTarget = 0.5 + energy * 0.4;
                    rgbSplitTarget = energy * 8;
                    titleTarget = 1;
                    break;
                case 'drop':
                    corruptionTarget = 0.1;
                    rgbSplitTarget = 1;
                    titleTarget = 0.3;
                    break;
                case 'cathedral':
                    corruptionTarget = 0.05;
                    rgbSplitTarget = 0.5;
                    titleTarget = 0;
                    break;
                case 'rebuild':
                    corruptionTarget = 0.3 + energy * 0.3;
                    rgbSplitTarget = energy * 5;
                    titleTarget = 0.5;
                    break;
                case 'peak':
                    corruptionTarget = 0.7 + energy * 0.3;
                    rgbSplitTarget = energy * 12;
                    titleTarget = 1;
                    break;
                case 'climax':
                    corruptionTarget = 0.9;
                    rgbSplitTarget = energy * 15;
                    titleTarget = 1;
                    break;
                case 'newreality':
                    corruptionTarget = 0.2 + energy * 0.3;
                    rgbSplitTarget = energy * 4;
                    titleTarget = 0.4;
                    break;
                case 'finalsurge':
                    corruptionTarget = 0.85 + energy * 0.15;
                    rgbSplitTarget = energy * 18;
                    titleTarget = 1;
                    break;
                case 'dissolve':
                    corruptionTarget = Math.max(0, 0.4 - sectionProgress * 0.1);
                    rgbSplitTarget = Math.max(0, 3 - sectionProgress);
                    titleTarget = Math.max(0, 1 - sectionProgress * 0.3);
                    break;
            }

            // Lerp state
            corruptionLevel = lerpExp(corruptionLevel, corruptionTarget, 4, dt);
            rgbSplitAmount = lerpExp(rgbSplitAmount, rgbSplitTarget, 6, dt);
            titleAlpha = lerpExp(titleAlpha, titleTarget, 3, dt);

            // ── Beat events ──
            if (beat !== lastBeat) {
                beatPulse = 1;

                // Beat-synced spawns
                var intensity = corruptionLevel;

                // Screen tears on every beat
                if (intensity > 0.1) {
                    spawnTearLines(Math.floor(intensity * 4));
                }

                // Glitch bars on strong beats
                if (energy > 0.3) {
                    spawnGlitchBars(Math.floor(energy * 6 * intensity), intensity);
                }

                // Pixel blocks when corrupted
                if (intensity > 0.3 && energy > 0.4) {
                    spawnPixelBlocks(Math.floor(intensity * 4), intensity);
                }

                // Geometric fragments
                if (intensity > 0.2) {
                    spawnShapes(Math.floor(intensity * 3), intensity);
                }

                // Dimension windows in overlay sections
                if ((sectionMood === 'drop' || sectionMood === 'climax' || sectionMood === 'finalsurge') && Math.random() < 0.3) {
                    spawnDimensionWindow(intensity);
                }

                // Flash on high energy beats
                if (energy > 0.6 && intensity > 0.4) {
                    flashAlpha = Math.max(flashAlpha, 0.1 + energy * 0.15);
                }

                // Title glitch spikes
                titleGlitch = intensity > 0.3 ? intensity * 3 : 0;

                lastBeat = beat;
            }

            beatPulse *= Math.exp(-8 * dt);
            flashAlpha *= Math.exp(-6 * dt);
            titleGlitch *= Math.exp(-10 * dt);

            // ── Update all particles ──
            updateParticles(dt);

            // ── Draw scene layers ──

            // 1. Background void with energy-reactive gradient
            drawVoidBackground(ctx, energy);

            // 2. Center vortex (visible in corruption+ sections)
            if (corruptionLevel > 0.1) {
                drawCenterVortex(ctx, energy, beat);
            }

            // 3. Corrupted grid
            drawCorruptedGrid(ctx, energy, beat);

            // 4. Dimension windows (behind main glitches)
            if (dimensionWindows.length > 0) {
                drawDimensionWindows(ctx, energy);
            }

            // 5. Geometric shapes
            if (shapes.length > 0) {
                drawShapes(ctx);
            }

            // 6. Title
            drawTitle(ctx);

            // 7. Data moshing effect
            drawDataMosh(ctx, corruptionLevel * energy);

            // 8. Pixel blocks
            if (pixelBlocks.length > 0) {
                drawPixelBlocks(ctx);
            }

            // 9. Glitch bars
            if (glitchBars.length > 0) {
                drawGlitchBars(ctx);
            }

            // 10. Tear lines
            if (tearLines.length > 0) {
                drawTearLines(ctx);
            }

            // 11. RGB channel separation
            drawRGBSplit(ctx, rgbSplitAmount);

            // 12. Static noise
            drawStaticNoise(ctx, corruptionLevel * 0.5 + beatPulse * 0.2);

            // 13. Scanlines
            drawScanlines(ctx, 0.3 + corruptionLevel * 0.5);

            // 14. Beat pulse vignette
            if (beatPulse > 0.01) {
                ctx.save();
                var vigGrad = ctx.createRadialGradient(W * 0.5, H * 0.5, W * 0.2, W * 0.5, H * 0.5, W * 0.7);
                vigGrad.addColorStop(0, 'rgba(0,0,0,0)');
                vigGrad.addColorStop(1, rgba(MAGENTA, beatPulse * 0.15));
                ctx.fillStyle = vigGrad;
                ctx.fillRect(0, 0, W, H);
                ctx.restore();
            }

            // 15. Flash
            drawFlash(ctx);
        }

        return {
            name: 'Glitch Dimension Video',
            init: init,
            render: render,
            resize: resize
        };
    })();

    // ── Page bootstrap ──
    (function() {
        var canvas = document.getElementById('viz-canvas');
        var overlay = document.getElementById('play-overlay');

        Visualizer.init(canvas);
        Visualizer.setRenderer('glitch-dimension-video');

        function loadAndPlay(json) {
            Visualizer.loadSong(json);
            Visualizer.play();
        }

        function fetchSong() {
            var url = '../audio-tracker/songs/glitch-dimension.json';
            if (window.fetch && location.protocol !== 'file:') {
                return fetch(url).then(function(r) { return r.json(); });
            }
            return new Promise(function(resolve, reject) {
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.onload = function() {
                    if (xhr.status === 200 || xhr.status === 0) {
                        resolve(JSON.parse(xhr.responseText));
                    } else {
                        reject(new Error('XHR failed: ' + xhr.status));
                    }
                };
                xhr.onerror = function() { reject(new Error('XHR error')); };
                xhr.send();
            });
        }

        overlay.addEventListener('click', function() {
            overlay.classList.add('hidden');
            fetchSong().then(loadAndPlay).catch(function(err) {
                console.error('Failed to load song:', err);
                overlay.classList.remove('hidden');
            });
        });

        canvas.addEventListener('click', function() {
            if (overlay.classList.contains('hidden')) {
                if (Visualizer.isPlaying()) {
                    Visualizer.stop();
                } else {
                    Visualizer.play();
                }
            }
        });
    })();
    </script>
</body>
</html>
