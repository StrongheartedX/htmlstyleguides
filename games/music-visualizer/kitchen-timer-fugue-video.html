<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kitchen Timer Fugue — Music Video</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&family=Source+Sans+3:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background: #1a0f08;
            color: #fff;
            font-family: 'Source Sans 3', sans-serif;
        }
        #viz-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: block;
            cursor: pointer;
        }
        .play-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            background: rgba(26,15,8,0.92);
            cursor: pointer;
            transition: opacity 0.5s;
        }
        .play-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .play-title {
            font-size: clamp(20px, 5vw, 48px);
            font-weight: 700;
            font-family: 'Playfair Display', serif;
            letter-spacing: 0.04em;
            color: #e87b35;
            text-shadow: 0 0 30px rgba(232,123,53,0.6), 0 0 60px rgba(232,123,53,0.3);
            margin-bottom: 12px;
        }
        .play-sub {
            font-size: clamp(12px, 2vw, 18px);
            color: rgba(255,235,210,0.5);
            margin-bottom: 40px;
        }
        .play-btn {
            width: 80px; height: 80px;
            border: 3px solid #e87b35;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: pulse 2s ease-in-out infinite;
        }
        .play-btn::after {
            content: '';
            display: block;
            width: 0; height: 0;
            border-style: solid;
            border-width: 18px 0 18px 30px;
            border-color: transparent transparent transparent #e87b35;
            margin-left: 6px;
        }
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(232,123,53,0.4); }
            50% { box-shadow: 0 0 0 20px rgba(232,123,53,0); }
        }
        .back-link {
            position: fixed;
            top: 12px; left: 12px;
            z-index: 30;
            color: rgba(255,235,210,0.4);
            text-decoration: none;
            font-size: 13px;
            padding: 6px 10px;
            border-radius: 6px;
            background: rgba(0,0,0,0.4);
            transition: color 0.2s;
        }
        .back-link:hover { color: rgba(255,235,210,0.8); }
    </style>
</head>
<body>
    <a href="music-videos/index.html" class="back-link">&larr; Music Videos</a>
    <canvas id="viz-canvas"></canvas>
    <div class="play-overlay" id="play-overlay">
        <div class="play-title">Kitchen Timer Fugue</div>
        <div class="play-sub">a chaotic culinary counterpoint</div>
        <div class="play-btn"></div>
    </div>

    <script src="../audio-tracker/playback-engine.js"></script>
    <script src="engine.js"></script>
    <script>
    // ── Kitchen Timer Fugue Video Renderer ────────────────────────────
    window.Renderers['kitchen-timer-fugue-video'] = (function() {
        "use strict";

        var W = 0, H = 0;
        var analysis = null;

        // ── Palette ──
        var BG_TOP = '#1a0f08';
        var BG_BOT = '#0d0805';
        var COPPER = '#c87533';
        var COPPER_LIGHT = '#e8a060';
        var FLAME_ORANGE = '#ff6a1a';
        var FLAME_YELLOW = '#ffcc33';
        var FLAME_RED = '#e83520';
        var STEAM_WHITE = '#fff5e8';
        var TILE_CREAM = '#f5e6d0';
        var TILE_GROUT = '#8a7560';
        var CAST_IRON = '#2a2226';
        var STAINLESS = '#9a9898';
        var COUNTER_TOP = '#3a3028';

        // Channel colors: each channel = a cooking station
        var STATION_COLORS = [
            '#e87b35',  // Ch0 Microwave - warm orange
            '#cc3322',  // Ch1 Oven - deep red
            '#55aa44',  // Ch2 Kitchen Bass - herb green
            '#ddcc22'   // Ch3 Smoke Alarm - alarm yellow
        ];

        var STATION_NAMES = ['MICROWAVE', 'OVEN', 'BASS LINE', 'SMOKE ALARM'];

        // ── Layout ──
        var COUNTER_Y_RATIO = 0.62;
        var TILE_TOP_RATIO = 0.08;

        // ── State ──
        var counterY = 0;
        var tileTop = 0;
        var lastBeat = -1;
        var beatPulse = 0;
        var flashAlpha = 0;
        var lastSeqIndex = -1;
        var sectionMood = 'exposition';
        var introFadeIn = 0;

        // Timer displays
        var timers = [];
        var timerDings = [];

        // Cooking stations (4 stations across the counter)
        var stations = [];

        // Steam particles
        var steamParticles = [];

        // Flame state per station
        var flames = [];

        // Bubbles per pot
        var bubbles = [];

        // Kitchen implements
        var implements_ = [];

        // Knife flash
        var knifeFlash = 0;
        var knifeX = 0;

        // Pot lid rattle
        var lidRattle = [];

        // Whisk rotation
        var whiskAngles = [];

        // Section-specific
        var chaosLevel = 0;
        var dingFlash = 0;
        var titleAlpha = 0;
        var titleTarget = 0;

        // Tile pattern
        var tilePhase = 0;

        // ── Helpers ──
        function lerp(a, b, t) { return a + (b - a) * t; }
        function lerpExp(current, target, speed, dt) {
            return current + (target - current) * (1 - Math.exp(-speed * dt));
        }
        function hexToRgb(hex) {
            return {
                r: parseInt(hex.slice(1, 3), 16),
                g: parseInt(hex.slice(3, 5), 16),
                b: parseInt(hex.slice(5, 7), 16)
            };
        }
        function rgba(hex, a) {
            var c = hexToRgb(hex);
            return 'rgba(' + c.r + ',' + c.g + ',' + c.b + ',' + a + ')';
        }

        // ── Section mapping based on fugue structure ──
        function mapSection(seqIdx) {
            // Exposition: voices enter one at a time (seq 0-7)
            if (seqIdx <= 1) return 'exposition-solo';     // Microwave alone
            if (seqIdx <= 3) return 'exposition-duo';      // + Oven
            if (seqIdx <= 5) return 'exposition-trio';     // + Bass
            if (seqIdx <= 7) return 'exposition-full';     // + Smoke Alarm, full texture
            // Episode 1: development (seq 8-12)
            if (seqIdx <= 12) return 'episode1';
            // Middle entries (seq 13-18)
            if (seqIdx <= 18) return 'middle';
            // Stretto: increasingly tight entries (seq 19-25)
            if (seqIdx <= 21) return 'stretto-mild';
            if (seqIdx <= 25) return 'stretto-chaos';
            // Coda and finale (seq 26-29+)
            if (seqIdx <= 27) return 'coda';
            return 'finale';
        }

        // ── Timer display objects ──
        function createTimer(x, y, startVal, speed) {
            return {
                x: x, y: y,
                value: startVal,
                speed: speed,
                active: false,
                blinking: false,
                blinkPhase: 0,
                size: 0.06, // relative to W
                dinging: false,
                dingTimer: 0
            };
        }

        // ── Init ──
        function init(ctx, width, height, anal) {
            W = width; H = height;
            analysis = anal;
            counterY = H * COUNTER_Y_RATIO;
            tileTop = H * TILE_TOP_RATIO;

            lastBeat = -1;
            beatPulse = 0;
            flashAlpha = 0;
            lastSeqIndex = -1;
            sectionMood = 'exposition-solo';
            introFadeIn = 0;
            chaosLevel = 0;
            dingFlash = 0;
            titleAlpha = 0;
            knifeFlash = 0;
            tilePhase = 0;

            // 4 cooking stations spaced across counter
            stations = [];
            flames = [];
            bubbles = [];
            lidRattle = [];
            whiskAngles = [];
            for (var i = 0; i < 4; i++) {
                var sx = W * (0.14 + i * 0.22);
                stations.push({
                    x: sx,
                    active: false,
                    intensity: 0,
                    potBubbleRate: 0,
                    flameHeight: 0
                });
                flames.push([]);
                bubbles.push([]);
                lidRattle.push(0);
                whiskAngles.push(Math.random() * Math.PI * 2);
            }

            // Timers along the top shelf
            timers = [];
            for (var ti = 0; ti < 6; ti++) {
                var tx = W * (0.1 + ti * 0.15);
                var ty = tileTop + H * 0.12;
                timers.push(createTimer(tx, ty, 300 + Math.floor(Math.random() * 500), 0.5 + Math.random() * 2));
            }
            timerDings = [];

            // Steam particles
            steamParticles = [];
            for (var si = 0; si < 60; si++) {
                steamParticles.push({
                    x: Math.random() * W,
                    y: counterY - Math.random() * H * 0.4,
                    vx: (Math.random() - 0.5) * 20,
                    vy: -10 - Math.random() * 40,
                    life: Math.random(),
                    maxLife: 2 + Math.random() * 3,
                    size: 2 + Math.random() * 6,
                    stationIdx: Math.floor(Math.random() * 4)
                });
            }

            implements_ = [];
        }

        // ── Resize ──
        function resize(width, height) {
            W = width; H = height;
            counterY = H * COUNTER_Y_RATIO;
            tileTop = H * TILE_TOP_RATIO;
            for (var i = 0; i < 4; i++) {
                stations[i].x = W * (0.14 + i * 0.22);
            }
            for (var ti = 0; ti < timers.length; ti++) {
                timers[ti].x = W * (0.1 + ti * 0.15);
                timers[ti].y = tileTop + H * 0.12;
            }
        }

        // ── Draw tiled backsplash ──
        function drawTiles(ctx, energy) {
            var tileH = counterY - tileTop;
            ctx.save();

            // Tile background
            ctx.fillStyle = TILE_CREAM;
            ctx.globalAlpha = 0.12 + energy * 0.05;
            ctx.fillRect(0, tileTop, W, tileH);

            // Grid lines
            var tileSize = Math.max(20, W * 0.04);
            ctx.strokeStyle = TILE_GROUT;
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.08 + energy * 0.04;

            for (var gx = 0; gx < W; gx += tileSize) {
                ctx.beginPath();
                ctx.moveTo(gx, tileTop);
                ctx.lineTo(gx, counterY);
                ctx.stroke();
            }
            for (var gy = tileTop; gy < counterY; gy += tileSize) {
                ctx.beginPath();
                ctx.moveTo(0, gy);
                ctx.lineTo(W, gy);
                ctx.stroke();
            }

            ctx.restore();
        }

        // ── Draw counter ──
        function drawCounter(ctx, energy) {
            ctx.save();

            // Counter surface
            var grad = ctx.createLinearGradient(0, counterY - 4, 0, counterY + H * 0.06);
            grad.addColorStop(0, '#4a3828');
            grad.addColorStop(0.3, COUNTER_TOP);
            grad.addColorStop(1, '#1a1210');
            ctx.fillStyle = grad;
            ctx.fillRect(0, counterY - 2, W, H * 0.06);

            // Counter edge highlight
            ctx.strokeStyle = rgba(COPPER_LIGHT, 0.3 + energy * 0.2);
            ctx.lineWidth = 2;
            ctx.shadowBlur = 6;
            ctx.shadowColor = rgba(COPPER_LIGHT, 0.2);
            ctx.beginPath();
            ctx.moveTo(0, counterY);
            ctx.lineTo(W, counterY);
            ctx.stroke();

            // Below counter: dark cabinets
            var cabY = counterY + H * 0.06;
            ctx.fillStyle = '#0d0a08';
            ctx.fillRect(0, cabY, W, H - cabY);

            // Cabinet handles
            ctx.strokeStyle = rgba(STAINLESS, 0.15);
            ctx.lineWidth = 2;
            var cabW = W / 5;
            for (var ci = 0; ci < 5; ci++) {
                var cx = cabW * ci + cabW * 0.3;
                var handleW = cabW * 0.4;
                var handleY = cabY + (H - cabY) * 0.3;
                ctx.beginPath();
                ctx.moveTo(cx, handleY);
                ctx.lineTo(cx + handleW, handleY);
                ctx.stroke();
            }

            ctx.restore();
        }

        // ── Draw a burner flame ──
        function drawFlame(ctx, x, baseY, height, energy, dt, stationIdx) {
            if (height < 2) return;
            var flameArr = flames[stationIdx];

            // Ensure enough flame particles
            while (flameArr.length < 12) {
                flameArr.push({
                    ox: (Math.random() - 0.5) * 30,
                    phase: Math.random() * Math.PI * 2,
                    speed: 1 + Math.random() * 3,
                    size: 0.5 + Math.random() * 0.5
                });
            }

            ctx.save();
            ctx.globalCompositeOperation = 'lighter';

            for (var fi = 0; fi < flameArr.length; fi++) {
                var f = flameArr[fi];
                f.phase += f.speed * dt * (2 + energy * 4);

                var flicker = Math.sin(f.phase) * 0.3 + Math.sin(f.phase * 2.7) * 0.2;
                var fh = height * f.size * (0.6 + flicker * 0.4);
                var fx = x + f.ox * (0.5 + energy * 0.5);
                var fy = baseY;

                // Flame gradient
                var grad = ctx.createLinearGradient(fx, fy, fx, fy - fh);
                grad.addColorStop(0, rgba(FLAME_ORANGE, 0.7 + flicker * 0.2));
                grad.addColorStop(0.3, rgba(FLAME_YELLOW, 0.5 + flicker * 0.2));
                grad.addColorStop(0.7, rgba(FLAME_RED, 0.3));
                grad.addColorStop(1, 'rgba(255,100,20,0)');

                ctx.fillStyle = grad;
                ctx.beginPath();
                var w = 4 + f.size * 6;
                ctx.moveTo(fx - w, fy);
                ctx.quadraticCurveTo(fx - w * 0.5 + flicker * 3, fy - fh * 0.6, fx + flicker * 5, fy - fh);
                ctx.quadraticCurveTo(fx + w * 0.5 - flicker * 3, fy - fh * 0.6, fx + w, fy);
                ctx.closePath();
                ctx.fill();
            }

            // Blue base
            var blueGrad = ctx.createRadialGradient(x, baseY, 0, x, baseY, 20 + energy * 10);
            blueGrad.addColorStop(0, 'rgba(50,120,255,0.4)');
            blueGrad.addColorStop(1, 'rgba(50,120,255,0)');
            ctx.fillStyle = blueGrad;
            ctx.fillRect(x - 25, baseY - 8, 50, 16);

            ctx.restore();
        }

        // ── Draw a copper pot ──
        function drawPot(ctx, x, y, w, h, stationIdx, energy, dt) {
            ctx.save();

            // Rattle offset
            var rattle = lidRattle[stationIdx];
            var rattleX = rattle * Math.sin(Date.now() * 0.03) * 2;
            var rattleY = rattle * Math.abs(Math.sin(Date.now() * 0.04)) * 3;

            // Pot body
            var potGrad = ctx.createLinearGradient(x - w / 2, y, x + w / 2, y);
            potGrad.addColorStop(0, '#8a5522');
            potGrad.addColorStop(0.3, COPPER_LIGHT);
            potGrad.addColorStop(0.6, COPPER);
            potGrad.addColorStop(1, '#6a4018');
            ctx.fillStyle = potGrad;

            // Rounded pot shape
            ctx.beginPath();
            ctx.moveTo(x - w / 2, y - h);
            ctx.lineTo(x - w / 2 - 4, y);
            ctx.quadraticCurveTo(x, y + 8, x + w / 2 + 4, y);
            ctx.lineTo(x + w / 2, y - h);
            ctx.closePath();
            ctx.fill();

            // Pot rim
            ctx.strokeStyle = COPPER_LIGHT;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(x, y - h, w / 2, 4, 0, 0, Math.PI * 2);
            ctx.stroke();

            // Handles
            ctx.strokeStyle = COPPER;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(x - w / 2 - 8, y - h * 0.5, 8, -0.5, 0.5);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(x + w / 2 + 8, y - h * 0.5, 8, Math.PI - 0.5, Math.PI + 0.5);
            ctx.stroke();

            // Lid (rattles with energy)
            ctx.fillStyle = '#999';
            ctx.strokeStyle = STAINLESS;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.ellipse(x + rattleX, y - h - 2 + rattleY, w / 2 + 2, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Lid knob
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(x + rattleX, y - h - 6 + rattleY, 4, 0, Math.PI * 2);
            ctx.fill();

            // Bubbles inside pot
            var bubbleArr = bubbles[stationIdx];
            var bubbleRate = stations[stationIdx].potBubbleRate;
            // Spawn bubbles
            if (Math.random() < bubbleRate * dt * 10) {
                bubbleArr.push({
                    x: x + (Math.random() - 0.5) * w * 0.6,
                    y: y - h + 2,
                    r: 1 + Math.random() * 3,
                    vy: -10 - Math.random() * 20,
                    life: 1
                });
            }
            // Update & draw bubbles
            ctx.fillStyle = rgba(STEAM_WHITE, 0.4);
            for (var bi = bubbleArr.length - 1; bi >= 0; bi--) {
                var b = bubbleArr[bi];
                b.y += b.vy * dt;
                b.life -= dt * 1.5;
                if (b.life <= 0 || b.y < y - h - 20) {
                    bubbleArr.splice(bi, 1);
                    continue;
                }
                ctx.globalAlpha = b.life * 0.6;
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            ctx.restore();
        }

        // ── Draw a timer display ──
        function drawTimer(ctx, timer, beatPulseVal) {
            if (!timer.active) return;
            ctx.save();

            var sz = W * timer.size;
            var x = timer.x;
            var y = timer.y;

            // Timer body (rounded rect)
            var blink = timer.blinking ? (Math.sin(timer.blinkPhase * 8) > 0 ? 1 : 0.3) : 1;
            ctx.fillStyle = rgba(CAST_IRON, 0.8 * blink);
            ctx.strokeStyle = rgba(STAINLESS, 0.4);
            ctx.lineWidth = 1;
            roundRect(ctx, x - sz / 2, y - sz * 0.4, sz, sz * 0.8, 4);
            ctx.fill();
            ctx.stroke();

            // LED display
            var mins = Math.floor(Math.max(0, timer.value) / 60);
            var secs = Math.floor(Math.max(0, timer.value) % 60);
            var timeStr = String(mins).padStart(2, '0') + ':' + String(secs).padStart(2, '0');

            var fontSize = sz * 0.35;
            ctx.font = '700 ' + fontSize + 'px "Source Sans 3", monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Green LED glow for active, red for done
            var ledColor = timer.value <= 0 ? '#ff2222' : '#22ff44';
            ctx.fillStyle = ledColor;
            ctx.shadowColor = ledColor;
            ctx.shadowBlur = 8 + beatPulseVal * 6;
            ctx.globalAlpha = blink;
            ctx.fillText(timeStr, x, y);

            // Timer tick flash on beat
            if (beatPulseVal > 0.5 && timer.value > 0) {
                ctx.globalAlpha = (beatPulseVal - 0.5) * 0.4;
                ctx.fillStyle = ledColor;
                ctx.shadowBlur = 20;
                ctx.fillText(timeStr, x, y);
            }

            ctx.restore();
        }

        function roundRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.arcTo(x + w, y, x + w, y + r, r);
            ctx.lineTo(x + w, y + h - r);
            ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
            ctx.lineTo(x + r, y + h);
            ctx.arcTo(x, y + h, x, y + h - r, r);
            ctx.lineTo(x, y + r);
            ctx.arcTo(x, y, x + r, y, r);
            ctx.closePath();
        }

        // ── Draw a knife (chopping animation) ──
        function drawKnife(ctx, x, y, chopPhase, energy) {
            ctx.save();
            ctx.translate(x, y);

            // Chop angle: rapid up-down on beat
            var angle = -0.3 + Math.sin(chopPhase * Math.PI * 2) * 0.6 * energy;
            ctx.rotate(angle);

            // Blade
            ctx.fillStyle = STAINLESS;
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = knifeFlash * 20;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(40, -2);
            ctx.lineTo(45, 2);
            ctx.lineTo(5, 6);
            ctx.closePath();
            ctx.fill();

            // Handle
            ctx.fillStyle = '#3a2010';
            ctx.fillRect(-15, -3, 18, 10);

            // Flash effect
            if (knifeFlash > 0.1) {
                ctx.globalAlpha = knifeFlash * 0.5;
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(40, -2);
                ctx.lineTo(45, 2);
                ctx.lineTo(5, 6);
                ctx.closePath();
                ctx.fill();
            }

            ctx.restore();
        }

        // ── Draw a whisk (spinning) ──
        function drawWhisk(ctx, x, y, angle, energy) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);

            // Handle
            ctx.strokeStyle = STAINLESS;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, -25);
            ctx.lineTo(0, 5);
            ctx.stroke();

            // Whisk wires
            ctx.lineWidth = 1.5;
            ctx.strokeStyle = rgba(STAINLESS, 0.7 + energy * 0.3);
            for (var wi = 0; wi < 6; wi++) {
                var wa = (wi / 6) * Math.PI * 2;
                var wr = 8 + energy * 4;
                ctx.beginPath();
                ctx.moveTo(0, 5);
                ctx.quadraticCurveTo(
                    Math.cos(wa) * wr, 15,
                    Math.cos(wa) * wr * 0.5, 25
                );
                ctx.stroke();
            }

            ctx.restore();
        }

        // ── Draw steam particles ──
        function updateAndDrawSteam(ctx, dt, energy) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';

            for (var si = 0; si < steamParticles.length; si++) {
                var p = steamParticles[si];
                var station = stations[p.stationIdx];
                if (!station.active) continue;

                p.life += dt;
                if (p.life > p.maxLife) {
                    // Reset
                    p.x = station.x + (Math.random() - 0.5) * 40;
                    p.y = counterY - 10;
                    p.life = 0;
                    p.vx = (Math.random() - 0.5) * 20;
                    p.vy = -10 - Math.random() * 40 * (1 + energy);
                }

                p.x += p.vx * dt + Math.sin(p.life * 2 + p.x * 0.01) * 10 * dt;
                p.y += p.vy * dt;
                p.vy -= 5 * dt; // rise faster

                var lifeRatio = p.life / p.maxLife;
                var alpha = (1 - lifeRatio) * 0.15 * station.intensity;
                var sz = p.size * (1 + lifeRatio * 3);

                ctx.globalAlpha = alpha;
                ctx.fillStyle = STEAM_WHITE;
                ctx.beginPath();
                ctx.arc(p.x, p.y, sz, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        // ── Draw station label ──
        function drawStationLabel(ctx, x, y, name, color, intensity) {
            if (intensity < 0.05) return;
            ctx.save();
            var fontSize = Math.max(10, W * 0.013);
            ctx.font = '700 ' + fontSize + 'px "Source Sans 3", sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillStyle = color;
            ctx.globalAlpha = intensity * 0.6;
            ctx.shadowColor = color;
            ctx.shadowBlur = 8;
            ctx.fillText(name, x, y);
            ctx.restore();
        }

        // ── Draw title ──
        function drawTitle(ctx) {
            if (titleAlpha < 0.01) return;
            ctx.save();

            var fontSize = Math.max(16, Math.min(W * 0.04, 52));
            ctx.font = '700 ' + fontSize + 'px "Playfair Display", serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            var y = tileTop + (counterY - tileTop) * 0.5;

            // Warm glow
            ctx.globalAlpha = titleAlpha * 0.9;
            ctx.shadowColor = FLAME_ORANGE;
            ctx.shadowBlur = 40;
            ctx.fillStyle = STEAM_WHITE;
            ctx.fillText('KITCHEN TIMER FUGUE', W / 2, y);

            // Second pass for intensity
            ctx.globalAlpha = titleAlpha * 0.4;
            ctx.shadowBlur = 80;
            ctx.fillStyle = FLAME_ORANGE;
            ctx.fillText('KITCHEN TIMER FUGUE', W / 2, y);

            ctx.restore();
        }

        // ── Ding effect ──
        function drawDingEffect(ctx) {
            if (dingFlash < 0.01) return;
            ctx.save();

            // Radiating rings from center
            ctx.globalCompositeOperation = 'lighter';
            var cx = W / 2;
            var cy = counterY * 0.5;
            var maxR = Math.max(W, H) * 0.4;

            for (var ri = 0; ri < 3; ri++) {
                var ringR = maxR * (1 - dingFlash) * (0.3 + ri * 0.3);
                var alpha = dingFlash * 0.15 * (1 - ri * 0.3);
                ctx.strokeStyle = rgba(FLAME_YELLOW, alpha);
                ctx.lineWidth = 3 - ri;
                ctx.beginPath();
                ctx.arc(cx, cy, ringR, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.restore();
        }

        // ── Draw flash overlay ──
        function drawFlash(ctx) {
            if (flashAlpha < 0.01) return;
            ctx.save();
            ctx.globalAlpha = flashAlpha;
            ctx.fillStyle = FLAME_YELLOW;
            ctx.fillRect(0, 0, W, H);
            ctx.restore();
        }

        // ── Draw warm ambient glow ──
        function drawAmbientGlow(ctx, energy) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';

            // Warm glow from below (stove light)
            for (var i = 0; i < 4; i++) {
                if (!stations[i].active) continue;
                var sx = stations[i].x;
                var intensity = stations[i].intensity;
                var grad = ctx.createRadialGradient(sx, counterY, 0, sx, counterY, H * 0.35);
                grad.addColorStop(0, rgba(FLAME_ORANGE, 0.08 * intensity));
                grad.addColorStop(0.5, rgba(FLAME_ORANGE, 0.03 * intensity));
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad;
                ctx.fillRect(sx - H * 0.35, counterY - H * 0.35, H * 0.7, H * 0.7);
            }

            ctx.restore();
        }

        // ── Main render ──
        function render(frameData) {
            var ctx = frameData.ctx;
            var dt = frameData.dt || 1 / 60;
            var cursor = frameData.cursor;

            // Background gradient
            var bgGrad = ctx.createLinearGradient(0, 0, 0, H);
            bgGrad.addColorStop(0, BG_TOP);
            bgGrad.addColorStop(1, BG_BOT);
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, W, H);

            if (!cursor) {
                // Idle state: dim kitchen
                drawTiles(ctx, 0);
                drawCounter(ctx, 0);
                return;
            }

            var beat = cursor.beat;
            var seqIdx = cursor.seqIndex;
            var energy = analysis ? (analysis.energy[cursor.timelineIndex] || 0) : 0;
            var currentNotes = frameData.currentNotes || [];

            // ── Section transitions ──
            var newSection = mapSection(seqIdx);
            if (seqIdx !== lastSeqIndex) {
                sectionMood = newSection;
                lastSeqIndex = seqIdx;

                // Ding flash on finale
                if (sectionMood === 'finale') {
                    dingFlash = 1;
                    flashAlpha = 0.3;
                    // All timers hit zero
                    for (var di = 0; di < timers.length; di++) {
                        timers[di].value = 0;
                        timers[di].blinking = true;
                    }
                }
            }

            // ── Compute chaos level from section ──
            var chaosTarget = 0;
            if (sectionMood === 'exposition-solo') chaosTarget = 0.1;
            else if (sectionMood === 'exposition-duo') chaosTarget = 0.2;
            else if (sectionMood === 'exposition-trio') chaosTarget = 0.35;
            else if (sectionMood === 'exposition-full') chaosTarget = 0.5;
            else if (sectionMood === 'episode1') chaosTarget = 0.55;
            else if (sectionMood === 'middle') chaosTarget = 0.65;
            else if (sectionMood === 'stretto-mild') chaosTarget = 0.8;
            else if (sectionMood === 'stretto-chaos') chaosTarget = 0.95;
            else if (sectionMood === 'coda') chaosTarget = 0.85;
            else if (sectionMood === 'finale') chaosTarget = 1.0;
            chaosLevel = lerpExp(chaosLevel, chaosTarget, 3, dt);

            // ── Intro fade ──
            introFadeIn = Math.min(1, introFadeIn + dt * 0.5);

            // ── Activate stations based on fugue voice entries ──
            stations[0].active = true; // Microwave always on after start
            stations[1].active = seqIdx >= 2; // Oven enters seq 2
            stations[2].active = seqIdx >= 4; // Bass enters seq 4
            stations[3].active = seqIdx >= 5; // Smoke alarm enters seq 5

            // Station intensity from current notes
            for (var chi = 0; chi < 4; chi++) {
                var noteActive = currentNotes[chi] && currentNotes[chi].midi;
                var targetInt = noteActive ? (0.5 + energy * 0.5) : 0.1;
                if (!stations[chi].active) targetInt = 0;
                stations[chi].intensity = lerpExp(stations[chi].intensity, targetInt, 8, dt);
                stations[chi].flameHeight = stations[chi].intensity * (30 + energy * 40);
                stations[chi].potBubbleRate = stations[chi].intensity * (0.5 + energy * 2);
            }

            // ── Beat pulse ──
            if (beat !== lastBeat) {
                beatPulse = 1;
                knifeFlash = 0.8;

                // Timer countdown ticks
                for (var tci = 0; tci < timers.length; tci++) {
                    var tmr = timers[tci];
                    if (tmr.active && tmr.value > 0) {
                        tmr.value -= tmr.speed;
                        if (tmr.value <= 0) {
                            tmr.value = 0;
                            tmr.blinking = true;
                            dingFlash = Math.max(dingFlash, 0.5);
                        }
                    }
                }

                // Activate timers progressively with chaos
                var numActiveTimers = Math.floor(1 + chaosLevel * 5);
                for (var tai = 0; tai < timers.length; tai++) {
                    timers[tai].active = tai < numActiveTimers;
                    if (timers[tai].active && timers[tai].value <= 0 && !timers[tai].blinking) {
                        timers[tai].value = 100 + Math.floor(Math.random() * 400);
                    }
                }

                // Lid rattle on beat
                for (var lri = 0; lri < 4; lri++) {
                    if (stations[lri].active) {
                        lidRattle[lri] = stations[lri].intensity * (1 + energy);
                    }
                }

                // Flash on high-energy stretto/finale beats
                if ((sectionMood === 'stretto-chaos' || sectionMood === 'finale') && energy > 0.5) {
                    flashAlpha = 0.1 + energy * 0.1;
                }

                lastBeat = beat;
            }

            beatPulse *= Math.exp(-8 * dt);
            knifeFlash *= Math.exp(-10 * dt);
            dingFlash *= Math.exp(-3 * dt);
            flashAlpha *= Math.exp(-6 * dt);

            // Decay lid rattle
            for (var dri = 0; dri < 4; dri++) {
                lidRattle[dri] *= Math.exp(-5 * dt);
            }

            // Update timer blink phases
            for (var tbi = 0; tbi < timers.length; tbi++) {
                if (timers[tbi].blinking) {
                    timers[tbi].blinkPhase += dt;
                    // Reset after a while
                    if (timers[tbi].blinkPhase > 6) {
                        timers[tbi].blinking = false;
                        timers[tbi].blinkPhase = 0;
                        timers[tbi].value = 100 + Math.floor(Math.random() * 400);
                    }
                }
            }

            // Spin whisks
            for (var whi = 0; whi < 4; whi++) {
                whiskAngles[whi] += dt * stations[whi].intensity * (3 + energy * 8);
            }

            // ── Title visibility ──
            titleTarget = (sectionMood === 'exposition-solo' || sectionMood === 'finale') ? 1 : 0;
            titleAlpha = lerpExp(titleAlpha, titleTarget, 3, dt);

            // ── Draw scene (back to front) ──

            // 1. Ambient glow
            drawAmbientGlow(ctx, energy);

            // 2. Tile backsplash
            drawTiles(ctx, energy);

            // 3. Timers on the shelf
            for (var dti = 0; dti < timers.length; dti++) {
                drawTimer(ctx, timers[dti], beatPulse);
            }

            // 4. Title
            drawTitle(ctx);

            // 5. Counter
            drawCounter(ctx, energy);

            // 6. Flames under pots
            var potW = W * 0.07;
            var potH = H * 0.08;
            for (var fli = 0; fli < 4; fli++) {
                if (!stations[fli].active) continue;
                drawFlame(ctx, stations[fli].x, counterY - 2, stations[fli].flameHeight, energy, dt, fli);
            }

            // 7. Pots on counter
            for (var pi = 0; pi < 4; pi++) {
                if (!stations[pi].active) continue;
                drawPot(ctx, stations[pi].x, counterY - 2, potW, potH, pi, energy, dt);
            }

            // 8. Kitchen implements between/around pots
            // Knife between stations 0 and 1
            if (stations[0].active) {
                var knifeBaseX = (stations[0].x + (stations[1].active ? stations[1].x : stations[0].x + W * 0.15)) / 2;
                drawKnife(ctx, knifeBaseX, counterY - potH * 0.3, cursor.totalFracRow * 0.5, energy);
            }

            // Whisks near active stations
            for (var wi = 0; wi < 4; wi++) {
                if (!stations[wi].active) continue;
                drawWhisk(ctx, stations[wi].x + potW * 0.8, counterY - potH * 1.1, whiskAngles[wi], energy);
            }

            // 9. Steam
            updateAndDrawSteam(ctx, dt, energy);

            // 10. Station labels below counter
            for (var sli = 0; sli < 4; sli++) {
                drawStationLabel(
                    ctx,
                    stations[sli].x,
                    counterY + H * 0.07,
                    STATION_NAMES[sli],
                    STATION_COLORS[sli],
                    stations[sli].intensity
                );
            }

            // 11. Ding effect
            drawDingEffect(ctx);

            // 12. Flash overlay
            drawFlash(ctx);

            // 13. Beat-sync visual: counter edge flashes with copper on every beat
            if (beatPulse > 0.1) {
                ctx.save();
                ctx.globalAlpha = beatPulse * 0.3;
                ctx.strokeStyle = COPPER_LIGHT;
                ctx.lineWidth = 3;
                ctx.shadowBlur = 15;
                ctx.shadowColor = COPPER_LIGHT;
                ctx.beginPath();
                ctx.moveTo(0, counterY);
                ctx.lineTo(W, counterY);
                ctx.stroke();
                ctx.restore();
            }

            // 14. Chaos smoke overlay at high levels
            if (chaosLevel > 0.7) {
                ctx.save();
                var smokeAlpha = (chaosLevel - 0.7) * 0.15;
                ctx.globalAlpha = smokeAlpha;
                ctx.fillStyle = '#888';
                // Animated smoke wisps
                for (var swi = 0; swi < 5; swi++) {
                    var swy = H * 0.1 + Math.sin(cursor.elapsed * 0.3 + swi * 1.5) * H * 0.15;
                    var swx = (cursor.elapsed * 20 + swi * W * 0.25) % (W * 1.5) - W * 0.25;
                    var swGrad = ctx.createRadialGradient(swx, swy, 0, swx, swy, W * 0.15);
                    swGrad.addColorStop(0, 'rgba(136,136,136,' + smokeAlpha + ')');
                    swGrad.addColorStop(1, 'rgba(136,136,136,0)');
                    ctx.fillStyle = swGrad;
                    ctx.fillRect(swx - W * 0.15, swy - W * 0.15, W * 0.3, W * 0.3);
                }
                ctx.restore();
            }
        }

        return {
            name: 'Kitchen Timer Fugue Video',
            init: init,
            render: render,
            resize: resize
        };
    })();

    // ── Page bootstrap ──
    (function() {
        var canvas = document.getElementById('viz-canvas');
        var overlay = document.getElementById('play-overlay');

        Visualizer.init(canvas);
        Visualizer.setRenderer('kitchen-timer-fugue-video');

        function loadAndPlay(json) {
            Visualizer.loadSong(json);
            Visualizer.play();
        }

        function fetchSong() {
            var url = '../audio-tracker/songs/kitchen-timer-fugue.json';
            if (window.fetch && location.protocol !== 'file:') {
                return fetch(url).then(function(r) { return r.json(); });
            }
            return new Promise(function(resolve, reject) {
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.onload = function() {
                    if (xhr.status === 200 || xhr.status === 0) {
                        resolve(JSON.parse(xhr.responseText));
                    } else {
                        reject(new Error('XHR failed: ' + xhr.status));
                    }
                };
                xhr.onerror = function() { reject(new Error('XHR error')); };
                xhr.send();
            });
        }

        overlay.addEventListener('click', function() {
            overlay.classList.add('hidden');
            fetchSong().then(loadAndPlay).catch(function(err) {
                console.error('Failed to load song:', err);
                overlay.classList.remove('hidden');
            });
        });

        canvas.addEventListener('click', function() {
            if (overlay.classList.contains('hidden')) {
                if (Visualizer.isPlaying()) {
                    Visualizer.stop();
                } else {
                    Visualizer.play();
                }
            }
        });
    })();
    </script>
</body>
</html>
