<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Cyberpunk Survivors</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0a1a;font-family:'Share Tech Mono',monospace;color:#c0e0ff}
canvas{display:block;width:100%;height:100%;touch-action:none}
#ui-overlay{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:10}
#hud{position:absolute;top:0;left:0;width:100%;padding:8px 12px;display:flex;justify-content:space-between;align-items:flex-start;font-family:'Orbitron',sans-serif}
#hud-left,#hud-right{display:flex;flex-direction:column;gap:4px}
#hud-right{align-items:flex-end}
.hud-text{font-size:14px;text-shadow:0 0 8px rgba(0,255,255,0.6),1px 1px 2px #000;color:#c0e0ff}
.hud-big{font-size:18px;font-weight:700;color:#00ffff}
#xp-bar-container{position:absolute;top:0;left:0;width:100%;height:4px;background:rgba(0,0,0,0.7)}
#xp-bar{height:100%;background:linear-gradient(90deg,#ff0080,#00ffff);width:0%;transition:width 0.3s}
#hp-bar-container{position:absolute;bottom:60px;left:50%;transform:translateX(-50%);width:200px;height:8px;background:rgba(0,0,0,0.7);border:1px solid #555;border-radius:4px;overflow:hidden}
#hp-bar{height:100%;background:linear-gradient(90deg,#00ffff,#ff0080);width:100%;transition:width 0.3s}
#weapon-bar{position:absolute;bottom:12px;left:50%;transform:translateX(-50%);display:flex;gap:4px}
.weapon-slot{width:36px;height:36px;border:2px solid #555;background:rgba(0,0,0,0.6);border-radius:4px;display:flex;align-items:center;justify-content:center;font-size:18px}
.weapon-slot.active{border-color:#00ffff;box-shadow:0 0 8px rgba(0,255,255,0.5)}
#title-screen,#game-over-screen,#level-up-screen,#pause-screen{position:fixed;top:0;left:0;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:20;pointer-events:auto}
#title-screen{background:radial-gradient(ellipse at center,#0a0a2a 0%,#0a0a1a 70%)}
#game-over-screen{background:rgba(5,0,15,0.92);display:none}
#level-up-screen{background:rgba(5,0,15,0.85);display:none}
#pause-screen{background:rgba(0,0,10,0.8);display:none}
.screen-title{font-family:'Orbitron',sans-serif;font-size:clamp(2.5rem,8vw,5rem);font-weight:900;color:#ff0080;text-shadow:0 0 40px rgba(255,0,128,0.6),0 0 80px rgba(0,255,255,0.3);margin-bottom:8px;text-align:center;letter-spacing:0.05em}
.screen-subtitle{font-family:'Share Tech Mono',monospace;font-size:clamp(1rem,3vw,1.4rem);color:#00ffff;font-style:normal;margin-bottom:32px;text-align:center}
.btn{font-family:'Orbitron',sans-serif;font-size:1.1rem;font-weight:700;padding:14px 40px;border:2px solid #00ffff;background:rgba(255,0,128,0.3);color:#c0e0ff;cursor:pointer;letter-spacing:0.1em;text-transform:uppercase;transition:all 0.2s;pointer-events:auto}
.btn:hover{background:rgba(255,0,128,0.6);box-shadow:0 0 20px rgba(0,255,255,0.4);transform:scale(1.05)}
.stats-line{font-size:1.1rem;color:#8090b0;margin:4px 0}
.upgrade-cards{display:flex;gap:16px;flex-wrap:wrap;justify-content:center;max-width:700px;padding:0 16px}
.upgrade-card{width:200px;padding:20px 16px;border:2px solid #333;background:rgba(10,10,30,0.9);cursor:pointer;text-align:center;transition:all 0.2s;pointer-events:auto;border-radius:4px}
.upgrade-card:hover{border-color:#00ffff;box-shadow:0 0 20px rgba(0,255,255,0.3);transform:translateY(-4px)}
.upgrade-icon{font-size:2.5rem;margin-bottom:8px}
.upgrade-name{font-family:'Orbitron',sans-serif;font-size:1rem;font-weight:700;color:#00ffff;margin-bottom:6px}
.upgrade-desc{font-size:0.85rem;color:#8090b0;line-height:1.4}
.upgrade-hotkey{position:absolute;top:8px;right:10px;font-family:'Orbitron',sans-serif;font-size:0.75rem;color:#777;border:1px solid #555;border-radius:3px;width:22px;height:22px;display:flex;align-items:center;justify-content:center}
.upgrade-card{position:relative}
.upgrade-card.selected{border-color:#00ffff;box-shadow:0 0 20px rgba(0,255,255,0.3);transform:translateY(-4px)}
#touch-zone{position:fixed;bottom:0;left:0;width:200px;height:200px;z-index:15;pointer-events:auto;display:none}
@media(hover:none)and(pointer:coarse){#touch-zone{display:block}}
@media(max-width:600px){.upgrade-cards{flex-direction:column;align-items:center}.upgrade-card{width:85%}.weapon-slot{width:28px;height:28px;font-size:14px}}
</style>
</head>
<body>
<canvas id="game-canvas"></canvas>
<div id="ui-overlay">
  <div id="xp-bar-container"><div id="xp-bar"></div></div>
  <div id="hud">
    <div id="hud-left">
      <div class="hud-text hud-big" id="hud-level">Level 1</div>
      <div class="hud-text" id="hud-time">0:00</div>
      <div class="hud-text" id="hud-kills">Kills: 0</div>
    </div>
    <div id="hud-right">
      <div class="hud-text" id="hud-wave">Wave 1</div>
    </div>
  </div>
  <div id="hp-bar-container"><div id="hp-bar"></div></div>
  <div id="weapon-bar"></div>
</div>
<div id="touch-zone"></div>

<div id="title-screen">
  <div class="screen-title">Cyberpunk Survivors</div>
  <div class="screen-subtitle">Survive the Grid</div>
  <button class="btn" id="btn-start">Begin</button>
  <div style="margin-top:24px;font-size:0.85rem;color:#556;text-align:center">WASD / Arrows to move &bull; Auto-attack &bull; Survive</div>
</div>

<div id="game-over-screen">
  <div class="screen-title">System Failure</div>
  <div id="go-stats"></div>
  <button class="btn" id="btn-restart" style="margin-top:24px">Reboot</button>
</div>

<div id="level-up-screen">
  <div class="screen-title" style="font-size:clamp(1.5rem,5vw,2.5rem)">Level Up</div>
  <div class="screen-subtitle">Choose your upgrade</div>
  <div class="upgrade-cards" id="upgrade-cards"></div>
</div>

<div id="pause-screen">
  <div class="screen-title" style="font-size:clamp(1.5rem,5vw,2.5rem)">Paused</div>
  <button class="btn" id="btn-resume">Resume</button>
</div>

<script>
// ============================================================
// THEME CONFIGURATION
// ============================================================
const THEME = {
  name: 'Cyberpunk Survivors',
  fonts: { title: 'Orbitron', body: 'Share Tech Mono' },
  palette: {
    bg: '#0a0a1a', bgLight: '#1a1a2a', accent: '#ff0080',
    gold: '#00ffff', bone: '#c0e0ff', emerald: '#39ff14',
    purple: '#bf00ff', blood: '#ff0040', midnight: '#050515',
    floorBase: '#0d0d2a', floorLine: '#1a1a3a'
  },
  // Enemy types: name, color, size, speed, hp, xp, spawnAfter(seconds)
  enemies: [
    { name:'Drone', color:'#00ddff', size:12, speed:65, hp:3, xp:1, spawnAfter:0, draw:'drone' },
    { name:'Mech', color:'#888899', size:18, speed:30, hp:8, xp:2, spawnAfter:0, draw:'mech' },
    { name:'Glitch Bug', color:'#ff00ff', size:11, speed:85, hp:2, xp:2, spawnAfter:30, draw:'glitch' },
    { name:'Cyber-wolf', color:'#39ff14', size:14, speed:95, hp:4, xp:3, spawnAfter:90, draw:'cyberwolf' },
    { name:'Heavy Tank', color:'#ff6600', size:20, speed:25, hp:12, xp:5, spawnAfter:180, draw:'tank' },
    { name:'Rogue AI', color:'#ffffff', size:16, speed:70, hp:18, xp:8, spawnAfter:300, draw:'rogueai' }
  ],
  bosses: [
    { name:'Mega Drone', color:'#00ffff', size:50, speed:35, hp:200, xp:50, spawnAt:120 },
    { name:'War Mech', color:'#ff6600', size:48, speed:40, hp:400, xp:80, spawnAt:240 },
    { name:'Virus Core', color:'#ff00ff', size:45, speed:55, hp:700, xp:120, spawnAt:360 },
    { name:'Singularity', color:'#ffffff', size:55, speed:50, hp:1200, xp:200, spawnAt:480 }
  ],
  weapons: [
    { name:'Plasma Pistol', desc:'Fires a plasma bolt', icon:'\u26A1', type:'projectile' },
    { name:'Shield Drones', desc:'Orbiting drone shield', icon:'\u2B21', type:'orbit' },
    { name:'EMP Pulse', desc:'Expanding EMP blast', icon:'\u29BF', type:'area' },
    { name:'Arc Discharge', desc:'Bounces between foes', icon:'\u2301', type:'chain' },
    { name:'Laser Beam', desc:'Sustained laser beam', icon:'\u2588', type:'beam' },
    { name:'Nano Swarm', desc:'Nanobots from above', icon:'\u2663', type:'rain' },
    { name:'Disc Launcher', desc:'Returning energy disc', icon:'\u25C9', type:'boomerang' },
    { name:'Firewall', desc:'Burning code zone', icon:'\u2593', type:'field' }
  ],
  passives: [
    { name:'Nanomed', desc:'+20% Max HP', icon:'\u2665', stat:'maxHp', mult:1.2 },
    { name:'Overclock', desc:'+15% Move Speed', icon:'\u27A4', stat:'speed', mult:1.15 },
    { name:'Tractor Beam', desc:'+40% Pickup Range', icon:'\u2609', stat:'pickupRadius', mult:1.4 },
    { name:'Amplifier', desc:'+20% Damage', icon:'\u2694', stat:'damage', mult:1.2 },
    { name:'Turbo', desc:'+15% Attack Speed', icon:'\u231A', stat:'attackSpeed', mult:1.15 },
    { name:'Plating', desc:'-15% Damage Taken', icon:'\u26E8', stat:'defense', mult:0.85 }
  ],
  drawPlayer(ctx, x, y, r, time) {
    // Cyberpunk character - angular body, visor/helmet with cyan glow
    ctx.save();
    ctx.translate(x, y);
    // Dark armor body
    ctx.beginPath();
    ctx.moveTo(-r*0.6, -r*0.2);
    ctx.lineTo(-r*0.8, r);
    ctx.lineTo(-r*0.2, r*0.8);
    ctx.lineTo(r*0.2, r*0.8);
    ctx.lineTo(r*0.8, r);
    ctx.lineTo(r*0.6, -r*0.2);
    ctx.closePath();
    ctx.fillStyle = '#1a1a2a';
    ctx.fill();
    ctx.strokeStyle = '#00ffff';
    ctx.lineWidth = 1;
    ctx.stroke();
    // Torso
    ctx.beginPath();
    ctx.moveTo(-r*0.5, -r*0.3);
    ctx.lineTo(-r*0.4, r*0.3);
    ctx.lineTo(r*0.4, r*0.3);
    ctx.lineTo(r*0.5, -r*0.3);
    ctx.closePath();
    ctx.fillStyle = '#252540';
    ctx.fill();
    // Helmet
    ctx.beginPath();
    ctx.arc(0, -r*0.6, r*0.4, 0, Math.PI*2);
    ctx.fillStyle = '#1a1a30';
    ctx.fill();
    ctx.strokeStyle = '#ff0080';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    // Visor glow
    const glow = 0.5 + 0.5*Math.sin(time*3);
    ctx.fillStyle = `rgba(0,255,255,${0.6+glow*0.4})`;
    ctx.shadowColor = '#00ffff';
    ctx.shadowBlur = 10;
    ctx.beginPath();
    ctx.ellipse(0, -r*0.65, r*0.28, r*0.08, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;
    // Shoulder accents
    ctx.fillStyle = '#ff0080';
    ctx.fillRect(-r*0.55, -r*0.25, r*0.12, r*0.06);
    ctx.fillRect(r*0.43, -r*0.25, r*0.12, r*0.06);
    ctx.restore();
  },
  drawEnemy(ctx, e, time) {
    const {x, y, size, type} = e;
    ctx.save();
    ctx.translate(x, y);
    const s = size;
    if(type.draw==='drone') {
      // Diamond shape with cyan glow, rotating
      const rot = time * 3 + e.spawnTime;
      ctx.rotate(rot);
      ctx.fillStyle = type.color;
      ctx.shadowColor = type.color;
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.moveTo(0, -s*0.6);
      ctx.lineTo(s*0.5, 0);
      ctx.lineTo(0, s*0.6);
      ctx.lineTo(-s*0.5, 0);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#0a0a1a';
      ctx.beginPath(); ctx.arc(0, 0, s*0.15, 0, Math.PI*2); ctx.fill();
    } else if(type.draw==='mech') {
      // Rectangular body with treads, grey metal
      ctx.fillStyle = '#555566';
      ctx.fillRect(-s*0.4, -s*0.5, s*0.8, s*0.9);
      ctx.fillStyle = type.color;
      ctx.fillRect(-s*0.35, -s*0.45, s*0.7, s*0.3);
      // Treads
      ctx.fillStyle = '#333344';
      ctx.fillRect(-s*0.5, s*0.2, s*0.15, s*0.4);
      ctx.fillRect(s*0.35, s*0.2, s*0.15, s*0.4);
      // Eye visor
      ctx.fillStyle = '#ff0040';
      ctx.fillRect(-s*0.2, -s*0.38, s*0.4, s*0.08);
    } else if(type.draw==='glitch') {
      // Flickering square that shifts position slightly
      const flick = Math.sin(time*20 + e.spawnTime*7);
      const ox = flick * 3;
      const oy = Math.cos(time*17 + e.spawnTime*5) * 2;
      ctx.fillStyle = type.color;
      ctx.globalAlpha = 0.6 + 0.4*Math.abs(flick);
      ctx.shadowColor = type.color;
      ctx.shadowBlur = 10;
      ctx.fillRect(-s*0.4+ox, -s*0.4+oy, s*0.8, s*0.8);
      ctx.shadowBlur = 0;
      // Scanlines
      ctx.fillStyle = 'rgba(0,0,0,0.4)';
      for(let i=0;i<4;i++) {
        ctx.fillRect(-s*0.4+ox, -s*0.4+oy+i*s*0.2, s*0.8, 2);
      }
      ctx.globalAlpha = 1;
    } else if(type.draw==='cyberwolf') {
      // Angular wolf shape, green glow
      ctx.fillStyle = type.color;
      ctx.shadowColor = type.color;
      ctx.shadowBlur = 8;
      // Body
      ctx.beginPath();
      ctx.moveTo(-s*0.6, 0);
      ctx.lineTo(-s*0.3, -s*0.4);
      ctx.lineTo(s*0.4, -s*0.3);
      ctx.lineTo(s*0.7, -s*0.1);
      ctx.lineTo(s*0.5, s*0.3);
      ctx.lineTo(-s*0.4, s*0.3);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
      // Eye
      ctx.fillStyle = '#ff0040';
      ctx.beginPath(); ctx.arc(s*0.3, -s*0.15, 2.5, 0, Math.PI*2); ctx.fill();
      // Legs
      ctx.strokeStyle = type.color;
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(-s*0.3,s*0.3); ctx.lineTo(-s*0.35,s*0.55); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(s*0.2,s*0.3); ctx.lineTo(s*0.25,s*0.55); ctx.stroke();
    } else if(type.draw==='tank') {
      // Wide hexagonal shape, orange glow, bulky
      ctx.fillStyle = '#443322';
      ctx.shadowColor = type.color;
      ctx.shadowBlur = 12;
      ctx.beginPath();
      ctx.moveTo(-s*0.3, -s*0.55);
      ctx.lineTo(s*0.3, -s*0.55);
      ctx.lineTo(s*0.6, 0);
      ctx.lineTo(s*0.3, s*0.55);
      ctx.lineTo(-s*0.3, s*0.55);
      ctx.lineTo(-s*0.6, 0);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.strokeStyle = type.color;
      ctx.lineWidth = 2;
      ctx.stroke();
      // Inner plate
      ctx.fillStyle = type.color;
      ctx.globalAlpha = 0.3;
      ctx.beginPath();
      ctx.moveTo(-s*0.15, -s*0.3);
      ctx.lineTo(s*0.15, -s*0.3);
      ctx.lineTo(s*0.3, 0);
      ctx.lineTo(s*0.15, s*0.3);
      ctx.lineTo(-s*0.15, s*0.3);
      ctx.lineTo(-s*0.3, 0);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 1;
      // Center dot
      ctx.fillStyle = type.color;
      ctx.beginPath(); ctx.arc(0, 0, s*0.12, 0, Math.PI*2); ctx.fill();
    } else if(type.draw==='rogueai') {
      // Pulsing white sphere with data streams
      const pulse = 0.8 + 0.2*Math.sin(time*5 + e.spawnTime);
      ctx.fillStyle = type.color;
      ctx.shadowColor = type.color;
      ctx.shadowBlur = 20;
      ctx.globalAlpha = 0.7 + 0.3*pulse;
      ctx.beginPath(); ctx.arc(0, 0, s*0.5*pulse, 0, Math.PI*2); ctx.fill();
      ctx.shadowBlur = 0;
      // Data stream rings
      ctx.strokeStyle = 'rgba(0,255,255,0.4)';
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.arc(0, 0, s*0.65, time*2, time*2+Math.PI*1.2); ctx.stroke();
      ctx.strokeStyle = 'rgba(255,0,128,0.4)';
      ctx.beginPath(); ctx.arc(0, 0, s*0.75, -time*1.5, -time*1.5+Math.PI*0.8); ctx.stroke();
      ctx.globalAlpha = 1;
      // Core
      ctx.fillStyle = '#00ffff';
      ctx.beginPath(); ctx.arc(0, 0, s*0.15, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();
  },
  drawBoss(ctx, e, time) {
    const {x, y, size} = e;
    ctx.save();
    ctx.translate(x, y);
    const s = size;
    // Neon glow outer
    ctx.fillStyle = e.type.color;
    ctx.shadowColor = e.type.color;
    ctx.shadowBlur = 40;
    ctx.beginPath(); ctx.arc(0, 0, s, 0, Math.PI*2); ctx.fill();
    ctx.shadowBlur = 0;
    // Inner dark ring
    ctx.fillStyle = 'rgba(10,10,26,0.5)';
    ctx.beginPath(); ctx.arc(0, 0, s*0.7, 0, Math.PI*2); ctx.fill();
    // Inner core
    ctx.fillStyle = e.type.color;
    ctx.beginPath(); ctx.arc(0, 0, s*0.4, 0, Math.PI*2); ctx.fill();
    // Scanlines
    ctx.strokeStyle = 'rgba(10,10,26,0.3)';
    ctx.lineWidth = 2;
    for(let i=-s;i<s;i+=6) {
      ctx.beginPath(); ctx.moveTo(-s, i); ctx.lineTo(s, i); ctx.stroke();
    }
    // Eyes
    ctx.fillStyle = '#ff0080';
    ctx.shadowColor = '#ff0080';
    ctx.shadowBlur = 10;
    ctx.beginPath();
    ctx.arc(-s*0.2, -s*0.15, s*0.1, 0, Math.PI*2);
    ctx.arc(s*0.2, -s*0.15, s*0.1, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;
    // HP bar
    const hpPct = e.hp / e.maxHp;
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(-s, -s-14, s*2, 8);
    ctx.fillStyle = hpPct > 0.5 ? '#00ffff' : '#ff0080';
    ctx.fillRect(-s, -s-14, s*2*hpPct, 8);
    ctx.strokeStyle = '#555';
    ctx.strokeRect(-s, -s-14, s*2, 8);
    // Name
    ctx.fillStyle = '#00ffff';
    ctx.font = '12px Orbitron';
    ctx.textAlign = 'center';
    ctx.fillText(e.type.name, 0, -s-18);
    ctx.restore();
  },
  drawBackground(ctx, cam, W, H, time) {
    // Dark grid floor with neon grid lines
    ctx.fillStyle = THEME.palette.floorBase;
    ctx.fillRect(0, 0, W, H);
    const gs = 64;
    const ox = (-cam.x % gs + gs) % gs;
    const oy = (-cam.y % gs + gs) % gs;
    // Cyan grid lines
    ctx.strokeStyle = '#00ffff';
    ctx.lineWidth = 1;
    ctx.globalAlpha = 0.08;
    for(let x = ox; x < W; x += gs) {
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
    }
    for(let y = oy; y < H; y += gs) {
      ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
    }
    ctx.globalAlpha = 1;
    // Digital rain-like particles in background
    const rainCount = 12;
    for(let i = 0; i < rainCount; i++) {
      const rx = ((i * 347 + 100) % 1400) - cam.x % 1400;
      const ry = ((i * 521 + (time * 40 * (1 + i%3)) ) % 1000) - cam.y % 1000;
      const a = 0.06 + 0.04 * Math.sin(time * 2 + i);
      ctx.fillStyle = `rgba(0,255,255,${a})`;
      ctx.font = '10px Share Tech Mono';
      const chars = ['0','1','0','1','#','@','$'];
      ctx.fillText(chars[i % chars.length], rx, ry);
    }
    // Occasional glitch flicker spots
    if(Math.sin(time * 7.3) > 0.95) {
      const gx = ((time * 200) % W);
      const gy = ((time * 137) % H);
      ctx.fillStyle = 'rgba(255,0,128,0.06)';
      ctx.fillRect(gx - 50, gy - 2, 100, 4);
    }
    if(Math.sin(time * 11.7) > 0.93) {
      const gx2 = ((time * 300 + 400) % W);
      const gy2 = ((time * 200 + 100) % H);
      ctx.fillStyle = 'rgba(0,255,255,0.05)';
      ctx.fillRect(gx2 - 80, gy2 - 1, 160, 2);
    }
  },
  drawProjectile(ctx, p) {
    ctx.save();
    ctx.translate(p.x, p.y);
    if(p.weaponType === 'projectile') {
      // Bright cyan elongated bolt
      ctx.fillStyle = '#00ffff';
      ctx.shadowColor = '#00ffff'; ctx.shadowBlur = 12;
      const angle = Math.atan2(p.vy, p.vx);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.ellipse(0, 0, 6+p.level, 2+p.level*0.5, 0, 0, Math.PI*2);
      ctx.fill();
    } else if(p.weaponType === 'chain') {
      // Electric arcs (blue-white)
      ctx.strokeStyle = '#ccddff';
      ctx.shadowColor = '#88aaff'; ctx.shadowBlur = 12;
      ctx.lineWidth = 2 + p.level;
      ctx.beginPath(); ctx.moveTo(-8,0); ctx.lineTo(-3,4); ctx.lineTo(3,-4); ctx.lineTo(8,0); ctx.stroke();
    } else if(p.weaponType === 'rain') {
      // Green nano particles falling
      ctx.fillStyle = '#39ff14';
      ctx.shadowColor = '#39ff14'; ctx.shadowBlur = 10;
      ctx.beginPath(); ctx.arc(0,0,4+p.level,0,Math.PI*2); ctx.fill();
      // Tiny orbiting dots
      for(let i=0;i<3;i++) {
        const a = p.angle*3 + i*Math.PI*2/3;
        ctx.fillStyle = 'rgba(57,255,20,0.5)';
        ctx.beginPath(); ctx.arc(Math.cos(a)*6, Math.sin(a)*6, 1.5, 0, Math.PI*2); ctx.fill();
      }
    } else if(p.weaponType === 'boomerang') {
      // Spinning pink disc
      ctx.fillStyle = '#ff0080';
      ctx.shadowColor = '#ff0080'; ctx.shadowBlur = 10;
      ctx.rotate(p.angle || 0);
      ctx.beginPath();
      ctx.arc(0, 0, 5+p.level, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#0a0a1a';
      ctx.beginPath();
      ctx.arc(0, 0, 2+p.level*0.3, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  },
  drawGem(ctx, g, time) {
    const pulse = 1 + 0.15*Math.sin(time*5 + g.x);
    ctx.save();
    ctx.translate(g.x, g.y);
    ctx.scale(pulse, pulse);
    // Hexagonal data fragments
    ctx.fillStyle = g.value > 5 ? '#00ffff' : g.value > 2 ? '#ff0080' : '#39ff14';
    ctx.shadowColor = ctx.fillStyle; ctx.shadowBlur = 8;
    ctx.beginPath();
    for(let i=0;i<6;i++) {
      const a = Math.PI/3 * i - Math.PI/6;
      const px = Math.cos(a) * 5;
      const py = Math.sin(a) * 5;
      if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
    }
    ctx.closePath(); ctx.fill();
    ctx.restore();
  }
};

// ============================================================
// AUDIO ENGINE (Web Audio API - all synthesized)
// ============================================================
const Audio = (() => {
  let actx = null;
  let masterGain = null;
  let ambientOsc = null;
  let ambientFilter = null;
  let muted = false;

  function init() {
    if(actx) return;
    actx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = actx.createGain();
    masterGain.gain.value = 0.4;
    masterGain.connect(actx.destination);
    startAmbient();
  }

  function startAmbient() {
    ambientOsc = actx.createOscillator();
    ambientFilter = actx.createBiquadFilter();
    const ambGain = actx.createGain();
    ambientOsc.type = 'sawtooth';
    ambientOsc.frequency.value = 55;
    ambientFilter.type = 'lowpass';
    ambientFilter.frequency.value = 200;
    ambientFilter.Q.value = 2;
    ambGain.gain.value = 0.06;
    ambientOsc.connect(ambientFilter);
    ambientFilter.connect(ambGain);
    ambGain.connect(masterGain);
    ambientOsc.start();
  }

  function updateAmbient(progress) {
    if(!ambientFilter) return;
    ambientFilter.frequency.value = 200 + progress * 600;
  }

  function note(freq, dur, type='sine', vol=0.15, detune=0) {
    if(!actx) return;
    const t = actx.currentTime;
    const o = actx.createOscillator();
    const g = actx.createGain();
    o.type = type;
    o.frequency.value = freq;
    o.detune.value = detune;
    g.gain.setValueAtTime(vol, t);
    g.gain.exponentialRampToValueAtTime(0.001, t+dur);
    o.connect(g); g.connect(masterGain);
    o.start(t); o.stop(t+dur);
  }

  function noise(dur, vol=0.1) {
    if(!actx) return;
    const t = actx.currentTime;
    const buf = actx.createBuffer(1, actx.sampleRate*dur, actx.sampleRate);
    const data = buf.getChannelData(0);
    for(let i=0;i<data.length;i++) data[i] = Math.random()*2-1;
    const src = actx.createBufferSource();
    const g = actx.createGain();
    const f = actx.createBiquadFilter();
    src.buffer = buf;
    f.type = 'highpass'; f.frequency.value = 2000;
    g.gain.setValueAtTime(vol, t);
    g.gain.exponentialRampToValueAtTime(0.001, t+dur);
    src.connect(f); f.connect(g); g.connect(masterGain);
    src.start(t); src.stop(t+dur);
  }

  function weaponSound(type, level) {
    const l = level || 1;
    if(type==='projectile') {
      note(800+l*100, 0.1, 'sine', 0.08);
      note(1200+l*150, 0.06, 'sine', 0.05);
    } else if(type==='orbit') {
      note(400+l*50, 0.15, 'triangle', 0.04);
    } else if(type==='area') {
      note(200, 0.3, 'sine', 0.1);
      note(400, 0.2, 'sine', 0.06);
      noise(0.15, 0.06);
    } else if(type==='chain') {
      note(600, 0.05, 'sawtooth', 0.07);
      note(900, 0.04, 'sawtooth', 0.05);
      note(1200, 0.03, 'sawtooth', 0.04);
    } else if(type==='beam') {
      note(300+l*30, 0.4, 'sawtooth', 0.05);
    } else if(type==='rain') {
      note(150, 0.15, 'sine', 0.06);
      noise(0.1, 0.08);
    } else if(type==='boomerang') {
      note(500, 0.08, 'triangle', 0.06);
      note(700, 0.06, 'triangle', 0.04);
    } else if(type==='field') {
      note(150, 0.5, 'sine', 0.04);
      note(225, 0.4, 'sine', 0.03);
    }
  }

  function hitSound() { noise(0.06, 0.12); note(200, 0.05, 'square', 0.06); }
  function deathSound() { note(300, 0.15, 'sawtooth', 0.08); note(150, 0.25, 'sawtooth', 0.06); noise(0.1, 0.07); }

  let gemChain = 0; let gemChainTimer = 0;
  function gemSound() {
    gemChain++;
    const freq = 600 + Math.min(gemChain, 20) * 40;
    note(freq, 0.12, 'sine', 0.07);
    note(freq*1.5, 0.08, 'sine', 0.04);
    clearTimeout(gemChainTimer);
    gemChainTimer = setTimeout(() => { gemChain = 0; }, 400);
  }

  function levelUpSound() {
    const t = actx ? actx.currentTime : 0;
    [523, 659, 784, 1047].forEach((f, i) => {
      setTimeout(() => note(f, 0.3, 'sine', 0.1), i*80);
    });
  }

  function bossWarning() {
    for(let i=0;i<4;i++) {
      setTimeout(() => {
        note(80, 0.3, 'sawtooth', 0.12);
        noise(0.1, 0.1);
      }, i*300);
    }
    note(60, 1.5, 'sawtooth', 0.08);
  }

  function heartbeat() {
    note(60, 0.1, 'sine', 0.15);
    setTimeout(() => note(55, 0.12, 'sine', 0.12), 120);
  }

  function damageTaken() {
    noise(0.08, 0.15);
    note(120, 0.1, 'square', 0.08);
  }

  function toggleMute() {
    muted = !muted;
    if(masterGain) masterGain.gain.value = muted ? 0 : 0.4;
    return muted;
  }

  return { init, note, noise, weaponSound, hitSound, deathSound, gemSound, levelUpSound, bossWarning, heartbeat, damageTaken, updateAmbient, toggleMute };
})();

// ============================================================
// SPATIAL HASH GRID
// ============================================================
class SpatialHash {
  constructor(cellSize) {
    this.cellSize = cellSize;
    this.cells = new Map();
  }
  clear() { this.cells.clear(); }
  _key(x, y) {
    return ((x/this.cellSize|0) * 73856093) ^ ((y/this.cellSize|0) * 19349663);
  }
  insert(obj) {
    const k = this._key(obj.x, obj.y);
    let cell = this.cells.get(k);
    if(!cell) { cell = []; this.cells.set(k, cell); }
    cell.push(obj);
  }
  query(x, y, radius) {
    const results = [];
    const cs = this.cellSize;
    const x0 = ((x-radius)/cs|0) - 1;
    const x1 = ((x+radius)/cs|0) + 1;
    const y0 = ((y-radius)/cs|0) - 1;
    const y1 = ((y+radius)/cs|0) + 1;
    for(let cx = x0; cx <= x1; cx++) {
      for(let cy = y0; cy <= y1; cy++) {
        const k = (cx * 73856093) ^ (cy * 19349663);
        const cell = this.cells.get(k);
        if(cell) {
          for(const obj of cell) {
            const dx = obj.x - x;
            const dy = obj.y - y;
            if(dx*dx + dy*dy <= radius*radius) results.push(obj);
          }
        }
      }
    }
    return results;
  }
}

// ============================================================
// OBJECT POOLS
// ============================================================
class Pool {
  constructor(factory, reset) {
    this.pool = [];
    this.active = [];
    this.factory = factory;
    this.reset = reset;
  }
  get(...args) {
    let obj = this.pool.pop() || this.factory();
    this.reset(obj, ...args);
    this.active.push(obj);
    return obj;
  }
  release(obj) {
    const idx = this.active.indexOf(obj);
    if(idx !== -1) this.active.splice(idx, 1);
    this.pool.push(obj);
  }
  releaseAll() {
    this.pool.push(...this.active);
    this.active.length = 0;
  }
  forEach(fn) {
    for(let i = this.active.length-1; i >= 0; i--) fn(this.active[i], i);
  }
  get count() { return this.active.length; }
}

// ============================================================
// GAME STATE
// ============================================================
const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');
let W, H;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

const keys = {};
let levelUpCards = [];
let levelUpSelection = -1;

function selectLevelUpCard(idx) {
  if(state !== 'levelup' || levelUpCards.length === 0) return;
  levelUpSelection = Math.max(0, Math.min(idx, levelUpCards.length - 1));
  levelUpCards.forEach((c, i) => c.classList.toggle('selected', i === levelUpSelection));
}

function confirmLevelUpSelection() {
  if(state !== 'levelup' || levelUpSelection < 0 || levelUpSelection >= levelUpCards.length) return;
  levelUpCards[levelUpSelection].click();
}

window.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  if(e.key === 'Escape') togglePause();
  if(e.key.toLowerCase() === 'm') Audio.toggleMute();
  if(state === 'levelup') {
    if(e.key === '1') { selectLevelUpCard(0); confirmLevelUpSelection(); }
    else if(e.key === '2') { selectLevelUpCard(1); confirmLevelUpSelection(); }
    else if(e.key === '3') { selectLevelUpCard(2); confirmLevelUpSelection(); }
    else if(e.key === 'ArrowLeft') selectLevelUpCard(levelUpSelection <= 0 ? 0 : levelUpSelection - 1);
    else if(e.key === 'ArrowRight') selectLevelUpCard(levelUpSelection < 0 ? 0 : levelUpSelection + 1);
    else if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); confirmLevelUpSelection(); }
  }
});
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

// Touch controls
let touchDir = { x: 0, y: 0 };
let touchActive = false;
let touchStart = { x: 0, y: 0 };
const touchZone = document.getElementById('touch-zone');

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  Audio.init();
  const t = e.touches[0];
  touchStart.x = t.clientX;
  touchStart.y = t.clientY;
  touchActive = true;
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  if(!touchActive) return;
  const t = e.touches[0];
  const dx = t.clientX - touchStart.x;
  const dy = t.clientY - touchStart.y;
  const len = Math.sqrt(dx*dx + dy*dy);
  if(len > 10) {
    touchDir.x = dx/len;
    touchDir.y = dy/len;
  }
}, { passive: false });

canvas.addEventListener('touchend', e => {
  e.preventDefault();
  touchActive = false;
  touchDir.x = 0;
  touchDir.y = 0;
}, { passive: false });

// Game state
let state = 'title'; // title, playing, levelup, paused, gameover
let gameTime = 0;
let kills = 0;
let playerLevel = 1;
let xp = 0;
let xpToNext = 5;
let waveNum = 1;
let waveTimer = 0;
let bossIdx = 0;
let lastBossTime = -999;
let heartbeatTimer = 0;
let damageFlash = 0;
let screenShake = 0;

const player = {
  x: 0, y: 0,
  speed: 150,
  maxHp: 100,
  hp: 100,
  damage: 1,
  attackSpeed: 1,
  pickupRadius: 60,
  defense: 1, // multiplier for damage taken
  invulnTime: 0,
  weapons: [],
  passives: []
};

const cam = { x: 0, y: 0 };

// Pools
const enemyHash = new SpatialHash(100);

const enemies = new Pool(
  () => ({ x:0, y:0, hp:0, maxHp:0, size:0, speed:0, type:null, xpValue:0, isBoss:false, spawnTime:0, hitFlash:0 }),
  (e, x, y, type, isBoss) => {
    e.x = x; e.y = y;
    e.type = type;
    e.isBoss = isBoss || false;
    const hpMult = 1 + gameTime / 120;
    e.hp = e.maxHp = (isBoss ? type.hp : type.hp * hpMult);
    e.size = type.size;
    e.speed = type.speed;
    e.xpValue = type.xp;
    e.spawnTime = gameTime;
    e.hitFlash = 0;
  }
);

const projectiles = new Pool(
  () => ({ x:0, y:0, vx:0, vy:0, damage:0, pierce:0, life:0, maxLife:0, weaponType:'', level:1, angle:0, target:null, origin:null, bounces:0 }),
  (p, x, y, vx, vy, dmg, life, type, level) => {
    p.x = x; p.y = y; p.vx = vx; p.vy = vy;
    p.damage = dmg; p.life = life; p.maxLife = life;
    p.pierce = level;
    p.weaponType = type;
    p.level = level;
    p.angle = 0;
    p.target = null;
    p.origin = { x, y };
    p.bounces = 0;
  }
);

const gems = new Pool(
  () => ({ x:0, y:0, value:0, life:0, vx:0, vy:0 }),
  (g, x, y, val) => {
    g.x = x; g.y = y; g.value = val;
    g.life = 30;
    g.vx = (Math.random()-0.5)*60;
    g.vy = (Math.random()-0.5)*60;
  }
);

const particles = new Pool(
  () => ({ x:0, y:0, vx:0, vy:0, life:0, maxLife:0, color:'', size:0 }),
  (p, x, y, vx, vy, life, color, size) => {
    p.x = x; p.y = y; p.vx = vx; p.vy = vy;
    p.life = life; p.maxLife = life;
    p.color = color; p.size = size || 3;
  }
);

// Active fields/beams/areas
const activeEffects = [];

// Weapon state
const weaponTimers = {};

// ============================================================
// WEAPON SYSTEM
// ============================================================
function getWeaponStats(type, level) {
  const l = level;
  switch(type) {
    case 'projectile': return { cooldown: 0.8/player.attackSpeed, damage: 8*l*player.damage, speed: 350, life: 1.5, count: Math.min(1+Math.floor(l/2), 4) };
    case 'orbit': return { cooldown: 0, damage: 5*l*player.damage, radius: 60+l*15, count: 2+l, speed: 2+l*0.3 };
    case 'area': return { cooldown: 3/player.attackSpeed, damage: 12*l*player.damage, radius: 80+l*20, life: 0.3 };
    case 'chain': return { cooldown: 1.2/player.attackSpeed, damage: 6*l*player.damage, bounces: 2+l, range: 150+l*20 };
    case 'beam': return { cooldown: 4/player.attackSpeed, damage: 3*l*player.damage, duration: 0.8+l*0.2, width: 6+l*2, range: 200+l*40 };
    case 'rain': return { cooldown: 2.5/player.attackSpeed, damage: 10*l*player.damage, count: 3+l, radius: 100+l*20 };
    case 'boomerang': return { cooldown: 1.5/player.attackSpeed, damage: 7*l*player.damage, speed: 250, range: 180+l*30 };
    case 'field': return { cooldown: 5/player.attackSpeed, damage: 4*l*player.damage, radius: 70+l*15, duration: 3+l*0.5 };
    default: return {};
  }
}

function fireWeapon(w) {
  const stats = getWeaponStats(w.type, w.level);
  Audio.weaponSound(w.type, w.level);

  if(w.type === 'projectile') {
    // Find nearest enemy for targeting
    const nearby = enemyHash.query(player.x, player.y, 500);
    let target = nearby[0];
    let minDist = Infinity;
    for(const e of nearby) {
      const d = Math.hypot(e.x-player.x, e.y-player.y);
      if(d < minDist) { minDist = d; target = e; }
    }
    for(let i = 0; i < stats.count; i++) {
      let angle;
      if(target) {
        angle = Math.atan2(target.y-player.y, target.x-player.x) + (i-stats.count/2+0.5)*0.2;
      } else {
        angle = Math.PI*2*i/stats.count;
      }
      projectiles.get(
        player.x, player.y,
        Math.cos(angle)*stats.speed, Math.sin(angle)*stats.speed,
        stats.damage, stats.life, 'projectile', w.level
      );
    }
  } else if(w.type === 'area') {
    activeEffects.push({
      type: 'area', x: player.x, y: player.y,
      radius: 0, maxRadius: stats.radius,
      damage: stats.damage, life: stats.life, maxLife: stats.life,
      hit: new Set()
    });
  } else if(w.type === 'chain') {
    const nearby = enemyHash.query(player.x, player.y, 400);
    if(nearby.length > 0) {
      let minD = Infinity, first = nearby[0];
      for(const e of nearby) {
        const d = Math.hypot(e.x-player.x, e.y-player.y);
        if(d<minD) {minD=d; first=e;}
      }
      chainHit(first, stats.damage, stats.bounces, stats.range, new Set());
    }
  } else if(w.type === 'beam') {
    const nearby = enemyHash.query(player.x, player.y, stats.range+200);
    let target = null, minD = Infinity;
    for(const e of nearby) {
      const d = Math.hypot(e.x-player.x, e.y-player.y);
      if(d<minD) { minD=d; target=e; }
    }
    if(target) {
      const angle = Math.atan2(target.y-player.y, target.x-player.x);
      activeEffects.push({
        type:'beam', x:player.x, y:player.y, angle,
        range: stats.range, width: stats.width,
        damage: stats.damage, life: stats.duration, maxLife: stats.duration,
        tickTimer: 0
      });
    }
  } else if(w.type === 'rain') {
    for(let i=0;i<stats.count;i++) {
      const rx = player.x + (Math.random()-0.5)*stats.radius*2;
      const ry = player.y + (Math.random()-0.5)*stats.radius*2;
      setTimeout(() => {
        if(state !== 'playing') return;
        projectiles.get(rx, ry-300, 0, 500, stats.damage, 0.7, 'rain', w.level);
        spawnParticles(rx, ry, 5, '#39ff14', 2);
      }, i * 150);
    }
  } else if(w.type === 'boomerang') {
    const nearby = enemyHash.query(player.x, player.y, 500);
    let target = null, minD = Infinity;
    for(const e of nearby) {
      const d = Math.hypot(e.x-player.x, e.y-player.y);
      if(d<minD) { minD=d; target=e; }
    }
    const angle = target ? Math.atan2(target.y-player.y, target.x-player.x) : Math.random()*Math.PI*2;
    const p = projectiles.get(
      player.x, player.y,
      Math.cos(angle)*stats.speed, Math.sin(angle)*stats.speed,
      stats.damage, stats.range/stats.speed*2, 'boomerang', w.level
    );
    p.origin = { x: player.x, y: player.y };
  } else if(w.type === 'field') {
    activeEffects.push({
      type:'field', x: player.x, y: player.y,
      radius: stats.radius, damage: stats.damage,
      life: stats.duration, maxLife: stats.duration,
      tickTimer: 0
    });
  }
}

function chainHit(enemy, damage, bouncesLeft, range, hitSet) {
  if(!enemy || hitSet.has(enemy)) return;
  hitSet.add(enemy);
  damageEnemy(enemy, damage);
  spawnParticles(enemy.x, enemy.y, 3, '#88aaff', 2);

  if(bouncesLeft <= 0) return;
  const nearby = enemyHash.query(enemy.x, enemy.y, range);
  let next = null, minD = Infinity;
  for(const e of nearby) {
    if(hitSet.has(e)) continue;
    const d = Math.hypot(e.x-enemy.x, e.y-enemy.y);
    if(d<minD) { minD=d; next=e; }
  }
  if(next) {
    // Visual chain line
    activeEffects.push({
      type:'chainLine', x1:enemy.x, y1:enemy.y, x2:next.x, y2:next.y,
      life: 0.15, maxLife: 0.15
    });
    setTimeout(() => chainHit(next, damage*0.8, bouncesLeft-1, range, hitSet), 50);
  }
}

// ============================================================
// ENEMY / DAMAGE
// ============================================================
function damageEnemy(e, dmg) {
  e.hp -= dmg;
  e.hitFlash = 0.1;
  Audio.hitSound();
  spawnParticles(e.x, e.y, 2, '#ff4444', 2);
  if(e.hp <= 0) {
    killEnemy(e);
  }
}

function killEnemy(e) {
  Audio.deathSound();
  spawnParticles(e.x, e.y, 8, e.type.color, 3);
  gems.get(e.x, e.y, e.xpValue);
  kills++;
  enemies.release(e);
}

function spawnParticles(x, y, count, color, size) {
  for(let i=0;i<count;i++) {
    const angle = Math.random()*Math.PI*2;
    const speed = 50+Math.random()*100;
    particles.get(x, y, Math.cos(angle)*speed, Math.sin(angle)*speed, 0.4+Math.random()*0.3, color, size);
  }
}

// ============================================================
// SPAWNING
// ============================================================
function spawnEnemy() {
  const available = THEME.enemies.filter(e => gameTime >= e.spawnAfter);
  if(available.length === 0) return;
  const type = available[Math.random()*available.length|0];
  const angle = Math.random() * Math.PI * 2;
  const dist = Math.max(W, H) * 0.6 + Math.random() * 100;
  const x = player.x + Math.cos(angle) * dist;
  const y = player.y + Math.sin(angle) * dist;
  enemies.get(x, y, type, false);
}

function spawnBoss() {
  if(bossIdx >= THEME.bosses.length) return;
  const type = THEME.bosses[bossIdx];
  Audio.bossWarning();
  const angle = Math.random() * Math.PI * 2;
  const dist = Math.max(W, H) * 0.5;
  enemies.get(
    player.x + Math.cos(angle)*dist,
    player.y + Math.sin(angle)*dist,
    type, true
  );
  bossIdx++;
}

// ============================================================
// LEVEL UP
// ============================================================
function addXp(amount) {
  xp += amount;
  while(xp >= xpToNext) {
    xp -= xpToNext;
    playerLevel++;
    xpToNext = Math.floor(5 * Math.pow(1.4, playerLevel-1));
    showLevelUp();
  }
}

function showLevelUp() {
  Audio.levelUpSound();
  state = 'levelup';
  const container = document.getElementById('upgrade-cards');
  container.innerHTML = '';

  const options = generateUpgradeOptions();
  levelUpCards = [];
  levelUpSelection = -1;
  options.forEach((opt, i) => {
    const card = document.createElement('div');
    card.className = 'upgrade-card';
    card.innerHTML = `<div class="upgrade-hotkey">${i+1}</div><div class="upgrade-icon">${opt.icon}</div><div class="upgrade-name">${opt.name}</div><div class="upgrade-desc">${opt.desc}</div>`;
    card.addEventListener('click', () => {
      opt.apply();
      levelUpCards = [];
      levelUpSelection = -1;
      document.getElementById('level-up-screen').style.display = 'none';
      state = 'playing';
    });
    container.appendChild(card);
    levelUpCards.push(card);
  });

  document.getElementById('level-up-screen').style.display = 'flex';
}

function generateUpgradeOptions() {
  const options = [];
  const allWeapons = THEME.weapons;
  const ownedTypes = player.weapons.map(w => w.type);

  // Option: level up existing weapon
  const upgradeable = player.weapons.filter(w => w.level < 5);
  if(upgradeable.length > 0) {
    const w = upgradeable[Math.random()*upgradeable.length|0];
    const def = allWeapons.find(d => d.type === w.type);
    options.push({
      icon: def.icon, name: `${def.name} Lv${w.level+1}`,
      desc: `Upgrade ${def.name}`,
      apply: () => { w.level++; }
    });
  }

  // Option: new weapon
  const unowned = allWeapons.filter(w => !ownedTypes.includes(w.type));
  if(unowned.length > 0 && player.weapons.length < 6) {
    const w = unowned[Math.random()*unowned.length|0];
    options.push({
      icon: w.icon, name: w.name,
      desc: w.desc,
      apply: () => { player.weapons.push({ type: w.type, level: 1 }); updateWeaponBar(); }
    });
  }

  // Option: passive stat
  const passive = THEME.passives[Math.random()*THEME.passives.length|0];
  options.push({
    icon: passive.icon, name: passive.name,
    desc: passive.desc,
    apply: () => {
      if(passive.stat === 'maxHp') { player.maxHp *= passive.mult; player.hp = Math.min(player.hp + 20, player.maxHp); }
      else if(passive.stat === 'speed') player.speed *= passive.mult;
      else if(passive.stat === 'pickupRadius') player.pickupRadius *= passive.mult;
      else if(passive.stat === 'damage') player.damage *= passive.mult;
      else if(passive.stat === 'attackSpeed') player.attackSpeed *= passive.mult;
      else if(passive.stat === 'defense') player.defense *= passive.mult;
      player.passives.push(passive.name);
    }
  });

  // Fill to 3
  while(options.length < 3) {
    const p = THEME.passives[Math.random()*THEME.passives.length|0];
    if(!options.find(o => o.name === p.name)) {
      options.push({
        icon: p.icon, name: p.name, desc: p.desc,
        apply: () => {
          if(p.stat === 'maxHp') { player.maxHp *= p.mult; player.hp = Math.min(player.hp+20, player.maxHp); }
          else if(p.stat === 'speed') player.speed *= p.mult;
          else if(p.stat === 'pickupRadius') player.pickupRadius *= p.mult;
          else if(p.stat === 'damage') player.damage *= p.mult;
          else if(p.stat === 'attackSpeed') player.attackSpeed *= p.mult;
          else if(p.stat === 'defense') player.defense *= p.mult;
          player.passives.push(p.name);
        }
      });
    }
  }

  return options.slice(0, 3);
}

// ============================================================
// HUD
// ============================================================
function updateHUD() {
  const mins = Math.floor(gameTime/60);
  const secs = Math.floor(gameTime%60);
  document.getElementById('hud-level').textContent = `Level ${playerLevel}`;
  document.getElementById('hud-time').textContent = `${mins}:${secs.toString().padStart(2,'0')}`;
  document.getElementById('hud-kills').textContent = `Kills: ${kills}`;
  document.getElementById('hud-wave').textContent = `Wave ${waveNum}`;
  document.getElementById('xp-bar').style.width = `${(xp/xpToNext)*100}%`;
  document.getElementById('hp-bar').style.width = `${(player.hp/player.maxHp)*100}%`;
}

function updateWeaponBar() {
  const bar = document.getElementById('weapon-bar');
  bar.innerHTML = '';
  const allW = THEME.weapons;
  player.weapons.forEach(w => {
    const def = allW.find(d => d.type === w.type);
    const slot = document.createElement('div');
    slot.className = 'weapon-slot active';
    slot.textContent = def ? def.icon : '?';
    slot.title = def ? `${def.name} Lv${w.level}` : '';
    bar.appendChild(slot);
  });
}

// ============================================================
// MAIN GAME LOOP
// ============================================================
let lastTime = 0;
let spawnTimer = 0;
let spawnRate = 1.5; // seconds between spawns

function gameLoop(timestamp) {
  requestAnimationFrame(gameLoop);
  const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
  lastTime = timestamp;

  if(state === 'title' || state === 'gameover') return;
  if(state === 'paused' || state === 'levelup') return;

  gameTime += dt;

  // Difficulty ramp
  const progress = Math.min(gameTime / 600, 1); // 10 min to max
  spawnRate = Math.max(0.15, 1.5 - progress * 1.2);
  waveNum = Math.floor(gameTime / 30) + 1;
  Audio.updateAmbient(progress);

  // Movement
  let mx = 0, my = 0;
  if(keys['w'] || keys['arrowup']) my -= 1;
  if(keys['s'] || keys['arrowdown']) my += 1;
  if(keys['a'] || keys['arrowleft']) mx -= 1;
  if(keys['d'] || keys['arrowright']) mx += 1;
  if(touchActive) { mx = touchDir.x; my = touchDir.y; }
  const mlen = Math.sqrt(mx*mx+my*my);
  if(mlen > 0) {
    mx /= mlen; my /= mlen;
    player.x += mx * player.speed * dt;
    player.y += my * player.speed * dt;
  }

  // Camera
  cam.x = player.x - W/2;
  cam.y = player.y - H/2;

  // Spawn enemies
  spawnTimer -= dt;
  if(spawnTimer <= 0) {
    spawnTimer = spawnRate;
    const count = 1 + Math.floor(progress * 3);
    for(let i=0;i<count;i++) spawnEnemy();
  }

  // Boss spawning
  for(const boss of THEME.bosses) {
    if(gameTime >= boss.spawnAt && lastBossTime < boss.spawnAt) {
      spawnBoss();
    }
  }
  lastBossTime = gameTime;

  // Death reaper at 15 min
  if(gameTime > 900 && enemies.count < 200) {
    for(let i=0;i<5;i++) spawnEnemy();
  }

  // Rebuild spatial hash
  enemyHash.clear();
  enemies.forEach(e => enemyHash.insert(e));

  // Weapon firing
  for(const w of player.weapons) {
    if(w.type === 'orbit') continue; // continuous
    if(!weaponTimers[w.type]) weaponTimers[w.type] = 0;
    weaponTimers[w.type] -= dt;
    if(weaponTimers[w.type] <= 0) {
      const stats = getWeaponStats(w.type, w.level);
      weaponTimers[w.type] = stats.cooldown;
      fireWeapon(w);
    }
  }

  // Orbit weapon (continuous)
  const orbitW = player.weapons.find(w => w.type === 'orbit');
  if(orbitW) {
    const stats = getWeaponStats('orbit', orbitW.level);
    const nearby = enemyHash.query(player.x, player.y, stats.radius + 30);
    for(const e of nearby) {
      const d = Math.hypot(e.x-player.x, e.y-player.y);
      if(d < stats.radius + e.size) {
        damageEnemy(e, stats.damage * dt);
      }
    }
  }

  // Update projectiles
  projectiles.forEach((p, idx) => {
    p.life -= dt;
    if(p.life <= 0) { projectiles.release(p); return; }

    // Boomerang return
    if(p.weaponType === 'boomerang' && p.life < p.maxLife * 0.5) {
      const dx = player.x - p.x;
      const dy = player.y - p.y;
      const d = Math.hypot(dx, dy);
      if(d > 5) {
        p.vx += (dx/d) * 800 * dt;
        p.vy += (dy/d) * 800 * dt;
      }
      if(d < 20) { projectiles.release(p); return; }
    }

    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.angle += 10 * dt;

    // Hit enemies
    const hits = enemyHash.query(p.x, p.y, 20);
    for(const e of hits) {
      const d = Math.hypot(p.x-e.x, p.y-e.y);
      if(d < e.size + 5) {
        damageEnemy(e, p.damage);
        p.pierce--;
        if(p.pierce <= 0) { projectiles.release(p); return; }
      }
    }
  });

  // Update active effects
  for(let i = activeEffects.length-1; i >= 0; i--) {
    const ef = activeEffects[i];
    ef.life -= dt;
    if(ef.life <= 0) { activeEffects.splice(i, 1); continue; }

    if(ef.type === 'area') {
      ef.radius = ef.maxRadius * (1 - ef.life/ef.maxLife);
      const hits = enemyHash.query(ef.x, ef.y, ef.radius);
      for(const e of hits) {
        if(!ef.hit.has(e)) {
          ef.hit.add(e);
          damageEnemy(e, ef.damage);
        }
      }
    } else if(ef.type === 'beam') {
      ef.tickTimer -= dt;
      if(ef.tickTimer <= 0) {
        ef.tickTimer = 0.1;
        // Damage along beam
        const cos = Math.cos(ef.angle);
        const sin = Math.sin(ef.angle);
        for(let d = 0; d < ef.range; d += 20) {
          const bx = ef.x + cos*d;
          const by = ef.y + sin*d;
          const hits = enemyHash.query(bx, by, ef.width+10);
          for(const e of hits) damageEnemy(e, ef.damage);
        }
      }
    } else if(ef.type === 'field') {
      ef.tickTimer -= dt;
      if(ef.tickTimer <= 0) {
        ef.tickTimer = 0.5;
        const hits = enemyHash.query(ef.x, ef.y, ef.radius);
        for(const e of hits) damageEnemy(e, ef.damage);
      }
    }
  }

  // Update enemies
  player.invulnTime -= dt;
  enemies.forEach(e => {
    // Move toward player
    const dx = player.x - e.x;
    const dy = player.y - e.y;
    const d = Math.hypot(dx, dy);
    if(d > 5) {
      e.x += (dx/d) * e.speed * dt;
      e.y += (dy/d) * e.speed * dt;
    }
    // Separation from nearby enemies
    const nearby = enemyHash.query(e.x, e.y, e.size * 2.5);
    for(const other of nearby) {
      if(other === e) continue;
      const sx = e.x - other.x;
      const sy = e.y - other.y;
      const sd = Math.hypot(sx, sy);
      const minDist = (e.size + other.size) * 0.8;
      if(sd < minDist && sd > 0.1) {
        const push = (minDist - sd) / minDist * 120 * dt;
        e.x += (sx/sd) * push;
        e.y += (sy/sd) * push;
      }
    }
    e.hitFlash -= dt;

    // Hit player
    if(d < e.size + 12 && player.invulnTime <= 0) {
      const dmg = (e.isBoss ? 15 : 5 + gameTime*0.02) * player.defense;
      player.hp -= dmg;
      player.invulnTime = 0.5;
      damageFlash = 0.15;
      screenShake = 0.1;
      Audio.damageTaken();
      if(player.hp <= 0) {
        gameOver();
        return;
      }
    }
  });

  // Low health heartbeat
  if(player.hp < player.maxHp * 0.3) {
    heartbeatTimer -= dt;
    if(heartbeatTimer <= 0) {
      heartbeatTimer = 0.8;
      Audio.heartbeat();
    }
  }

  // Update gems
  gems.forEach(g => {
    g.life -= dt;
    if(g.life <= 0) { gems.release(g); return; }
    // Slow down
    g.vx *= 0.95;
    g.vy *= 0.95;
    g.x += g.vx * dt;
    g.y += g.vy * dt;
    // Magnetic pickup
    const dx = player.x - g.x;
    const dy = player.y - g.y;
    const d = Math.hypot(dx, dy);
    if(d < player.pickupRadius) {
      const pull = Math.max(300, 600 * (1 - d/player.pickupRadius));
      g.x += (dx/d) * pull * dt;
      g.y += (dy/d) * pull * dt;
    }
    if(d < 15) {
      addXp(g.value);
      Audio.gemSound();
      gems.release(g);
    }
  });

  // Update particles
  particles.forEach(p => {
    p.life -= dt;
    if(p.life <= 0) { particles.release(p); return; }
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vx *= 0.96;
    p.vy *= 0.96;
  });

  // Render
  render(dt);
  updateHUD();
}

// ============================================================
// RENDERING
// ============================================================
function render(dt) {
  // Clear entire canvas before camera transform
  ctx.fillStyle = THEME.palette.bg;
  ctx.fillRect(0, 0, W, H);

  ctx.save();

  // Screen shake
  let sx = 0, sy = 0;
  if(screenShake > 0) {
    screenShake -= dt;
    sx = (Math.random()-0.5) * 8;
    sy = (Math.random()-0.5) * 8;
  }
  // Background (drawn in screen space before camera transform)
  ctx.save();
  ctx.translate(sx, sy);
  THEME.drawBackground(ctx, cam, W, H, gameTime);
  ctx.restore();

  ctx.translate(sx - cam.x, sy - cam.y);

  // Field effects (below everything)
  for(const ef of activeEffects) {
    if(ef.type === 'field') {
      const alpha = ef.life / ef.maxLife * 0.3;
      ctx.fillStyle = `rgba(0,255,255,${alpha})`;
      ctx.beginPath(); ctx.arc(ef.x, ef.y, ef.radius, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = `rgba(255,0,128,${alpha*2})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }

  // Gems
  gems.forEach(g => THEME.drawGem(ctx, g, gameTime));

  // Enemies
  enemies.forEach(e => {
    ctx.save();
    if(e.hitFlash > 0) {
      ctx.globalAlpha = 0.5 + 0.5*Math.sin(e.hitFlash*30);
    }
    if(e.isBoss) {
      THEME.drawBoss(ctx, e, gameTime);
    } else {
      THEME.drawEnemy(ctx, e, gameTime);
    }
    ctx.restore();
  });

  // Player
  const pr = 16;
  THEME.drawPlayer(ctx, player.x, player.y, pr, gameTime);

  // Orbit visual
  const orbitW = player.weapons.find(w => w.type === 'orbit');
  if(orbitW) {
    const stats = getWeaponStats('orbit', orbitW.level);
    ctx.strokeStyle = `rgba(0,255,255,0.15)`;
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.arc(player.x, player.y, stats.radius, 0, Math.PI*2); ctx.stroke();
    for(let i=0;i<stats.count;i++) {
      const a = gameTime * stats.speed + (Math.PI*2*i/stats.count);
      const ox = player.x + Math.cos(a)*stats.radius;
      const oy = player.y + Math.sin(a)*stats.radius;
      ctx.fillStyle = '#00ffff';
      ctx.shadowColor = '#00ffff'; ctx.shadowBlur = 10;
      ctx.beginPath(); ctx.arc(ox, oy, 5+orbitW.level, 0, Math.PI*2); ctx.fill();
      ctx.shadowBlur = 0;
    }
  }

  // Projectiles
  projectiles.forEach(p => THEME.drawProjectile(ctx, p));

  // Effects
  for(const ef of activeEffects) {
    if(ef.type === 'area') {
      const alpha = ef.life/ef.maxLife * 0.4;
      ctx.strokeStyle = `rgba(0,255,255,${alpha})`;
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.arc(ef.x, ef.y, ef.radius, 0, Math.PI*2); ctx.stroke();
      ctx.fillStyle = `rgba(0,255,255,${alpha*0.3})`;
      ctx.fill();
    } else if(ef.type === 'beam') {
      const alpha = ef.life/ef.maxLife;
      ctx.save();
      ctx.strokeStyle = `rgba(0,255,255,${alpha})`;
      ctx.shadowColor = '#00ffff'; ctx.shadowBlur = 20;
      ctx.lineWidth = ef.width;
      ctx.beginPath();
      ctx.moveTo(ef.x, ef.y);
      ctx.lineTo(ef.x + Math.cos(ef.angle)*ef.range, ef.y + Math.sin(ef.angle)*ef.range);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.restore();
    } else if(ef.type === 'chainLine') {
      const alpha = ef.life/ef.maxLife;
      ctx.strokeStyle = `rgba(136,170,255,${alpha})`;
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(ef.x1, ef.y1); ctx.lineTo(ef.x2, ef.y2); ctx.stroke();
    }
  }

  // Particles
  particles.forEach(p => {
    const alpha = p.life / p.maxLife;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;
    ctx.beginPath(); ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI*2); ctx.fill();
  });
  ctx.globalAlpha = 1;

  ctx.restore();

  // Damage flash overlay
  if(damageFlash > 0) {
    damageFlash -= 1/60;
    ctx.fillStyle = `rgba(255,0,128,${damageFlash * 2})`;
    ctx.fillRect(0, 0, W, H);
  }

  // Invuln indicator
  if(player.invulnTime > 0) {
    ctx.save();
    ctx.translate(W/2, H/2);
    ctx.strokeStyle = `rgba(0,255,255,${0.3*Math.sin(gameTime*20)})`;
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(0, 0, 18, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }
}

// ============================================================
// STATE MANAGEMENT
// ============================================================
function startGame() {
  Audio.init();
  state = 'playing';
  gameTime = 0;
  kills = 0;
  playerLevel = 1;
  xp = 0;
  xpToNext = 5;
  waveNum = 1;
  bossIdx = 0;
  lastBossTime = -999;
  player.x = 0; player.y = 0;
  player.hp = 100; player.maxHp = 100;
  player.speed = 150;
  player.damage = 1;
  player.attackSpeed = 1;
  player.pickupRadius = 60;
  player.defense = 1;
  player.invulnTime = 0;
  player.weapons = [{ type: 'projectile', level: 1 }];
  player.passives = [];
  enemies.releaseAll();
  projectiles.releaseAll();
  gems.releaseAll();
  particles.releaseAll();
  activeEffects.length = 0;
  Object.keys(weaponTimers).forEach(k => weaponTimers[k] = 0);
  damageFlash = 0;
  screenShake = 0;
  spawnTimer = 0;
  updateWeaponBar();
  document.getElementById('title-screen').style.display = 'none';
  document.getElementById('game-over-screen').style.display = 'none';
  lastTime = performance.now();
}

function gameOver() {
  state = 'gameover';
  const mins = Math.floor(gameTime/60);
  const secs = Math.floor(gameTime%60);
  document.getElementById('go-stats').innerHTML = `
    <div class="stats-line">Time Survived: ${mins}:${secs.toString().padStart(2,'0')}</div>
    <div class="stats-line">Level Reached: ${playerLevel}</div>
    <div class="stats-line">Enemies Slain: ${kills}</div>
    <div class="stats-line">Weapons: ${player.weapons.length}</div>
  `;
  document.getElementById('game-over-screen').style.display = 'flex';
}

function togglePause() {
  if(state === 'playing') {
    state = 'paused';
    document.getElementById('pause-screen').style.display = 'flex';
  } else if(state === 'paused') {
    state = 'playing';
    document.getElementById('pause-screen').style.display = 'none';
    lastTime = performance.now();
  }
}

// Button handlers
document.getElementById('btn-start').addEventListener('click', startGame);
document.getElementById('btn-restart').addEventListener('click', startGame);
document.getElementById('btn-resume').addEventListener('click', togglePause);

// Start loop
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
