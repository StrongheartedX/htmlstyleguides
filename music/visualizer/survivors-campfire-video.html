<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Survivors: Campfire Rest — Music Video</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="video-base-styles.css">
    <style>
        :root {
            --vid-bg: #06080e;
            --vid-bg-rgb: 6,8,14;
            --vid-font: 'JetBrains Mono', monospace;
            --vid-accent: #f5a623;
            --vid-accent-r: 245;
            --vid-accent-g: 166;
            --vid-accent-b: 35;
            --vid-overlay-alpha: 0.92;
            --vid-title-min: 18px;
            --vid-title-vw: 4.5vw;
            --vid-title-max: 44px;
            --vid-title-spacing: 0.06em;
            --vid-sub-min: 11px;
            --vid-sub-max: 16px;
        }
    </style>
</head>
<body>
    <a href="music-videos/index.html" class="back-link">&larr; Music Videos</a>
    <canvas id="viz-canvas"></canvas>
    <div class="play-overlay" id="play-overlay">
        <div class="play-title">Survivors: Campfire Rest</div>
        <div class="play-sub">town hub theme</div>
        <div class="play-btn"></div>
    </div>

    <script src="../audio-tracker/playback-engine.js"></script>
    <script src="engine.js"></script>
    <script src="stick-fight-engine.js"></script>
    <script src="video-utils.js"></script>
    <script src="base-renderer.js"></script>
    <script>
    // ── Survivors: Campfire Rest Video Renderer ─────────────────────
    (function() {
        "use strict";

        var W = 0, H = 0;
        var analysis = null;

        // ── Palette ──
        var SKY_TOP = '#030510';
        var SKY_BOTTOM = '#0a0f1e';
        var GROUND_COLOR = '#0c0e08';
        var FIRE_ORANGE = '#f5a623';
        var FIRE_YELLOW = '#ffd566';
        var FIRE_RED = '#e85820';
        var EMBER_COLOR = '#ff6a2a';
        var STAR_COLOR = '#ffffff';
        var SILHOUETTE = '#08090c';

        // ── State ──
        var beatPulse = 0;
        var time = 0;
        var groundY = 0;
        var fireX = 0;
        var fireBaseY = 0;

        // Stars
        var stars = [];
        var NUM_STARS = 180;

        // Embers
        var embers = [];
        var MAX_EMBERS = 40;

        // Shooting stars
        var shootingStars = [];
        var shootingStarTimer = 0;

        // Figures (survivors sitting around fire)
        var figureSeats = []; // StickFight figures
        var figureMeta = []; // {facingRight, headBobPhase, headBobAmount, armRaise}

        // Trees / hills
        var hills = [];
        var trees = [];

        // Section tracking
        var lastSeqIndex = -1;
        var sectionMood = 'intro'; // intro, verse, bridge, transition

        // ── Helpers ──
        function clamp(v, lo, hi) { return v < lo ? lo : v > hi ? hi : v; }

        // ── Init stars ──
        function initStars() {
            stars = [];
            for (var i = 0; i < NUM_STARS; i++) {
                stars.push({
                    x: Math.random() * W,
                    y: Math.random() * groundY * 0.85,
                    size: 0.5 + Math.random() * 2,
                    baseAlpha: 0.2 + Math.random() * 0.6,
                    twinklePhase: Math.random() * Math.PI * 2,
                    twinkleSpeed: 0.5 + Math.random() * 2,
                    beatFlash: 0
                });
            }
        }

        // ── Init figures ──
        function initFigures() {
            figureSeats = [];
            figureMeta = [];
            var fireRadius = W * 0.12;
            var figH = H * 0.06;
            // 4 survivors arranged in a semicircle facing the fire
            var angles = [-0.65, -0.25, 0.25, 0.65];
            for (var i = 0; i < 4; i++) {
                var angle = angles[i];
                var dist = fireRadius * (0.9 + Math.random() * 0.3);
                var fx = fireX + Math.sin(angle * Math.PI) * dist;
                var fy = fireBaseY + Math.abs(Math.cos(angle * Math.PI)) * dist * 0.25 + 5;
                var facingRight = angle < 0;

                var fig = StickFight.create({
                    x: fx, y: fy,
                    figH: figH,
                    facing: facingRight ? 1 : -1,
                    color: SILHOUETTE,
                    lineWidth: 3,
                    poseSpeed: 6
                });
                // Set sitting/kneeling pose
                StickFight.setPose(fig, 'kneel');
                StickFight.setTarget(fig, 'bounce', -0.35);
                StickFight.setTarget(fig, 'lean', 0.15);
                StickFight.setTarget(fig, 'legSpread', 0.3);
                StickFight.setTarget(fig, 'kneeL', 0.5);
                StickFight.setTarget(fig, 'kneeR', 0.4);
                StickFight.setTarget(fig, 'armLAngle', 0.5);
                StickFight.setTarget(fig, 'armRAngle', 0.4);
                StickFight.setTarget(fig, 'elbowLBend', 0.4);
                StickFight.setTarget(fig, 'elbowRBend', 0.5);
                // Copy targets to params so they start in position
                for (var k in fig.targets) {
                    if (fig.targets.hasOwnProperty(k)) fig.params[k] = fig.targets[k];
                }

                figureSeats.push(fig);
                figureMeta.push({
                    facingRight: facingRight,
                    headBobPhase: Math.random() * Math.PI * 2,
                    headBobAmount: 0,
                    armRaise: i === 1 ? 0.3 : 0
                });
            }
        }

        // ── Init hills and trees ──
        function initLandscape() {
            hills = [];
            // Layer of rolling hills behind trees
            var numHills = 5;
            for (var i = 0; i < numHills; i++) {
                hills.push({
                    cx: (i / (numHills - 1)) * W,
                    w: W * (0.25 + Math.random() * 0.2),
                    h: groundY * (0.08 + Math.random() * 0.1)
                });
            }

            trees = [];
            var numTrees = 12;
            for (var j = 0; j < numTrees; j++) {
                var tx = (j / (numTrees - 1)) * W * 1.1 - W * 0.05;
                // Gap in the middle for the campfire scene
                var distFromCenter = Math.abs(tx - fireX) / (W * 0.5);
                if (distFromCenter < 0.3) continue;
                trees.push({
                    x: tx,
                    h: H * (0.1 + Math.random() * 0.15),
                    w: 8 + Math.random() * 12,
                    crownW: 20 + Math.random() * 25,
                    crownH: 30 + Math.random() * 40
                });
            }
        }

        // ── Init embers ──
        function spawnEmber() {
            embers.push({
                x: fireX + (Math.random() - 0.5) * 20,
                y: fireBaseY - 10,
                vx: (Math.random() - 0.5) * 30,
                vy: -(20 + Math.random() * 60),
                life: 1.0,
                decay: 0.2 + Math.random() * 0.4,
                size: 1 + Math.random() * 2.5
            });
        }

        // ── Section mapping ──
        function mapSection(seqIndex) {
            // Song has 15 sequence entries (0-14)
            // Pattern names: Intro, Verse A, Verse B, Verse A, Bridge Night Sky,
            //   Verse A', Verse C, Verse B, Bridge Night Sky, Bridge B Settling,
            //   Transition Crackle, Verse A', Verse C, Bridge B Settling, Transition Crackle
            if (seqIndex <= 0) return 'intro';
            if (seqIndex <= 3) return 'verse';
            if (seqIndex === 4) return 'bridge';
            if (seqIndex <= 7) return 'verse';
            if (seqIndex <= 9) return 'bridge';
            if (seqIndex === 10) return 'transition';
            if (seqIndex <= 12) return 'verse';
            if (seqIndex <= 13) return 'bridge';
            return 'transition';
        }

        // ── Draw sky gradient ──
        function drawSky(ctx) {
            var grad = ctx.createLinearGradient(0, 0, 0, groundY);
            grad.addColorStop(0, SKY_TOP);
            grad.addColorStop(1, SKY_BOTTOM);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, W, groundY);
        }

        // ── Draw stars ──
        function drawStars(ctx, dt, energy) {
            for (var i = 0; i < stars.length; i++) {
                var s = stars[i];
                s.twinklePhase += s.twinkleSpeed * dt;
                s.beatFlash *= Math.exp(-4 * dt);

                var twinkle = 0.5 + 0.5 * Math.sin(s.twinklePhase);
                var alpha = s.baseAlpha * twinkle + s.beatFlash;
                alpha = clamp(alpha, 0, 1);

                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = STAR_COLOR;
                ctx.shadowColor = STAR_COLOR;
                ctx.shadowBlur = s.size * 3;

                ctx.beginPath();
                ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                ctx.fill();

                // Cross sparkle on brighter stars
                if (s.size > 1.2 && alpha > 0.5) {
                    ctx.strokeStyle = STAR_COLOR;
                    ctx.lineWidth = 0.5;
                    ctx.globalAlpha = alpha * 0.4;
                    var len = s.size * 3;
                    ctx.beginPath();
                    ctx.moveTo(s.x - len, s.y);
                    ctx.lineTo(s.x + len, s.y);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(s.x, s.y - len);
                    ctx.lineTo(s.x, s.y + len);
                    ctx.stroke();
                }

                ctx.restore();
            }
        }

        // ── Beat-triggered star twinkle ──
        function flashRandomStars(count) {
            for (var i = 0; i < count; i++) {
                var idx = Math.floor(Math.random() * stars.length);
                stars[idx].beatFlash = 0.5 + Math.random() * 0.5;
            }
        }

        // ── Draw shooting star ──
        function updateAndDrawShootingStars(ctx, dt) {
            for (var i = shootingStars.length - 1; i >= 0; i--) {
                var ss = shootingStars[i];
                ss.x += ss.vx * dt;
                ss.y += ss.vy * dt;
                ss.life -= dt * 0.8;

                if (ss.life <= 0) {
                    shootingStars.splice(i, 1);
                    continue;
                }

                var alpha = ss.life;
                var tailLen = 60 * alpha;

                ctx.save();
                ctx.globalAlpha = alpha;
                var grad = ctx.createLinearGradient(
                    ss.x, ss.y,
                    ss.x - (ss.vx / Math.abs(ss.vx)) * tailLen, ss.y - (ss.vy / Math.abs(ss.vy)) * tailLen
                );
                grad.addColorStop(0, 'rgba(255,255,255,0.9)');
                grad.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.strokeStyle = grad;
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(ss.x, ss.y);
                ctx.lineTo(ss.x - (ss.vx * 0.06), ss.y - (ss.vy * 0.06));
                ctx.stroke();

                // Head glow
                ctx.fillStyle = '#fff';
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(ss.x, ss.y, 1.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        function spawnShootingStar() {
            var startX = Math.random() * W * 0.6 + W * 0.2;
            var startY = Math.random() * groundY * 0.3;
            var angle = Math.PI * 0.15 + Math.random() * 0.3;
            var speed = 200 + Math.random() * 200;
            shootingStars.push({
                x: startX,
                y: startY,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 1.0
            });
        }

        // ── Draw hills silhouette ──
        function drawHills(ctx) {
            ctx.save();
            ctx.fillStyle = '#0a0d14';
            for (var i = 0; i < hills.length; i++) {
                var h = hills[i];
                ctx.beginPath();
                ctx.ellipse(h.cx, groundY, h.w, h.h, 0, Math.PI, 0);
                ctx.fill();
            }
            ctx.restore();
        }

        // ── Draw tree silhouettes ──
        function drawTrees(ctx) {
            ctx.save();
            ctx.fillStyle = SILHOUETTE;
            for (var i = 0; i < trees.length; i++) {
                var t = trees[i];
                var baseY = groundY;
                // Trunk
                ctx.fillRect(t.x - t.w / 2, baseY - t.h, t.w, t.h);
                // Crown (triangular pine shape)
                ctx.beginPath();
                ctx.moveTo(t.x, baseY - t.h - t.crownH);
                ctx.lineTo(t.x - t.crownW, baseY - t.h + 10);
                ctx.lineTo(t.x + t.crownW, baseY - t.h + 10);
                ctx.closePath();
                ctx.fill();
                // Second crown layer
                ctx.beginPath();
                ctx.moveTo(t.x, baseY - t.h - t.crownH * 0.6);
                ctx.lineTo(t.x - t.crownW * 1.2, baseY - t.h + t.crownH * 0.3);
                ctx.lineTo(t.x + t.crownW * 1.2, baseY - t.h + t.crownH * 0.3);
                ctx.closePath();
                ctx.fill();
            }
            ctx.restore();
        }

        // ── Draw ground ──
        function drawGround(ctx, energy) {
            ctx.save();
            ctx.fillStyle = GROUND_COLOR;
            ctx.fillRect(0, groundY, W, H - groundY);

            // Subtle fire reflection on ground
            var glowRadius = W * 0.2 * (0.8 + energy * 0.4 + beatPulse * 0.2);
            var grad = ctx.createRadialGradient(
                fireX, groundY, 0,
                fireX, groundY, glowRadius
            );
            grad.addColorStop(0, rgba(FIRE_ORANGE, 0.08 + energy * 0.04));
            grad.addColorStop(0.5, rgba(FIRE_RED, 0.03));
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, groundY, W, H - groundY);
            ctx.restore();
        }

        // ── Draw campfire ──
        function drawCampfire(ctx, energy) {
            var baseW = W * 0.04;
            var flameH = H * 0.08 * (0.7 + energy * 0.5 + beatPulse * 0.3);

            // Log base
            ctx.save();
            ctx.fillStyle = '#2a1a0a';
            ctx.strokeStyle = '#1a0f05';
            ctx.lineWidth = 2;
            // Two crossing logs
            ctx.beginPath();
            ctx.moveTo(fireX - baseW * 1.5, fireBaseY);
            ctx.lineTo(fireX + baseW * 0.5, fireBaseY - 6);
            ctx.lineTo(fireX + baseW * 0.7, fireBaseY - 2);
            ctx.lineTo(fireX - baseW * 1.3, fireBaseY + 4);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(fireX + baseW * 1.5, fireBaseY);
            ctx.lineTo(fireX - baseW * 0.5, fireBaseY - 6);
            ctx.lineTo(fireX - baseW * 0.7, fireBaseY - 2);
            ctx.lineTo(fireX + baseW * 1.3, fireBaseY + 4);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Fire glow (radial)
            var glowR = flameH * 3;
            var grad = ctx.createRadialGradient(
                fireX, fireBaseY - flameH * 0.4, 0,
                fireX, fireBaseY - flameH * 0.4, glowR
            );
            grad.addColorStop(0, rgba(FIRE_YELLOW, 0.12 + beatPulse * 0.06));
            grad.addColorStop(0.3, rgba(FIRE_ORANGE, 0.06 + beatPulse * 0.03));
            grad.addColorStop(0.6, rgba(FIRE_RED, 0.02));
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.globalCompositeOperation = 'lighter';
            ctx.fillStyle = grad;
            ctx.fillRect(fireX - glowR, fireBaseY - flameH - glowR, glowR * 2, glowR * 2);
            ctx.globalCompositeOperation = 'source-over';

            // Flames (multiple triangular flickering shapes)
            var numFlames = 5;
            for (var i = 0; i < numFlames; i++) {
                var t = i / (numFlames - 1);
                var fx = fireX + (t - 0.5) * baseW * 1.8;
                var fh = flameH * (0.5 + 0.5 * Math.sin(time * 6 + i * 1.3)) * (0.6 + t * 0.4 * (1 - t) * 4);
                var fw = baseW * (0.3 + 0.15 * Math.sin(time * 8 + i * 2));
                var wobble = Math.sin(time * 5 + i * 1.7) * fw * 0.4;

                // Outer flame (orange/red)
                ctx.save();
                ctx.globalAlpha = 0.7 + beatPulse * 0.2;
                var flameGrad = ctx.createLinearGradient(fx, fireBaseY, fx, fireBaseY - fh);
                flameGrad.addColorStop(0, FIRE_RED);
                flameGrad.addColorStop(0.4, FIRE_ORANGE);
                flameGrad.addColorStop(0.8, FIRE_YELLOW);
                flameGrad.addColorStop(1, rgba(FIRE_YELLOW, 0.2));
                ctx.fillStyle = flameGrad;

                ctx.beginPath();
                ctx.moveTo(fx - fw, fireBaseY);
                ctx.quadraticCurveTo(fx - fw * 0.3 + wobble * 0.5, fireBaseY - fh * 0.5, fx + wobble, fireBaseY - fh);
                ctx.quadraticCurveTo(fx + fw * 0.3 + wobble * 0.5, fireBaseY - fh * 0.5, fx + fw, fireBaseY);
                ctx.closePath();
                ctx.fill();

                // Inner flame (bright yellow/white core)
                if (i % 2 === 0) {
                    ctx.globalAlpha = 0.5 + beatPulse * 0.3;
                    ctx.fillStyle = FIRE_YELLOW;
                    ctx.beginPath();
                    ctx.moveTo(fx - fw * 0.4, fireBaseY);
                    ctx.quadraticCurveTo(fx + wobble * 0.3, fireBaseY - fh * 0.4, fx + wobble * 0.5, fireBaseY - fh * 0.6);
                    ctx.quadraticCurveTo(fx + wobble * 0.3, fireBaseY - fh * 0.4, fx + fw * 0.4, fireBaseY);
                    ctx.closePath();
                    ctx.fill();
                }

                ctx.restore();
            }

            // Bright core glow
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            var coreGrad = ctx.createRadialGradient(
                fireX, fireBaseY - flameH * 0.2, 0,
                fireX, fireBaseY - flameH * 0.2, baseW
            );
            coreGrad.addColorStop(0, rgba('#ffffff', 0.15 + beatPulse * 0.1));
            coreGrad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = coreGrad;
            ctx.fillRect(fireX - baseW, fireBaseY - flameH, baseW * 2, flameH);
            ctx.restore();

            ctx.restore();
        }

        // ── Draw embers ──
        function updateAndDrawEmbers(ctx, dt, energy) {
            // Spawn embers
            if (Math.random() < (0.3 + energy * 0.5) * dt * 60) {
                spawnEmber();
            }
            // Extra embers on beat
            if (beatPulse > 0.5) {
                for (var s = 0; s < 2; s++) spawnEmber();
            }

            // Cap
            while (embers.length > MAX_EMBERS) embers.shift();

            for (var i = embers.length - 1; i >= 0; i--) {
                var e = embers[i];
                e.x += e.vx * dt;
                e.y += e.vy * dt;
                e.vy -= 5 * dt; // float upward more
                e.vx += (Math.random() - 0.5) * 40 * dt; // wander
                e.life -= e.decay * dt;

                if (e.life <= 0) {
                    embers.splice(i, 1);
                    continue;
                }

                ctx.save();
                ctx.globalAlpha = e.life * 0.8;
                ctx.fillStyle = e.life > 0.5 ? FIRE_YELLOW : EMBER_COLOR;
                ctx.shadowColor = EMBER_COLOR;
                ctx.shadowBlur = 4;
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.size * e.life, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // ── Draw sitting survivor (StickFight + firelight rim) ──
        function drawSurvivor(ctx, fig, meta, energy) {
            // Draw the stick figure
            StickFight.drawFigure(ctx, fig);

            // Firelight rim on the fire-facing side
            var joints = StickFight.computeJoints(fig);
            var distToFire = Math.abs(fig.x - fireX);
            var rimAlpha = clamp(0.15 - distToFire / (W * 0.5) * 0.1 + beatPulse * 0.05, 0, 0.3);
            if (rimAlpha < 0.01) return;

            ctx.save();
            ctx.translate(fig.x, fig.y);
            ctx.globalAlpha = rimAlpha;
            ctx.strokeStyle = FIRE_ORANGE;
            ctx.lineWidth = 2;
            ctx.shadowColor = FIRE_ORANGE;
            ctx.shadowBlur = 6;

            var rimSide = meta.facingRight ? 1 : -1;

            // Rim on head
            ctx.beginPath();
            ctx.arc(joints.head.x, joints.head.y, joints.headR + 1,
                -Math.PI * 0.5 + (rimSide > 0 ? 0 : -Math.PI * 0.3),
                Math.PI * 0.5 + (rimSide > 0 ? 0 : -Math.PI * 0.3));
            ctx.stroke();

            // Rim on shoulder
            ctx.beginPath();
            ctx.moveTo(joints.neck.x, joints.neck.y);
            ctx.lineTo(joints.neck.x + rimSide * 2, joints.neck.y - 5);
            ctx.stroke();

            ctx.restore();
        }

        // ── Draw firelight ambient glow ──
        function drawFirelightGlow(ctx, energy) {
            var radius = W * 0.35 * (0.8 + energy * 0.3 + beatPulse * 0.15);
            var grad = ctx.createRadialGradient(
                fireX, fireBaseY - H * 0.04, 0,
                fireX, fireBaseY - H * 0.04, radius
            );
            grad.addColorStop(0, rgba(FIRE_ORANGE, 0.04 + energy * 0.02 + beatPulse * 0.02));
            grad.addColorStop(0.4, rgba(FIRE_RED, 0.015));
            grad.addColorStop(1, 'rgba(0,0,0,0)');

            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, W, H);
            ctx.restore();
        }

        // ── Draw long shadows from figures ──
        function drawShadows(ctx, energy) {
            ctx.save();
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            for (var i = 0; i < figureSeats.length; i++) {
                var fx = figureSeats[i].x;
                var fy = figureSeats[i].y;
                var dx = fx - fireX;
                var shadowLen = (W * 0.15 + energy * W * 0.05) * (dx > 0 ? 1 : -1);
                var shadowDir = dx / Math.abs(dx || 1);

                ctx.beginPath();
                ctx.moveTo(fx - 5, fy + 5);
                ctx.lineTo(fx + 5, fy + 5);
                ctx.lineTo(fx + shadowLen, fy + 15);
                ctx.lineTo(fx + shadowLen - 10 * shadowDir, fy + 15);
                ctx.closePath();
                ctx.fill();
            }
            ctx.restore();
        }

        // ── Draw title ──
        var titleAlpha = 0;
        var titleTarget = 0;

        function drawTitle(ctx) {
            if (titleAlpha < 0.01) return;

            var fontSize = Math.max(14, Math.min(W * 0.028, 36));
            ctx.save();
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = '700 ' + fontSize + 'px "JetBrains Mono", monospace';
            ctx.globalAlpha = titleAlpha * 0.7;
            ctx.fillStyle = FIRE_ORANGE;
            ctx.shadowColor = FIRE_ORANGE;
            ctx.shadowBlur = 20;
            ctx.fillText('SURVIVORS: CAMPFIRE REST', W / 2, H * 0.08);

            ctx.font = '400 ' + (fontSize * 0.55) + 'px "JetBrains Mono", monospace';
            ctx.globalAlpha = titleAlpha * 0.4;
            ctx.shadowBlur = 10;
            ctx.fillText('town hub theme', W / 2, H * 0.08 + fontSize * 1.2);
            ctx.restore();
        }

        // ── Init ──
        function init(ctx, width, height, anal) {
            W = width; H = height;
            analysis = anal;
            groundY = H * 0.72;
            fireX = W * 0.5;
            fireBaseY = groundY;
            time = 0;
            beatPulse = 0;
            lastSeqIndex = -1;
            sectionMood = 'intro';
            titleAlpha = 0;
            titleTarget = 0;
            shootingStarTimer = 0;
            embers = [];
            shootingStars = [];

            initStars();
            initFigures();
            initLandscape();
        }

        // ── Resize ──
        function resize(width, height) {
            W = width; H = height;
            groundY = H * 0.72;
            fireX = W * 0.5;
            fireBaseY = groundY;
            initStars();
            initFigures();
            initLandscape();
        }

        // ── Main render ──
        function render(frameData) {
            var ctx = frameData.ctx;
            var dt = frameData.dt || 1 / 60;
            var cursor = frameData.cursor;
            beatPulse = frameData.beatPulse;
            time += dt;

            // Background
            drawSky(ctx);

            if (!cursor) {
                // Idle state: peaceful static scene
                drawStars(ctx, dt, 0);
                drawHills(ctx);
                drawTrees(ctx);
                drawGround(ctx, 0);
                drawCampfire(ctx, 0.3);
                updateAndDrawEmbers(ctx, dt, 0.2);
                StickFight.drawAll(ctx, figureSeats);
                return;
            }

            var beat = cursor.beat;
            var seqIdx = cursor.seqIndex;
            var energy = analysis ? (analysis.energy[cursor.timelineIndex] || 0) : 0.3;

            // Section tracking
            if (seqIdx !== lastSeqIndex) {
                sectionMood = mapSection(seqIdx);
                lastSeqIndex = seqIdx;
            }

            // Beat handling
            if (frameData.beatChanged) {

                // Twinkle stars on beats
                flashRandomStars(3 + Math.floor(energy * 8));

                // Head bob trigger
                for (var hi = 0; hi < figureMeta.length; hi++) {
                    figureMeta[hi].headBobAmount = 0.3 + energy * 0.7;
                    StickFight.setTarget(figureSeats[hi], 'bounce', -0.35 + (0.05 * energy));
                }

                // Storyteller gesture changes
                if (Math.random() < 0.3) {
                    var storyteller = Math.floor(Math.random() * figureMeta.length);
                    for (var gi = 0; gi < figureMeta.length; gi++) {
                        figureMeta[gi].armRaise = gi === storyteller ? 0.3 + Math.random() * 0.4 : 0;
                        if (gi === storyteller) {
                            StickFight.setTarget(figureSeats[gi], 'armLAngle', -0.3 - Math.random() * 0.5);
                            StickFight.setTarget(figureSeats[gi], 'elbowLBend', 0.3);
                        } else {
                            StickFight.setTarget(figureSeats[gi], 'armLAngle', 0.5);
                            StickFight.setTarget(figureSeats[gi], 'elbowLBend', 0.4);
                        }
                    }
                }
            }

            // Decay beat pulse

            // Update head bob phases and StickFight figures
            for (var ui = 0; ui < figureMeta.length; ui++) {
                figureMeta[ui].headBobPhase += (3 + energy * 2) * dt;
                figureMeta[ui].headBobAmount *= Math.exp(-2 * dt);
            }
            StickFight.updateAll(figureSeats, dt);

            // Shooting star timer
            shootingStarTimer -= dt;
            if (shootingStarTimer <= 0) {
                spawnShootingStar();
                shootingStarTimer = 5 + Math.random() * 15;
            }
            // Extra shooting stars during bridge sections
            if (sectionMood === 'bridge' && Math.random() < 0.002) {
                spawnShootingStar();
            }

            // Title: show during intro and bridge
            titleTarget = (sectionMood === 'intro' || sectionMood === 'bridge') ? 1 : 0;
            titleAlpha += (titleTarget - titleAlpha) * (1 - Math.exp(-2 * dt));

            // ── Draw scene (back to front) ──

            // 1. Stars
            drawStars(ctx, dt, energy);

            // 2. Shooting stars
            updateAndDrawShootingStars(ctx, dt);

            // 3. Title (behind landscape)
            drawTitle(ctx);

            // 4. Hills
            drawHills(ctx);

            // 5. Trees
            drawTrees(ctx);

            // 6. Firelight ambient glow (affects whole scene)
            drawFirelightGlow(ctx, energy);

            // 7. Ground
            drawGround(ctx, energy);

            // 8. Shadows
            drawShadows(ctx, energy);

            // 9. Survivors
            for (var si = 0; si < figureSeats.length; si++) {
                drawSurvivor(ctx, figureSeats[si], figureMeta[si], energy);
            }

            // 10. Campfire (in front of survivors for depth)
            drawCampfire(ctx, energy);

            // 11. Embers (topmost, floating above)
            updateAndDrawEmbers(ctx, dt, energy);
        }

        BaseRenderer('campfire-video', 'Survivors: Campfire Rest', {
            beatDecay: 5,
            init: init,
            render: render,
            resize: resize
        });
    })();

    // ── Page bootstrap ──
    (function() {
        var canvas = document.getElementById('viz-canvas');
        var overlay = document.getElementById('play-overlay');

        Visualizer.init(canvas);
        Visualizer.setRenderer('campfire-video');

        function loadAndPlay(json) {
            Visualizer.loadSong(json);
            Visualizer.play();
        }

        function fetchSong() {
            var url = '../audio-tracker/songs/survivors-campfire.json';
            if (window.fetch && location.protocol !== 'file:') {
                return fetch(url).then(function(r) { return r.json(); });
            }
            return new Promise(function(resolve, reject) {
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.onload = function() {
                    if (xhr.status === 200 || xhr.status === 0) {
                        resolve(JSON.parse(xhr.responseText));
                    } else {
                        reject(new Error('XHR failed: ' + xhr.status));
                    }
                };
                xhr.onerror = function() { reject(new Error('XHR error')); };
                xhr.send();
            });
        }

        overlay.addEventListener('click', function() {
            overlay.classList.add('hidden');
            fetchSong().then(loadAndPlay).catch(function(err) {
                console.error('Failed to load song:', err);
                overlay.classList.remove('hidden');
            });
        });

        // Auto-play when embedded (e.g. jukebox iframe with ?autoplay=1)
        if (new URLSearchParams(window.location.search).get('autoplay') === '1') {
            overlay.click();
        }

        canvas.addEventListener('click', function() {
            if (overlay.classList.contains('hidden')) {
                if (Visualizer.isPlaying()) {
                    Visualizer.stop();
                } else {
                    Visualizer.play();
                }
            }
        });
    })();
    </script>
</body>
</html>
