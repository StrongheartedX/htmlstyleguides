<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Glassblower's Phoenix — Music Video</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="video-base-styles.css">
    <style>
        :root {
            --vid-bg: #1a0800;
            --vid-bg-rgb: 26,8,0;
            --vid-font: 'Cinzel', serif;
            --vid-accent: #ff9933;
            --vid-accent-r: 255;
            --vid-accent-g: 153;
            --vid-accent-b: 51;
            --vid-overlay-alpha: 0.93;
            --vid-title-spacing: 0.08em;
            --vid-sub-alpha: 0.55;
        }
    </style>
</head>
<body>
    <a href="music-videos/index.html" class="back-link">&larr; Music Videos</a>
    <canvas id="viz-canvas"></canvas>
    <div class="play-overlay" id="play-overlay">
        <div class="play-title">The Glassblower's Phoenix</div>
        <div class="play-sub">a narrative music video</div>
        <div class="play-btn"></div>
    </div>

    <script src="../audio-tracker/playback-engine.js"></script>
    <script src="engine.js"></script>
    <script src="video-utils.js"></script>
    <script src="base-renderer.js"></script>
    <script>
    // ── The Glassblower's Phoenix Video Renderer ───────────────────────────
    (function() {
        "use strict";

        var W = 0, H = 0;
        var analysis = null;

        // ── Color Palette ──
        var COL_BG_FORGE    = '#1a0800';
        var COL_MOLTEN      = '#ff6600';
        var COL_GLOW        = '#ffaa33';
        var COL_DARK        = '#331100';
        var COL_GLASS_AMBER = '#ffcc88';
        var COL_GLASS_BRIGHT= '#ffe8cc';
        var COL_GRIEF_BG    = '#0a0608';
        var COL_GRIEF_BLUE  = '#1a1228';
        var COL_PHOENIX_DEEP= '#ff4400';
        var COL_PHOENIX_GOLD= '#ffaa00';
        var COL_PHOENIX_HOT = '#ffee88';
        var COL_STAR        = '#aaccff';
        var COL_WHITE       = '#ffffff';

        // ── Scene State ──
        var scene = 'forge';
        var lastScene = 'forge';   // tracks scene-level changes (not per-seqIdx)
        var lastSeqIndex = -1;
        var elapsed = 0;
        var introFade = 0;
        var outroFade = 1;

        // ── Global animatables ──
        var bgBrightness = 0;       // 0..1 forge brightness
        var glassOrbR = 0;          // current glass orb radius
        var glassOrbRTarget = 0;
        var glassPhase = 0;         // deformation phase
        var glassColorT = 0;        // 0=molten 1=clear amber
        var glassColorTTarget = 0;
        var energySmooth = 0;
        var sceneAge = 0;           // seconds in current scene

        // ── Title / Subtitle ──
        var titleAlpha = 0;
        var titleTarget = 0;
        var subtitleAlpha = 0;
        var subtitleTarget = 0;
        var subtitleText = '';

        // ── Flash ──
        var flashAlpha = 0;
        var flashColor = '#ffffff';

        // ── Screen Shake ──
        var shakeX = 0, shakeY = 0;
        var shakeIntensity = 0;

        // ── Ember Particles ──
        var embers = [];
        var EMBER_COUNT = 120;

        // ── Glass Fragments (shatter) ──
        var fragments = [];
        var FRAG_COUNT = 55;
        var shatterTriggered = false;
        var shatterGlowFade = 0;  // 0..1 ground ember glow post-shatter

        // ── Stars (phoenix scene) ──
        var stars = [];
        var STAR_COUNT = 100;
        var starAlpha = 0;
        var starAlphaTarget = 0;

        // ── Phoenix ──
        var phoenixY = 0;           // y position (from bottom %)
        var phoenixYTarget = 0;
        var phoenixSize = 0;
        var phoenixSizeTarget = 0;
        var phoenixAlpha = 0;
        var phoenixAlphaTarget = 0;
        var phoenixPhase = 0;

        // ── Figure state ──
        var figureHunch = 0;        // 0=upright 1=hunched (grief)
        var figureHunchTarget = 0;
        var figureLeanAngle = 0;    // lean forward (working)
        var figureLeanTarget = 0;
        var figureVisible = 1;
        var figureVisibleTarget = 1;

        // ── Light rays ──
        var rayAlpha = 0;
        var rayAlphaTarget = 0;
        var rayCount = 8;

        // ── Background tint ──
        var bgColdT = 0;            // 0=warm 1=cold blue (grief)
        var bgColdTTarget = 0;
        var skyOpenT = 0;           // 0=workshop 1=open sky (phoenix)
        var skyOpenTTarget = 0;

        // ── Crucially-moment state ──
        var crucialHold = 0;        // 0..1

        // ── Vignette ──
        var vignetteIntensity = 0.6;

        // ── Ghost image (grief scene — retrograde motif) ──
        var ghostAlpha = 0;
        var ghostAlphaTarget = 0;

        // ── Scene names ──
        var SCENE_TEXTS = {
            'forge':    'The Forge Awakens',
            'gather':   'Gathering',
            'shape':    'Shaping',
            'crucial':  'The Crucial Moment',
            'shatter':  'The Shatter',
            'grief':    'Silence',
            'begin':    'Beginning Again',
            'phoenix':  'The Phoenix Rises'
        };

        // ── Scene mapping ──
        function mapScene(seqIdx) {
            if (seqIdx <= 2)  return 'forge';
            if (seqIdx <= 7)  return 'gather';
            if (seqIdx <= 13) return 'shape';
            if (seqIdx <= 15) return 'crucial';
            if (seqIdx <= 17) return 'shatter';
            if (seqIdx <= 20) return 'grief';
            if (seqIdx <= 24) return 'begin';
            return 'phoenix';
        }

        // ── Color lerp helper ──
        function lerpColor(c1, c2, t) {
            t = t < 0 ? 0 : t > 1 ? 1 : t;
            var r1 = parseInt(c1.slice(1,3),16), g1 = parseInt(c1.slice(3,5),16), b1 = parseInt(c1.slice(5,7),16);
            var r2 = parseInt(c2.slice(1,3),16), g2 = parseInt(c2.slice(3,5),16), b2 = parseInt(c2.slice(5,7),16);
            var r = Math.round(r1 + (r2-r1)*t), g = Math.round(g1 + (g2-g1)*t), b = Math.round(b1 + (b2-b1)*t);
            return 'rgb(' + r + ',' + g + ',' + b + ')';
        }

        // ── Init ──
        function init(ctx, w, h, ana) {
            W = w; H = h;
            analysis = ana;
            initEmbers();
            initStars();
            initFragments();
            scene = 'forge';
            lastScene = 'forge';
            lastSeqIndex = -1;
            glassOrbR = 0;
            glassOrbRTarget = 0;
            glassColorT = 0;
            glassColorTTarget = 0;
            bgBrightness = 0;
            introFade = 0;
            outroFade = 1;
            flashAlpha = 0;
            shatterTriggered = false;
            shatterGlowFade = 0;
            phoenixY = 0;
            phoenixYTarget = 0;
            phoenixSize = 0;
            phoenixSizeTarget = 0;
            phoenixAlpha = 0;
            phoenixAlphaTarget = 0;
            starAlpha = 0;
            starAlphaTarget = 0;
            skyOpenT = 0;
            skyOpenTTarget = 0;
            bgColdT = 0;
            bgColdTTarget = 0;
            figureHunch = 0;
            figureVisible = 1;
            figureVisibleTarget = 1;
            figureLeanTarget = 0.3;
            titleAlpha = 0;
            subtitleAlpha = 0;
            energySmooth = 0;
            rayAlpha = 0;
            rayAlphaTarget = 0;
            ghostAlpha = 0;
            ghostAlphaTarget = 0;
            sceneAge = 0;
        }

        function resize(w, h) {
            W = w; H = h;
            initStars();
            initEmbers();
            initFragments();
        }

        function initEmbers() {
            embers = [];
            for (var i = 0; i < EMBER_COUNT; i++) {
                embers.push(makeEmber(true));
            }
        }

        function makeEmber(randomY) {
            var forgeX = W * 0.5;
            var forgeY = H * 0.82;
            return {
                x: forgeX + rand(-W * 0.12, W * 0.12),
                y: randomY ? rand(forgeY - H * 0.4, forgeY) : forgeY + rand(-H * 0.04, 0),
                vx: rand(-18, 18),
                vy: rand(-60, -20),
                size: rand(1.5, 4),
                alpha: rand(0.4, 0.9),
                life: rand(0, 1),
                maxLife: rand(1.5, 4),
                colorT: rand(0, 1),   // 0=red-orange 1=amber
                trail: [],
                isGlass: false
            };
        }

        function makeGlassEmber() {
            var e = makeEmber(false);
            e.isGlass = true;
            e.size = rand(1, 3);
            e.alpha = rand(0.3, 0.7);
            e.colorT = rand(0.7, 1);
            e.vx = rand(-30, 30);
            e.vy = rand(-80, -30);
            return e;
        }

        function makePhoenixEmber(cx, cy) {
            return {
                x: cx + rand(-20, 20),
                y: cy + rand(0, H * 0.05),
                vx: rand(-25, 25),
                vy: rand(-70, -10),
                size: rand(1.5, 3.5),
                alpha: rand(0.5, 1),
                life: 0,
                maxLife: rand(0.8, 2),
                colorT: rand(0, 1),
                trail: [],
                isGlass: false
            };
        }

        function initStars() {
            stars = [];
            for (var i = 0; i < STAR_COUNT; i++) {
                stars.push({
                    x: rand(0, W),
                    y: rand(0, H * 0.65),
                    size: rand(0.4, 2.2),
                    twinkle: rand(0, Math.PI * 2),
                    speed: rand(0.5, 2.5)
                });
            }
        }

        function initFragments() {
            fragments = [];
            for (var i = 0; i < FRAG_COUNT; i++) {
                fragments.push(makeFragment());
            }
        }

        function makeFragment() {
            return {
                x: W * 0.5, y: H * 0.45,
                vx: rand(-W * 0.3, W * 0.3),
                vy: rand(-H * 0.45, -H * 0.05),
                rot: rand(0, Math.PI * 2),
                rotV: rand(-4, 4),
                size: rand(H * 0.012, H * 0.04),
                alpha: rand(0.6, 1),
                glow: rand(0.5, 1),
                active: false,
                settled: false,
                colorT: rand(0.4, 1)
            };
        }

        // ── Spawn Shatter Fragments ──
        function spawnShatter() {
            var cx = W * 0.5;
            var cy = H * 0.45;
            var orbR = glassOrbR;
            for (var i = 0; i < fragments.length; i++) {
                var angle = rand(0, Math.PI * 2);
                var speed = rand(H * 0.15, H * 0.55);
                fragments[i].x = cx + Math.cos(angle) * orbR * 0.5;
                fragments[i].y = cy + Math.sin(angle) * orbR * 0.5;
                fragments[i].vx = Math.cos(angle) * speed * rand(0.4, 1.0);
                fragments[i].vy = Math.sin(angle) * speed * rand(0.4, 1.0) - H * 0.1;
                fragments[i].rot = rand(0, Math.PI * 2);
                fragments[i].rotV = rand(-6, 6);
                fragments[i].size = rand(H * 0.01, H * 0.035);
                fragments[i].alpha = rand(0.7, 1);
                fragments[i].glow = 1;
                fragments[i].active = true;
                fragments[i].settled = false;
                fragments[i].colorT = rand(0.3, 0.9);
            }
        }

        // ── Draw Background ──
        function drawBackground(ctx) {
            var topColor, botColor;
            // Base: forge warm — use bgBrightness to lighten
            topColor = lerpColor('#0a0400', '#2a1200', bgBrightness);
            botColor = lerpColor('#0a0400', '#3a1a04', bgBrightness);
            // Blend toward night sky (phoenix / begin)
            if (skyOpenT > 0.01) {
                var nightTop = '#040216';
                var nightBot = '#0d0820';
                topColor = lerpColor(topColor, nightTop, skyOpenT);
                botColor = lerpColor(botColor, nightBot, skyOpenT);
            }
            // Blend toward cold blue-black (grief) — layered on top
            if (bgColdT > 0.01) {
                topColor = lerpColor(topColor, COL_GRIEF_BG, bgColdT);
                botColor = lerpColor(botColor, '#080408', bgColdT);
            }

            var grad = ctx.createLinearGradient(0, 0, 0, H);
            grad.addColorStop(0, topColor);
            grad.addColorStop(0.6, botColor);
            grad.addColorStop(1, '#000000');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, W, H);

            // Workshop walls (visible in forge/gather/shape/crucial scenes)
            var wallAlpha = 1 - skyOpenT - bgColdT * 0.7;
            wallAlpha = wallAlpha < 0 ? 0 : wallAlpha > 1 ? 1 : wallAlpha;
            if (wallAlpha > 0.02 && bgBrightness > 0.1) {
                drawWorkshopWalls(ctx, wallAlpha);
            }
        }

        function drawWorkshopWalls(ctx, alpha) {
            ctx.save();
            ctx.globalAlpha = alpha * bgBrightness * 0.5;
            // Left wall
            ctx.fillStyle = '#2a1200';
            ctx.fillRect(0, 0, W * 0.08, H);
            // Right wall
            ctx.fillRect(W * 0.92, 0, W * 0.08, H);
            // Ceiling beams
            ctx.globalAlpha = alpha * bgBrightness * 0.35;
            ctx.fillStyle = '#1a0a00';
            ctx.fillRect(0, 0, W, H * 0.08);
            // Wall highlight from forge glow — radiates from forge center
            var wgL = ctx.createLinearGradient(W * 0.3, H * 0.7, 0, H * 0.5);
            wgL.addColorStop(0, rgba(COL_MOLTEN, 0.15 * bgBrightness));
            wgL.addColorStop(1, rgba(COL_MOLTEN, 0));
            ctx.globalAlpha = 1;
            ctx.fillStyle = wgL;
            ctx.fillRect(0, 0, W * 0.35, H);
            // Right wall glow
            var wgR = ctx.createLinearGradient(W * 0.7, H * 0.7, W, H * 0.5);
            wgR.addColorStop(0, rgba(COL_MOLTEN, 0.12 * bgBrightness));
            wgR.addColorStop(1, rgba(COL_MOLTEN, 0));
            ctx.fillStyle = wgR;
            ctx.fillRect(W * 0.65, 0, W * 0.35, H);
            // Floor glow from forge
            var wgF = ctx.createLinearGradient(W * 0.5, H * 0.85, W * 0.5, H * 0.6);
            wgF.addColorStop(0, rgba(COL_MOLTEN, 0.2 * bgBrightness));
            wgF.addColorStop(1, rgba(COL_MOLTEN, 0));
            ctx.fillStyle = wgF;
            ctx.fillRect(W * 0.15, H * 0.6, W * 0.7, H * 0.4);
            ctx.restore();
        }

        // ── Draw Stars ──
        function drawStars(ctx, dt) {
            if (starAlpha < 0.01) return;
            ctx.save();
            for (var i = 0; i < stars.length; i++) {
                var s = stars[i];
                s.twinkle += s.speed * dt;
                var a = starAlpha * (0.3 + 0.7 * Math.abs(Math.sin(s.twinkle)));
                ctx.globalAlpha = a;
                ctx.fillStyle = COL_STAR;
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        // ── Draw Forge ──
        function drawForge(ctx, energy, dt, beatPulseVal) {
            var forgeW = W * 0.22;
            var forgeH = H * 0.1;
            var forgeX = W * 0.5 - forgeW * 0.5;
            var forgeY = H * 0.86;
            var bp = beatPulseVal || 0;

            // Dim in grief, dim when phoenix takes over
            var forgeBright = bgBrightness;
            if (bgColdT > 0.5) {
                forgeBright = bgBrightness * (1 - (bgColdT - 0.5) * 1.5);
                forgeBright = forgeBright < 0 ? 0 : forgeBright;
            }
            if (forgeBright < 0.02 && scene !== 'begin' && scene !== 'phoenix') return;

            ctx.save();
            // Pulse driven by sin wave + energy + beatPulse for visceral beat response
            var pulse = 0.85 + Math.sin(glassPhase * 1.5) * 0.15 + energy * 0.15 + bp * 0.25;

            // Glow beneath forge — radius expands with beatPulse
            var glowRadius = forgeW * (1.8 + bp * 0.8);
            var gg = ctx.createRadialGradient(W * 0.5, forgeY + forgeH * 0.5, 0, W * 0.5, forgeY + forgeH * 0.5, glowRadius);
            gg.addColorStop(0, rgba(COL_MOLTEN, forgeBright * pulse * 0.7));
            gg.addColorStop(0.4, rgba('#ff3300', forgeBright * pulse * 0.35));
            gg.addColorStop(1, rgba(COL_MOLTEN, 0));
            ctx.fillStyle = gg;
            ctx.fillRect(forgeX - forgeW * 1.5, forgeY - forgeH, forgeW * 5, forgeH * 6);

            // Forge body
            var fg = ctx.createLinearGradient(forgeX, forgeY, forgeX, forgeY + forgeH);
            fg.addColorStop(0, lerpColor('#ff5500', '#220800', 1 - forgeBright * pulse));
            fg.addColorStop(0.4, '#882200');
            fg.addColorStop(1, '#110300');
            ctx.globalAlpha = forgeBright;
            ctx.fillStyle = fg;
            ctx.fillRect(forgeX, forgeY, forgeW, forgeH);

            // Opening glow at top
            var og = ctx.createLinearGradient(forgeX, forgeY - forgeH * 0.5, forgeX, forgeY + forgeH * 0.3);
            og.addColorStop(0, rgba(COL_GLOW, forgeBright * pulse * 0.8));
            og.addColorStop(1, rgba(COL_MOLTEN, 0));
            ctx.fillStyle = og;
            ctx.fillRect(forgeX + forgeW * 0.1, forgeY - forgeH * 0.5, forgeW * 0.8, forgeH * 0.8);

            // Heat distortion lines above forge
            if (forgeBright > 0.3) {
                ctx.globalAlpha = 0.05 * forgeBright;
                ctx.strokeStyle = COL_GLOW;
                ctx.lineWidth = 1;
                for (var hi = 0; hi < 5; hi++) {
                    var hx = forgeX + forgeW * (0.1 + hi * 0.2);
                    var hOffset = Math.sin(glassPhase * 2.3 + hi * 1.1) * 4;
                    ctx.beginPath();
                    ctx.moveTo(hx, forgeY);
                    ctx.quadraticCurveTo(hx + hOffset, forgeY - forgeH, hx, forgeY - forgeH * 2);
                    ctx.stroke();
                }
            }

            ctx.restore();
        }

        // ── Draw Figure Silhouette ──
        function drawFigure(ctx, energy) {
            if (figureVisible < 0.05) return;

            var groundY = H * 0.86;
            var figH = H * 0.18;
            var cx = W * 0.5 - W * 0.14; // slightly left of center
            var hunch = figureHunch;
            var lean = figureLeanAngle;

            ctx.save();
            ctx.globalAlpha = figureVisible;
            var figCol = (scene === 'grief') ? '#181018' : '#2a1608';
            ctx.fillStyle = figCol;
            ctx.strokeStyle = figCol;
            ctx.lineCap = 'round';

            var headR = figH * 0.08;
            var torsoLen = figH * 0.28;
            var legLen = figH * 0.35;

            // Hunch offset
            var hunchOffY = hunch * figH * 0.1;
            var hunchAngle = hunch * 0.4;
            var leanAngle = lean * 0.35;

            // Head pos
            var headX = cx + Math.sin(leanAngle + hunchAngle) * (torsoLen + headR * 2);
            var headY = groundY - legLen - torsoLen * Math.cos(hunchAngle) - headR * 2 - hunchOffY;

            // Head
            ctx.beginPath();
            ctx.arc(headX, headY, headR, 0, Math.PI * 2);
            ctx.fill();

            // Torso
            var neckX = cx + Math.sin(leanAngle + hunchAngle * 0.6) * (torsoLen + headR);
            var neckY = groundY - legLen - torsoLen * Math.cos(hunchAngle * 0.6) - hunchOffY;
            var hipX = cx;
            var hipY = groundY - legLen;
            ctx.lineWidth = figH * 0.055;
            ctx.beginPath();
            ctx.moveTo(neckX, neckY + headR);
            ctx.lineTo(hipX, hipY);
            ctx.stroke();

            // Legs
            ctx.lineWidth = figH * 0.045;
            // Left leg
            ctx.beginPath();
            ctx.moveTo(hipX, hipY);
            ctx.lineTo(hipX - figH * 0.06, groundY);
            ctx.stroke();
            // Right leg
            ctx.beginPath();
            ctx.moveTo(hipX, hipY);
            ctx.lineTo(hipX + figH * 0.04, groundY);
            ctx.stroke();

            // Arms — working at the blowpipe
            ctx.lineWidth = figH * 0.038;
            var armBaseX = neckX + (hipX - neckX) * 0.25;
            var armBaseY = neckY + (hipY - neckY) * 0.25;

            if (scene === 'grief') {
                // Arms hang low, drooping
                ctx.beginPath();
                ctx.moveTo(armBaseX, armBaseY);
                ctx.quadraticCurveTo(armBaseX + figH * 0.05, armBaseY + figH * 0.2, armBaseX - figH * 0.02, armBaseY + figH * 0.28);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(armBaseX, armBaseY);
                ctx.quadraticCurveTo(armBaseX - figH * 0.08, armBaseY + figH * 0.22, armBaseX - figH * 0.04, armBaseY + figH * 0.3);
                ctx.stroke();
            } else {
                // Holding blowpipe out toward center/right
                var pipeDir = (scene === 'crucial' || scene === 'shape') ? 1 : 0.7;
                ctx.beginPath();
                ctx.moveTo(armBaseX, armBaseY);
                ctx.lineTo(armBaseX + figH * 0.18 * pipeDir, armBaseY + figH * 0.05);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(armBaseX, armBaseY);
                ctx.lineTo(armBaseX + figH * 0.22 * pipeDir, armBaseY + figH * 0.12);
                ctx.stroke();

                // Blowpipe — long rod from figure to orb
                if (scene !== 'shatter' && scene !== 'grief' && glassOrbR > 1) {
                    var orbX = W * 0.5;
                    var orbY = H * 0.45;
                    ctx.globalAlpha = figureVisible * 0.8;
                    ctx.strokeStyle = '#1a0a00';
                    ctx.lineWidth = figH * 0.022;
                    ctx.beginPath();
                    ctx.moveTo(armBaseX + figH * 0.22 * pipeDir, armBaseY + figH * 0.1);
                    ctx.lineTo(orbX, orbY);
                    ctx.stroke();
                }
            }

            // Rim light from forge — orange edge glow on figure
            if (bgBrightness > 0.2 && scene !== 'grief') {
                ctx.globalAlpha = figureVisible * bgBrightness * 0.5;
                ctx.strokeStyle = rgba(COL_MOLTEN, 0.6);
                ctx.lineWidth = figH * 0.025;
                // Right edge of torso (facing forge)
                ctx.beginPath();
                ctx.moveTo(neckX + figH * 0.02, neckY + headR);
                ctx.lineTo(hipX + figH * 0.02, hipY);
                ctx.stroke();
                // Head rim
                ctx.beginPath();
                ctx.arc(headX, headY, headR + 1, -0.5, 1.2);
                ctx.stroke();
            }

            ctx.restore();
        }

        // ── Draw Glass Orb ──
        function drawGlassOrb(ctx, dt, energy, beat) {
            if (glassOrbR < 1) return;
            if (scene === 'shatter' && shatterTriggered) return;
            if (scene === 'grief') return;

            glassPhase += dt * (1.8 + energy * 2);

            var cx = W * 0.5;
            var cy = H * 0.45;
            var r = glassOrbR;
            var bp = beat || 0;

            // Deformation based on scene — amplified by beatPulse
            var deform = 0;
            if (scene === 'shape' || scene === 'crucial') {
                deform = 0.12 + energy * 0.08 + bp * 0.06;
            } else if (scene === 'gather') {
                deform = 0.05 + energy * 0.04 + bp * 0.03;
            }

            // Build deformed path
            ctx.save();

            // Outer glow — expands on beat
            var glowR = r * (1.8 + energy * 0.6 + bp * 0.5 + (scene === 'crucial' ? 0.8 : 0));
            var gc = ctx.createRadialGradient(cx, cy, r * 0.2, cx, cy, glowR);
            var glowColorA = (scene === 'begin' || scene === 'phoenix') ? '#ffcc00' : COL_GLOW;
            var glowColorB = (scene === 'begin' || scene === 'phoenix') ? '#ff8800' : COL_MOLTEN;
            gc.addColorStop(0, rgba(glowColorA, 0.35 + energy * 0.2 + bp * 0.15));
            gc.addColorStop(0.4, rgba(glowColorB, 0.12 + energy * 0.1));
            gc.addColorStop(1, rgba(glowColorB, 0));
            ctx.fillStyle = gc;
            ctx.fillRect(cx - glowR, cy - glowR, glowR * 2, glowR * 2);

            // Orb shape (deformed circle) — extra harmonic on beat
            var steps = 48;
            ctx.beginPath();
            for (var si = 0; si <= steps; si++) {
                var ang = (si / steps) * Math.PI * 2;
                var d1 = deform * Math.sin(ang * 3 + glassPhase * 0.7) * r;
                var d2 = deform * Math.sin(ang * 5 - glassPhase * 1.1) * r * 0.5;
                var d3 = (scene === 'shape' ? deform * 0.6 : 0) * Math.sin(ang * 2 + glassPhase) * r;
                var d4 = bp * 0.04 * Math.sin(ang * 7 + glassPhase * 2.3) * r;
                var rr = r + d1 + d2 + d3 + d4;
                var px = cx + Math.cos(ang) * rr;
                var py = cy + Math.sin(ang) * rr * (scene === 'shape' ? (0.85 + Math.sin(glassPhase * 0.4) * 0.15) : 1);
                if (si === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();

            // Glass color — molten orange to translucent amber
            var cInner, cOuter;
            var t = glassColorT;
            if (scene === 'begin' || scene === 'phoenix') {
                // New glass — golden/white tint
                cInner = lerpColor('#ffdd88', '#ffffff', t * 0.7 + energy * 0.1);
                cOuter = lerpColor('#ffaa00', '#ffcc44', t);
            } else {
                cInner = lerpColor('#ff8800', '#ffe8cc', t);
                cOuter = lerpColor(COL_MOLTEN, COL_GLASS_AMBER, t);
            }
            var ig = ctx.createRadialGradient(cx - r * 0.2, cy - r * 0.25, r * 0.1, cx, cy, r);
            ig.addColorStop(0, cInner);
            ig.addColorStop(0.5, cOuter);
            ig.addColorStop(1, rgba(cOuter, 0.6));
            ctx.fillStyle = ig;
            ctx.globalAlpha = 0.88 + energy * 0.12;
            ctx.fill();

            // Inner highlight
            if (t > 0.3) {
                ctx.globalAlpha = t * 0.4;
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.ellipse(cx - r * 0.25, cy - r * 0.3, r * 0.2, r * 0.12, -0.5, 0, Math.PI * 2);
                ctx.fill();
            }

            // Beat pulse ring
            if (energy > 0.3) {
                ctx.globalAlpha = energy * 0.3;
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(cx, cy, r * (1.1 + energy * 0.3), 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.restore();
        }

        // ── Draw Light Rays ──
        function drawLightRays(ctx, energy) {
            if (rayAlpha < 0.02) return;
            var cx = W * 0.5;
            var cy = H * 0.45;
            var rayLen = H * 0.55 + energy * H * 0.3;

            ctx.save();
            ctx.globalAlpha = rayAlpha * (0.6 + energy * 0.4);
            for (var ri = 0; ri < rayCount; ri++) {
                var angle = (ri / rayCount) * Math.PI * 2 + glassPhase * 0.15;
                var col = (scene === 'phoenix') ? '#ffdd44' : COL_GLASS_BRIGHT;
                var rg = ctx.createLinearGradient(cx, cy, cx + Math.cos(angle) * rayLen, cy + Math.sin(angle) * rayLen);
                rg.addColorStop(0, rgba(col, 0.25 + energy * 0.2));
                rg.addColorStop(0.3, rgba(col, 0.08));
                rg.addColorStop(1, rgba(col, 0));
                ctx.strokeStyle = rg;
                ctx.lineWidth = 2 + energy * 3;
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.lineTo(cx + Math.cos(angle) * rayLen, cy + Math.sin(angle) * rayLen);
                ctx.stroke();
            }
            ctx.restore();
        }

        // ── Draw Embers ──
        function drawEmbers(ctx, dt, energy) {
            var groundY = H * 0.88;
            var forgeX = W * 0.5;
            var forgeY = H * 0.82;

            // Determine how many embers to show
            var countMul = 0.1;
            if (scene === 'forge')   countMul = 0.2 + energy * 0.2;
            if (scene === 'gather')  countMul = 0.3 + energy * 0.3;
            if (scene === 'shape')   countMul = 0.5 + energy * 0.4;
            if (scene === 'crucial') countMul = 0.8 + energy * 0.2;
            if (scene === 'shatter') countMul = shatterTriggered ? 0.05 : 0.9;
            if (scene === 'grief')   countMul = 0.04 + energy * 0.04;
            if (scene === 'begin')   countMul = 0.2 + energy * 0.3;
            if (scene === 'phoenix') countMul = 0.7 + energy * 0.3;
            var visCount = Math.floor(EMBER_COUNT * countMul);

            ctx.save();
            for (var i = 0; i < visCount; i++) {
                var e = embers[i];
                e.life += dt;
                if (e.life > e.maxLife) {
                    // Respawn
                    var fresh = (scene === 'phoenix') ?
                        makePhoenixEmber(W * 0.5, H * 0.5 - phoenixY * H * 0.4) :
                        makeEmber(false);
                    embers[i] = fresh;
                    e = embers[i];
                }

                var lifeT = e.life / e.maxLife;
                e.x += e.vx * dt;
                e.y += e.vy * dt;
                e.vy += dt * 12; // light gravity

                // Sway
                e.x += Math.sin(e.life * 2.5 + i * 0.7) * 8 * dt;

                // Trail
                e.trail.unshift({x: e.x, y: e.y});
                if (e.trail.length > 5) e.trail.pop();

                var a = e.alpha * (1 - lifeT * 0.8) * (scene === 'grief' ? 0.3 : 1);
                if (a < 0.01) continue;

                var col;
                if (scene === 'phoenix' || scene === 'begin') {
                    col = lerpColor(COL_PHOENIX_DEEP, COL_PHOENIX_HOT, e.colorT);
                } else if (e.isGlass) {
                    col = lerpColor(COL_GLASS_AMBER, COL_WHITE, e.colorT - 0.5);
                } else {
                    col = lerpColor('#ff3300', COL_GLOW, e.colorT);
                }

                // Trail
                for (var ti = 0; ti < e.trail.length; ti++) {
                    var ta = a * (1 - ti / e.trail.length) * 0.4;
                    ctx.globalAlpha = ta;
                    ctx.fillStyle = col;
                    ctx.beginPath();
                    ctx.arc(e.trail[ti].x, e.trail[ti].y, e.size * (1 - ti * 0.15), 0, Math.PI * 2);
                    ctx.fill();
                }
                // Head
                ctx.globalAlpha = a;
                ctx.fillStyle = col;
                ctx.shadowColor = col;
                ctx.shadowBlur = e.size * 3;
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
            ctx.restore();
        }

        // ── Draw Glass Fragments (shatter) ──
        function drawFragments(ctx, dt, energy) {
            var groundY = H * 0.88;
            var anyActive = false;
            ctx.save();
            for (var i = 0; i < fragments.length; i++) {
                var f = fragments[i];
                if (!f.active) continue;
                anyActive = true;

                if (!f.settled) {
                    f.x += f.vx * dt;
                    f.y += f.vy * dt;
                    f.vy += 280 * dt; // gravity
                    f.rot += f.rotV * dt;
                    f.glow *= Math.exp(-1.0 * dt);
                    f.alpha *= Math.exp(-0.12 * dt);

                    if (f.y > groundY) {
                        f.y = groundY;
                        f.vy *= -0.25;
                        f.vx *= 0.8;
                        f.rotV *= 0.6;
                        if (Math.abs(f.vy) < 10) f.settled = true;
                    }
                } else {
                    f.alpha *= Math.exp(-0.06 * dt);
                    f.glow *= Math.exp(-0.8 * dt);
                }

                if (f.alpha < 0.01) { f.active = false; continue; }

                ctx.save();
                ctx.translate(f.x, f.y);
                ctx.rotate(f.rot);
                ctx.globalAlpha = f.alpha;

                // Fragment triangle
                var s = f.size;
                var col = lerpColor(COL_GLASS_AMBER, COL_GLASS_BRIGHT, f.colorT);
                ctx.fillStyle = col;
                if (f.glow > 0.05) {
                    ctx.shadowColor = col;
                    ctx.shadowBlur = s * f.glow * 4;
                }
                ctx.beginPath();
                ctx.moveTo(0, -s);
                ctx.lineTo(s * 0.866, s * 0.5);
                ctx.lineTo(-s * 0.866, s * 0.5);
                ctx.closePath();
                ctx.fill();

                // Inner highlight
                ctx.globalAlpha = f.alpha * f.colorT * 0.5;
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.moveTo(0, -s * 0.5);
                ctx.lineTo(s * 0.3, s * 0.2);
                ctx.lineTo(-s * 0.3, s * 0.2);
                ctx.closePath();
                ctx.fill();

                ctx.shadowBlur = 0;
                ctx.restore();
            }

            // Ground ember glow from settled fragments
            if (shatterGlowFade > 0.02) {
                ctx.globalAlpha = shatterGlowFade * 0.3;
                var gg = ctx.createLinearGradient(W * 0.3, groundY, W * 0.7, groundY + H * 0.04);
                gg.addColorStop(0, rgba(COL_GLASS_AMBER, 0.5));
                gg.addColorStop(0.5, rgba(COL_GLOW, 0.3));
                gg.addColorStop(1, rgba(COL_GLASS_AMBER, 0));
                ctx.fillStyle = gg;
                ctx.fillRect(W * 0.25, groundY - 2, W * 0.5, H * 0.06);
            }

            ctx.restore();
        }

        // ── Draw Phoenix ──
        function drawPhoenix(ctx, dt, energy, beatPulseVal) {
            if (phoenixAlpha < 0.02) return;

            var cx = W * 0.5;
            // phoenixY is 0..1 (0=near forge, 1=top of frame)
            var cy = H * 0.5 - phoenixY * H * 0.45;
            var sz = phoenixSize;
            var bp = beatPulseVal || 0;
            phoenixPhase += dt * 2.5;

            ctx.save();
            ctx.globalAlpha = phoenixAlpha;

            // Body glow — expands on beat
            var glowSz = sz * (3.5 + bp * 1.2);
            var pgr = ctx.createRadialGradient(cx, cy, 0, cx, cy, glowSz);
            pgr.addColorStop(0, rgba(COL_PHOENIX_HOT, 0.9 + bp * 0.1));
            pgr.addColorStop(0.2, rgba(COL_PHOENIX_GOLD, 0.5 + energy * 0.3 + bp * 0.2));
            pgr.addColorStop(0.5, rgba(COL_PHOENIX_DEEP, 0.2));
            pgr.addColorStop(1, rgba(COL_PHOENIX_DEEP, 0));
            ctx.fillStyle = pgr;
            var gr = glowSz;
            ctx.fillRect(cx - gr, cy - gr, gr * 2, gr * 2);

            // Wing shapes — built from arcs and fills
            var wingSpan = sz * (2.8 + bp * 0.5);   // wings spread wider on beat
            var wingBeats = Math.sin(phoenixPhase * 1.2) * 0.3 * sz + bp * sz * 0.25;

            function drawWing(side) {
                var sx = side * wingSpan;
                var wg = ctx.createLinearGradient(cx, cy, cx + sx, cy - sz * 1.2 + wingBeats);
                wg.addColorStop(0, rgba(COL_PHOENIX_HOT, 0.85));
                wg.addColorStop(0.4, rgba(COL_PHOENIX_GOLD, 0.5));
                wg.addColorStop(1, rgba(COL_PHOENIX_DEEP, 0.1));
                ctx.fillStyle = wg;
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.bezierCurveTo(
                    cx + sx * 0.3, cy - sz * 0.6 + wingBeats * 0.5,
                    cx + sx * 0.7, cy - sz * 1.0 + wingBeats,
                    cx + sx, cy - sz * 0.5 + wingBeats
                );
                ctx.bezierCurveTo(
                    cx + sx * 0.8, cy + sz * 0.3,
                    cx + sx * 0.4, cy + sz * 0.5,
                    cx, cy + sz * 0.3
                );
                ctx.closePath();
                ctx.fill();
                // Feather tips
                for (var fi = 0; fi < 5; fi++) {
                    var ft = (fi + 0.5) / 5;
                    var fx = cx + sx * ft;
                    var fy = cy - sz * 0.8 * Math.sin(ft * Math.PI) + wingBeats * ft;
                    ctx.beginPath();
                    ctx.moveTo(fx, fy);
                    ctx.lineTo(fx + side * sz * 0.15, fy - sz * 0.4 - fi * sz * 0.05);
                    ctx.lineTo(fx + side * sz * 0.05, fy + sz * 0.1);
                    ctx.closePath();
                    ctx.fillStyle = rgba(COL_PHOENIX_HOT, 0.6);
                    ctx.fill();
                }
            }

            ctx.globalAlpha = phoenixAlpha;
            drawWing(1);
            drawWing(-1);

            // Central body glow
            var bg2 = ctx.createRadialGradient(cx, cy, 0, cx, cy, sz * 1.2);
            bg2.addColorStop(0, rgba('#ffffff', 0.95));
            bg2.addColorStop(0.3, rgba(COL_PHOENIX_HOT, 0.8));
            bg2.addColorStop(0.7, rgba(COL_PHOENIX_GOLD, 0.4));
            bg2.addColorStop(1, rgba(COL_PHOENIX_DEEP, 0));
            ctx.fillStyle = bg2;
            ctx.beginPath();
            ctx.arc(cx, cy, sz * 1.2, 0, Math.PI * 2);
            ctx.fill();

            // Tail streaming downward
            var tailLen = sz * 2.5 + energy * sz;
            var tailG = ctx.createLinearGradient(cx, cy, cx, cy + tailLen);
            tailG.addColorStop(0, rgba(COL_PHOENIX_GOLD, 0.7));
            tailG.addColorStop(0.5, rgba(COL_PHOENIX_DEEP, 0.3));
            tailG.addColorStop(1, rgba(COL_PHOENIX_DEEP, 0));
            ctx.fillStyle = tailG;
            ctx.beginPath();
            ctx.moveTo(cx - sz * 0.2, cy + sz * 0.3);
            ctx.bezierCurveTo(
                cx + Math.sin(phoenixPhase * 0.7) * sz * 0.5, cy + tailLen * 0.4,
                cx + Math.sin(phoenixPhase * 0.9 + 1) * sz * 0.3, cy + tailLen * 0.7,
                cx + Math.sin(phoenixPhase * 0.5 + 2) * sz * 0.2, cy + tailLen
            );
            ctx.lineTo(cx + sz * 0.2, cy + sz * 0.3);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        // ── Draw Ghost Image (grief — faint inverted orb memory) ──
        function drawGhostOrb(ctx) {
            if (ghostAlpha < 0.01) return;
            var cx = W * 0.5;
            var cy = H * 0.45;
            var r = glassOrbR > 0 ? glassOrbR : H * 0.1;

            ctx.save();
            ctx.globalAlpha = ghostAlpha;
            var gg = ctx.createRadialGradient(cx, cy, 0, cx, cy, r * 1.5);
            gg.addColorStop(0, rgba(COL_GRIEF_BLUE, 0.5));
            gg.addColorStop(0.5, rgba('#302040', 0.2));
            gg.addColorStop(1, rgba('#200030', 0));
            ctx.fillStyle = gg;
            ctx.beginPath();
            ctx.arc(cx, cy, r * 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        // ── Draw Title + Subtitle ──
        function drawTitle(ctx) {
            if (titleAlpha < 0.01 && subtitleAlpha < 0.01) return;
            ctx.save();

            if (titleAlpha > 0.01) {
                var titleSize = Math.round(H * 0.055);
                ctx.font = 'bold ' + titleSize + 'px Cinzel, serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.globalAlpha = titleAlpha * outroFade;
                ctx.shadowColor = rgba(COL_GLOW, 0.7);
                ctx.shadowBlur = 24;
                ctx.fillStyle = COL_GLOW;
                ctx.fillText("THE GLASSBLOWER'S PHOENIX", W * 0.5, H * 0.12);
            }

            if (subtitleAlpha > 0.01 && subtitleText) {
                var subSize = Math.round(H * 0.028);
                ctx.font = subSize + 'px Cinzel, serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.globalAlpha = subtitleAlpha * outroFade;
                ctx.shadowColor = rgba(COL_MOLTEN, 0.5);
                ctx.shadowBlur = 12;
                var subCol = (scene === 'grief') ? '#8888aa' :
                             (scene === 'phoenix' || scene === 'begin') ? COL_PHOENIX_GOLD : COL_GLOW;
                ctx.fillStyle = subCol;
                ctx.fillText(subtitleText, W * 0.5, H * 0.21);
            }

            ctx.restore();
        }

        // ── Draw Vignette ──
        function drawVignette(ctx, intensity) {
            var vg = ctx.createRadialGradient(W * 0.5, H * 0.5, H * 0.2, W * 0.5, H * 0.5, H * 0.9);
            vg.addColorStop(0, 'rgba(0,0,0,0)');
            vg.addColorStop(1, 'rgba(0,0,0,' + (intensity * 0.7).toFixed(2) + ')');
            ctx.fillStyle = vg;
            ctx.fillRect(0, 0, W, H);
        }

        // ── Draw Flash ──
        function drawFlash(ctx) {
            if (flashAlpha < 0.01) return;
            ctx.save();
            ctx.globalAlpha = flashAlpha;
            ctx.fillStyle = flashColor;
            ctx.fillRect(0, 0, W, H);
            ctx.restore();
        }

        // ── Main Render ──
        function render(frameData) {
            var ctx = frameData.ctx;
            var dt = frameData.dt || 1/60;
            var cursor = frameData.cursor;
            var beat = frameData.beatPulse;

            if (!cursor) {
                // Idle — static forge
                ctx.fillStyle = COL_BG_FORGE;
                ctx.fillRect(0, 0, W, H);
                drawForge(ctx, 0, dt);
                drawVignette(ctx, 0.7);
                return;
            }

            var seqIdx = cursor.seqIndex;
            var energy = analysis ? (analysis.energy[cursor.timelineIndex] || 0) : 0;
            elapsed = cursor.elapsed;
            sceneAge += dt;

            energySmooth = lerpExp(energySmooth, energy, 4, dt);
            glassPhase += dt;

            // ── Scene transitions ──
            var newScene = mapScene(seqIdx);
            if (seqIdx !== lastSeqIndex) {
                var oldScene = scene;
                scene = newScene;

                // Only reset sceneAge when the scene itself changes (not every seq step)
                if (scene !== lastScene) {
                    sceneAge = 0;
                    lastScene = scene;

                    // Transition effects (fire only on actual scene boundary)
                    if (scene === 'shatter' && oldScene !== 'shatter') {
                        flashAlpha = 0.85;
                        flashColor = '#ffffff';
                        shatterTriggered = false;
                    }
                    if (scene === 'begin' && oldScene === 'grief') {
                        flashAlpha = 0.15;
                        flashColor = COL_GLOW;
                    }
                    if (scene === 'phoenix' && oldScene === 'begin') {
                        flashAlpha = 0.4;
                        flashColor = COL_PHOENIX_HOT;
                    }
                }

                lastSeqIndex = seqIdx;
            }

            // ── Trigger shatter ──
            if (scene === 'shatter' && !shatterTriggered && sceneAge > 0.15) {
                spawnShatter();
                shatterTriggered = true;
                shatterGlowFade = 1.0;
                shakeIntensity = 12;   // hard camera shake on impact
                glassOrbR = 0;
                glassOrbRTarget = 0;
            }

            // ── Scene-specific targets ──
            if (scene === 'forge') {
                bgBrightness        = lerpExp(bgBrightness, 0.45 + elapsed * 0.05, 1.5, dt);
                glassOrbRTarget     = 0;
                glassColorTTarget   = 0;
                bgColdTTarget       = 0;
                skyOpenTTarget      = 0;
                starAlphaTarget     = 0;
                titleTarget         = elapsed > 1.5 ? 0.8 : 0;
                subtitleTarget      = elapsed > 2 ? 0.5 : 0;
                subtitleText        = SCENE_TEXTS['forge'];
                figureHunchTarget   = 0;
                figureVisibleTarget = 1;
                figureLeanTarget    = 0.5;
                rayAlphaTarget      = 0;
                ghostAlphaTarget    = 0;
                vignetteIntensity   = lerpExp(vignetteIntensity, 0.55, 2, dt);
                phoenixAlphaTarget  = 0;

            } else if (scene === 'gather') {
                bgBrightness        = lerpExp(bgBrightness, 0.7, 1.5, dt);
                glassOrbRTarget     = H * 0.055 + energySmooth * H * 0.02;
                glassColorTTarget   = 0.15;
                bgColdTTarget       = 0;
                skyOpenTTarget      = 0;
                starAlphaTarget     = 0;
                titleTarget         = 0.7;
                subtitleTarget      = 0.6;
                subtitleText        = SCENE_TEXTS['gather'];
                figureHunchTarget   = 0;
                figureVisibleTarget = 1;
                figureLeanTarget    = 0.7;
                rayAlphaTarget      = 0;
                ghostAlphaTarget    = 0;
                vignetteIntensity   = lerpExp(vignetteIntensity, 0.5, 2, dt);
                phoenixAlphaTarget  = 0;

            } else if (scene === 'shape') {
                bgBrightness        = lerpExp(bgBrightness, 0.85 + energySmooth * 0.15, 1.5, dt);
                var seqInPhase = seqIdx - 8;
                var phaseT = seqInPhase / 5;
                glassOrbRTarget     = H * (0.07 + phaseT * 0.06) + energySmooth * H * 0.03;
                glassColorTTarget   = 0.3 + phaseT * 0.4;
                bgColdTTarget       = 0;
                skyOpenTTarget      = 0;
                starAlphaTarget     = 0;
                titleTarget         = 0.5;
                subtitleTarget      = 0.7;
                subtitleText        = SCENE_TEXTS['shape'];
                figureHunchTarget   = 0;
                figureVisibleTarget = 1;
                figureLeanTarget    = 0.8;
                rayAlphaTarget      = 0.15 + energySmooth * 0.25;
                ghostAlphaTarget    = 0;
                vignetteIntensity   = lerpExp(vignetteIntensity, 0.4, 2, dt);
                phoenixAlphaTarget  = 0;

                // Occasional glass embers
                if (Math.random() < energySmooth * 0.3) {
                    var idx = Math.floor(Math.random() * EMBER_COUNT);
                    if (idx < EMBER_COUNT * 0.3) embers[idx] = makeGlassEmber();
                }

            } else if (scene === 'crucial') {
                bgBrightness        = lerpExp(bgBrightness, 0.95, 2, dt);
                glassOrbRTarget     = H * 0.145 + energySmooth * H * 0.04;
                glassColorTTarget   = 0.75 + energySmooth * 0.2;
                bgColdTTarget       = 0;
                skyOpenTTarget      = 0;
                starAlphaTarget     = 0;
                titleTarget         = 0.4;
                subtitleTarget      = 0.9;
                subtitleText        = SCENE_TEXTS['crucial'];
                figureHunchTarget   = 0;
                figureVisibleTarget = 1;
                figureLeanTarget    = 1.0;
                rayAlphaTarget      = 0.5 + energySmooth * 0.5;
                ghostAlphaTarget    = 0;
                vignetteIntensity   = lerpExp(vignetteIntensity, 0.4, 2, dt);
                phoenixAlphaTarget  = 0;

                // Screen shake for ascending intensity
                shakeIntensity = energySmooth * 2;

            } else if (scene === 'shatter') {
                // After shatter: dim gradually, not instantly — keep forge embers visible
                var shatterDimTarget = shatterTriggered ? (sceneAge < 3 ? 0.35 : 0.12) : 0.95;
                var shatterDimRate   = shatterTriggered ? 1.5 : 2;
                bgBrightness        = lerpExp(bgBrightness, shatterDimTarget, shatterDimRate, dt);
                glassOrbRTarget     = shatterTriggered ? 0 : H * 0.15;
                glassColorTTarget   = 0.8;
                bgColdTTarget       = shatterTriggered ? (sceneAge < 2 ? 0.15 : 0.35) : 0;
                skyOpenTTarget      = 0;
                starAlphaTarget     = 0;
                titleTarget         = 0;
                subtitleTarget      = shatterTriggered ? 0.5 : 0;
                subtitleText        = SCENE_TEXTS['shatter'];
                figureHunchTarget   = shatterTriggered ? 0.7 : 0.3;
                figureVisibleTarget = 1;
                figureLeanTarget    = -0.2;
                rayAlphaTarget      = 0;
                ghostAlphaTarget    = 0;
                shakeIntensity      = shatterTriggered ? 0 : (flashAlpha * 8);
                shatterGlowFade     = lerpExp(shatterGlowFade, 0, 0.3, dt);
                vignetteIntensity   = lerpExp(vignetteIntensity, 0.75, 1.5, dt);
                phoenixAlphaTarget  = 0;

            } else if (scene === 'grief') {
                bgBrightness        = lerpExp(bgBrightness, 0.08, 1, dt);
                glassOrbRTarget     = 0;
                glassColorTTarget   = 0.5;
                bgColdTTarget       = 0.8;
                skyOpenTTarget      = 0;
                starAlphaTarget     = 0;
                titleTarget         = 0;
                subtitleTarget      = 0.4;
                subtitleText        = SCENE_TEXTS['grief'];
                figureHunchTarget   = 0.9;
                figureVisibleTarget = 1;
                figureLeanTarget    = -0.3;
                rayAlphaTarget      = 0;
                ghostAlphaTarget    = 0.25 + Math.sin(elapsed * 0.5) * 0.1;
                shakeIntensity      = 0;
                vignetteIntensity   = lerpExp(vignetteIntensity, 0.95, 1, dt);
                phoenixAlphaTarget  = 0;

            } else if (scene === 'begin') {
                bgBrightness        = lerpExp(bgBrightness, 0.3 + energySmooth * 0.4, 1.5, dt);
                var beginT = Math.min(1, sceneAge / 20);
                glassOrbRTarget     = H * (0.025 + beginT * 0.1) + energySmooth * H * 0.025;
                glassColorTTarget   = 0.5 + beginT * 0.4;
                bgColdTTarget       = lerpExp(bgColdTTarget, 0, 1.5, dt);
                skyOpenTTarget      = beginT * 0.3;
                starAlphaTarget     = beginT * 0.2;
                titleTarget         = 0.3;
                subtitleTarget      = 0.7;
                subtitleText        = SCENE_TEXTS['begin'];
                figureHunchTarget   = 0;
                figureVisibleTarget = 1;
                figureLeanTarget    = 0.6;
                rayAlphaTarget      = beginT * 0.3 + energySmooth * 0.2;
                ghostAlphaTarget    = 0;
                shakeIntensity      = 0;
                vignetteIntensity   = lerpExp(vignetteIntensity, 0.7, 1.5, dt);
                phoenixAlphaTarget  = 0;

            } else if (scene === 'phoenix') {
                bgBrightness        = lerpExp(bgBrightness, 0.15, 1, dt);
                var phxT = Math.min(1, sceneAge / 30);
                glassOrbRTarget     = 0;
                glassColorTTarget   = 1;
                bgColdTTarget       = 0;
                skyOpenTTarget      = phxT;
                starAlphaTarget     = 0.3 + phxT * 0.7;
                titleTarget         = 0.6;
                subtitleTarget      = 0.8;
                subtitleText        = SCENE_TEXTS['phoenix'];
                figureHunchTarget   = 0;
                figureVisibleTarget = 0;
                rayAlphaTarget      = 0.4 + energySmooth * 0.5;
                ghostAlphaTarget    = 0;
                shakeIntensity      = 0;
                vignetteIntensity   = lerpExp(vignetteIntensity, 0.6, 1, dt);

                // Phoenix ascends
                phoenixYTarget      = phxT * 0.9;
                phoenixSizeTarget   = H * (0.06 + phxT * 0.05);
                phoenixAlphaTarget  = Math.min(1, sceneAge * 0.3);
                // Outro: fade over the last ~15s of the phoenix scene (sceneAge > 45s)
                outroFade           = sceneAge > 45 ? Math.max(0, 1 - (sceneAge - 45) / 12) : 1;
            }

            // ── Beat-triggered effects ──
            if (frameData.beatChanged) {
                if (scene === 'shatter' && !shatterTriggered) {
                    // Already handled by trigger
                }
                if (scene === 'crucial') {
                    flashAlpha = Math.max(flashAlpha, 0.08 + energySmooth * 0.12);
                    flashColor = COL_GLASS_BRIGHT;
                }
                if (scene === 'phoenix') {
                    flashAlpha = Math.max(flashAlpha, energySmooth * 0.15);
                    flashColor = COL_PHOENIX_HOT;
                    // Burst of phoenix embers on beat
                    var pec = Math.floor(energySmooth * 20);
                    for (var pi = 0; pi < pec; pi++) {
                        var eidx = Math.floor(Math.random() * EMBER_COUNT);
                        embers[eidx] = makePhoenixEmber(W * 0.5, H * 0.5 - phoenixY * H * 0.45);
                    }
                }
                if (scene === 'begin' && energySmooth > 0.4) {
                    flashAlpha = Math.max(flashAlpha, energySmooth * 0.1);
                    flashColor = COL_GLOW;
                }
            }

            // ── Continuous phoenix trail (each frame, not just on beat) ──
            if (scene === 'phoenix' && phoenixAlpha > 0.1) {
                var trailRate = Math.floor(energySmooth * 3 + 1);
                for (var tri = 0; tri < trailRate; tri++) {
                    var teidx = Math.floor(Math.random() * EMBER_COUNT);
                    embers[teidx] = makePhoenixEmber(W * 0.5, H * 0.5 - phoenixY * H * 0.45);
                }
            }

            // ── Smooth all animatables ──
            flashAlpha          = lerpExp(flashAlpha, 0, 7, dt);
            glassOrbR           = lerpExp(glassOrbR, glassOrbRTarget, 3, dt);
            glassColorT         = lerpExp(glassColorT, glassColorTTarget, 2, dt);
            bgColdT             = lerpExp(bgColdT, bgColdTTarget, 2, dt);
            skyOpenT            = lerpExp(skyOpenT, skyOpenTTarget, 1.5, dt);
            starAlpha           = lerpExp(starAlpha, starAlphaTarget, 2, dt);
            titleAlpha          = lerpExp(titleAlpha, titleTarget, 2.5, dt);
            subtitleAlpha       = lerpExp(subtitleAlpha, subtitleTarget, 3, dt);
            figureHunch         = lerpExp(figureHunch, figureHunchTarget, 2, dt);
            figureVisible       = lerpExp(figureVisible, figureVisibleTarget, 2, dt);
            figureLeanAngle     = lerpExp(figureLeanAngle, figureLeanTarget, 2, dt);
            rayAlpha            = lerpExp(rayAlpha, rayAlphaTarget, 3, dt);
            ghostAlpha          = lerpExp(ghostAlpha, ghostAlphaTarget, 2, dt);
            phoenixY            = lerpExp(phoenixY, phoenixYTarget, 1.5, dt);
            phoenixSize         = lerpExp(phoenixSize, phoenixSizeTarget, 2, dt);
            phoenixAlpha        = lerpExp(phoenixAlpha, phoenixAlphaTarget, 2, dt);

            // ── Intro fade ──
            if (elapsed < 2) {
                introFade = elapsed / 2;
            } else {
                introFade = 1;
            }

            // ── Screen shake ──
            var sx = 0, sy = 0;
            if (shakeIntensity > 0.01) {
                sx = (Math.random() - 0.5) * shakeIntensity * 4;
                sy = (Math.random() - 0.5) * shakeIntensity * 4;
                shakeIntensity *= Math.exp(-3 * dt);
            }

            // ── Compositing (back to front) ──
            ctx.save();
            if (sx !== 0 || sy !== 0) ctx.translate(sx, sy);

            // 1. Background
            drawBackground(ctx);

            // 2. Stars
            drawStars(ctx, dt);

            // 3. Ghost orb (grief memory)
            drawGhostOrb(ctx);

            // 4. Light rays (behind orb)
            drawLightRays(ctx, energy);

            // 5. Glass orb
            drawGlassOrb(ctx, dt, energy, beat);

            // 6. Fragments (shatter)
            drawFragments(ctx, dt, energy);

            // 7. Phoenix
            drawPhoenix(ctx, dt, energy, beat);

            // 8. Embers
            drawEmbers(ctx, dt, energy);

            // 9. Forge
            drawForge(ctx, energy, dt, beat);

            // 10. Figure
            drawFigure(ctx, energy);

            // 11. Vignette
            drawVignette(ctx, vignetteIntensity);

            // 12. Title / subtitle
            drawTitle(ctx);

            // 13. Flash
            drawFlash(ctx);

            ctx.restore();

            // 14. Intro fade-in
            if (introFade < 1) {
                ctx.save();
                ctx.globalAlpha = 1 - introFade;
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, W, H);
                ctx.restore();
            }

            // 15. Outro fade
            if (outroFade < 1) {
                ctx.save();
                ctx.globalAlpha = 1 - outroFade;
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, W, H);
                ctx.restore();
            }
        }

        BaseRenderer('the-glassblowers-phoenix-video', "The Glassblower's Phoenix", {
            beatDecay: 6,
            init: init,
            render: render,
            resize: resize
        });
    })();

    // ── Page bootstrap ──
    (function() {
        var canvas = document.getElementById('viz-canvas');
        var overlay = document.getElementById('play-overlay');

        Visualizer.init(canvas);
        Visualizer.setRenderer('the-glassblowers-phoenix-video');

        function loadAndPlay(json) {
            Visualizer.loadSong(json);
            Visualizer.play();
        }

        function fetchSong() {
            var url = '../audio-tracker/songs/the-glassblowers-phoenix.json';
            if (window.fetch && location.protocol !== 'file:') {
                return fetch(url).then(function(r) { return r.json(); });
            }
            return new Promise(function(resolve, reject) {
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.onload = function() {
                    if (xhr.status === 200 || xhr.status === 0) {
                        resolve(JSON.parse(xhr.responseText));
                    } else {
                        reject(new Error('XHR failed: ' + xhr.status));
                    }
                };
                xhr.onerror = function() { reject(new Error('XHR error')); };
                xhr.send();
            });
        }

        overlay.addEventListener('click', function() {
            overlay.classList.add('hidden');
            fetchSong().then(loadAndPlay).catch(function(err) {
                console.error('Failed to load song:', err);
                overlay.classList.remove('hidden');
            });
        });

        // Auto-play when embedded (e.g. jukebox iframe with ?autoplay=1)
        if (new URLSearchParams(window.location.search).get('autoplay') === '1') {
            overlay.click();
        }

        canvas.addEventListener('click', function() {
            if (overlay.classList.contains('hidden')) {
                if (Visualizer.isPlaying()) {
                    Visualizer.stop();
                } else {
                    Visualizer.play();
                }
            }
        });
    })();
    </script>
</body>
</html>
