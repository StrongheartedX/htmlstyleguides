<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WAP — Wireless Access Protocol Music Video</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background: #0a0a12;
            color: #fff;
            font-family: 'JetBrains Mono', monospace;
        }
        #viz-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: block;
            cursor: pointer;
        }
        .play-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            background: rgba(10,10,18,0.92);
            cursor: pointer;
            transition: opacity 0.5s;
        }
        .play-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .play-title {
            font-size: clamp(20px, 5vw, 48px);
            font-weight: 700;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #ff2d95;
            text-shadow: 0 0 30px rgba(255,45,149,0.6), 0 0 60px rgba(255,45,149,0.3);
            margin-bottom: 12px;
        }
        .play-sub {
            font-size: clamp(12px, 2vw, 18px);
            color: rgba(255,255,255,0.5);
            margin-bottom: 40px;
        }
        .play-btn {
            width: 80px; height: 80px;
            border: 3px solid #ff2d95;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: pulse 2s ease-in-out infinite;
        }
        .play-btn::after {
            content: '';
            display: block;
            width: 0; height: 0;
            border-style: solid;
            border-width: 18px 0 18px 30px;
            border-color: transparent transparent transparent #ff2d95;
            margin-left: 6px;
        }
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(255,45,149,0.4); }
            50% { box-shadow: 0 0 0 20px rgba(255,45,149,0); }
        }
        .back-link {
            position: fixed;
            top: 12px; left: 12px;
            z-index: 30;
            color: rgba(255,255,255,0.4);
            text-decoration: none;
            font-size: 13px;
            padding: 6px 10px;
            border-radius: 6px;
            background: rgba(0,0,0,0.4);
            transition: color 0.2s;
        }
        .back-link:hover { color: rgba(255,255,255,0.8); }
    </style>
</head>
<body>
    <a href="music-videos/index.html" class="back-link">← Music Videos</a>
    <canvas id="viz-canvas"></canvas>
    <div class="play-overlay" id="play-overlay">
        <div class="play-title">Wireless Access Protocol</div>
        <div class="play-sub">a stick figure music video</div>
        <div class="play-btn"></div>
    </div>

    <script src="../audio-tracker/playback-engine.js"></script>
    <script src="engine.js"></script>
    <script src="stick-fight-engine.js"></script>
    <script>
    // ── WAP Video Renderer ──────────────────────────────────────────
    window.Renderers['wap-video'] = (function() {
        "use strict";

        var W = 0, H = 0;
        var analysis = null;

        // ── Tunables ──
        var BG = '#0a0a12';
        var FLOOR_Y_RATIO = 0.82;
        var POLE_HEIGHT_RATIO = 0.55;

        // Figure colors
        var COLORS = {
            poleDancer1: '#ff2d95',  // hot pink
            poleDancer2: '#00e5ff',  // cyan
            floor1: '#ffea00',       // yellow
            floor2: '#ff4444',       // red
            floor3: '#448aff'        // blue
        };

        var SPOTLIGHT_COLORS = ['#ff2d95', '#00e5ff', '#ffea00', '#ff4444', '#448aff', '#aa44ff'];

        // ── State ──
        var floorY = 0;
        var poleH = 0;
        var poleX1 = 0, poleX2 = 0;
        var lastBeat = -1;
        var beatPulse = 0;
        var flashAlpha = 0;
        var spotlightPhase = 0;
        var titleAlpha = 0;
        var titleTarget = 0;

        // Section state
        var sectionMood = 'intro';  // intro, verse, hook, bridge, build, outro
        var sectionEnergy = 0;
        var introFadeIn = 0;
        var outroFadeOut = 1;
        var freezeTimer = 0;
        var freezeExplode = false;
        var lastSeqIndex = -1;

        // ── Club Scene State ──
        var beams = [];
        var particles = [];
        var crowd = [];
        var floorGridPhase = 0;

        // ── Figure State ──
        var figures = [];

        // Custom overlay params that StickFight doesn't handle
        function createOverlayParams() {
            return {
                hairWhip: 0,
                hairWhipDir: 1,
                headBang: 0,
                hipThrust: 0,
                windmillAngle: 0
            };
        }

        function createPoleDancer(color, poleX, phaseOffset) {
            var fig = StickFight.create({
                x: poleX,
                y: 0,  // will be positioned dynamically
                figH: 100, // set in render
                facing: 1,
                color: color,
                lineWidth: 3,
                poseSpeed: 12
            });
            fig.type = 'pole';
            fig.poleX = poleX;
            fig.phaseOffset = phaseOffset;
            fig.orbitAngle = phaseOffset;
            fig.orbitSpeed = 1.8;
            fig.slideY = 0.5;
            fig.slideTarget = 0.5;
            fig.hangMode = false;
            fig.upsideDown = false;
            fig.kickSpin = 0;
            fig.active = false;
            fig.overlay = createOverlayParams();
            StickFight.setPose(fig, 'idle');
            return fig;
        }

        function createFloorDancer(color, xPos) {
            var fig = StickFight.create({
                x: xPos,
                y: 0,  // set in render
                figH: 100, // set in render
                facing: 1,
                color: color,
                lineWidth: 3,
                poseSpeed: 12
            });
            fig.type = 'floor';
            fig.currentMove = 'BasicBounce';
            fig.moveBeatCounter = 0;
            fig.splitsBeatTimer = 0;
            fig.active = false;
            fig.overlay = createOverlayParams();
            StickFight.setPose(fig, 'idle');
            return fig;
        }

        // ── Move Pool for Floor Dancers ──
        // Move functions now set StickFight targets + overlay params on the figure
        var MOVES = {
            BasicBounce: function(fig, e) {
                StickFight.setPose(fig, 'dance_basic');
                StickFight.setTarget(fig, 'bounce', 0.3 + e * 0.3);
            },
            ArmPump: function(fig, e) {
                StickFight.setPose(fig, 'dance_basic');
                StickFight.setTarget(fig, 'bounce', 0.2);
                var side = Math.random() > 0.5 ? 1 : -1;
                if (side > 0) {
                    StickFight.setTarget(fig, 'armRAngle', -1.0 * (0.8 + e * 0.2));
                    StickFight.setTarget(fig, 'elbowRBend', 0.6);
                } else {
                    StickFight.setTarget(fig, 'armLAngle', -1.0 * (0.8 + e * 0.2));
                    StickFight.setTarget(fig, 'elbowLBend', 0.6);
                }
            },
            HipThrust: function(fig, e) {
                StickFight.setPose(fig, 'dance_basic');
                StickFight.setTarget(fig, 'bounce', 0.15);
                var lean = (Math.random() - 0.5) * 0.3;
                StickFight.setTarget(fig, 'lean', lean + (0.6 + e * 0.4) * 0.3);
                fig.overlay.hairWhip = 0.4;
                fig.overlay.hairWhipDir = lean > 0 ? -1 : 1;
            },
            Windmill: function(fig, e) {
                StickFight.setPose(fig, 'dance_basic');
                StickFight.setTarget(fig, 'bounce', 0.1);
                // Windmill arms via direct angle manipulation
                var wa = fig.overlay.windmillAngle;
                StickFight.setTarget(fig, 'armLAngle', wa);
                StickFight.setTarget(fig, 'armRAngle', wa + Math.PI);
                StickFight.setTarget(fig, 'elbowLBend', 0.1);
                StickFight.setTarget(fig, 'elbowRBend', 0.1);
                fig.overlay.hairWhip = 0.6;
                fig.overlay.hairWhipDir = 1;
            },
            RunningMan: function(fig, e) {
                var kickSide = Math.random() > 0.5 ? 1 : -1;
                StickFight.setPose(fig, 'kick');
                StickFight.setTarget(fig, 'kneeL', kickSide > 0 ? 0 : -(0.5 + e * 0.3));
                StickFight.setTarget(fig, 'kneeR', kickSide > 0 ? -(0.5 + e * 0.3) : 0);
                StickFight.setTarget(fig, 'legSpread', 0.3);
                if (kickSide > 0) {
                    StickFight.setTarget(fig, 'armLAngle', -0.8);
                } else {
                    StickFight.setTarget(fig, 'armRAngle', -0.8);
                }
            },
            HeadBang: function(fig, e) {
                StickFight.setPose(fig, 'dance_basic');
                StickFight.setTarget(fig, 'bounce', 0.25);
                StickFight.setTarget(fig, 'lean', 0.4 + e * 0.3);
                fig.overlay.headBang = 0.7 + e * 0.3;
                fig.overlay.hairWhip = 0.9;
                fig.overlay.hairWhipDir = Math.random() > 0.5 ? 1 : -1;
            },
            Splits: function(fig, e) {
                StickFight.setPose(fig, 'idle');
                StickFight.setTarget(fig, 'legSpread', 0.9);
                StickFight.setTarget(fig, 'bounce', -0.1);
            },
            FreezeFrame: function(fig, e) {
                StickFight.setPose(fig, 'arms_up');
                StickFight.setTarget(fig, 'lean', (Math.random() - 0.5) * 0.6);
                StickFight.setTarget(fig, 'kneeL', -0.3);
            }
        };

        var MOVE_NAMES = Object.keys(MOVES);

        // Weighted move selection based on energy
        function pickMove(energy) {
            if (sectionMood === 'bridge') return 'BasicBounce';
            var weights;
            if (energy > 0.7) {
                weights = { BasicBounce: 1, ArmPump: 4, HipThrust: 3, Windmill: 3, RunningMan: 3, HeadBang: 3, Splits: 1, FreezeFrame: 2 };
            } else if (energy > 0.4) {
                weights = { BasicBounce: 3, ArmPump: 3, HipThrust: 2, Windmill: 1, RunningMan: 2, HeadBang: 2, Splits: 0, FreezeFrame: 1 };
            } else {
                weights = { BasicBounce: 5, ArmPump: 1, HipThrust: 1, Windmill: 0, RunningMan: 1, HeadBang: 1, Splits: 0, FreezeFrame: 0 };
            }
            var total = 0;
            for (var k in weights) total += weights[k];
            var r = Math.random() * total;
            var acc = 0;
            for (var k2 in weights) {
                acc += weights[k2];
                if (r <= acc) return k2;
            }
            return 'BasicBounce';
        }

        // ── Lerp helper (for overlay params) ──
        function lerpParam(current, target, speed, dt) {
            return current + (target - current) * (1 - Math.exp(-speed * dt));
        }

        function updateOverlayParams(fig, dt) {
            var o = fig.overlay;
            o.hairWhip = lerpParam(o.hairWhip, 0, 6, dt);
            o.headBang = lerpParam(o.headBang, 0, 6, dt);
            o.windmillAngle += dt * 8; // continuous spin
        }

        // ── Draw a figure with overlays (hair, clothing, face) ──
        // Uses StickFight for skeleton, then draws custom overlays on top
        function drawFigureWithOverlays(ctx, fig, alpha, scaleX) {
            scaleX = scaleX || 1;
            var color = fig.color;
            var joints = StickFight.computeJoints(fig);
            var hr = joints.headR;
            var o = fig.overlay || {};

            var lean = fig.params.lean || 0;
            var headBang = o.headBang || 0;
            var whip = o.hairWhip || 0;
            var whipDir = o.hairWhipDir || 1;
            var hairSwing = -lean * 0.4 - headBang * 0.6 + whip * whipDir * 2.2;

            // Joint positions scaled by scaleX for pole-dancer foreshortening
            var hx = joints.head.x * scaleX;
            var hy = joints.head.y;

            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.shadowBlur = 12;
            ctx.shadowColor = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;

            // --- HAIR (BACK LAYER) ---
            function drawHairStrands(count, startRange, lengthMult, strandAlpha) {
                var baseLen = hr * (2.8 + whip * 2.2);
                for (var si = 0; si < count; si++) {
                    var t = si / (count - 1);
                    var spread = startRange[0] + (startRange[1] - startRange[0]) * t;
                    var startAngle = -Math.PI * 0.5 + spread;
                    var sX = hx + Math.cos(startAngle) * hr * 0.85;
                    var sY = hy + Math.sin(startAngle) * hr * 0.75;

                    var strandLen = baseLen * lengthMult * (0.7 + Math.abs(t - 0.5) * 0.6);
                    var fAng = Math.PI * 0.5 + spread * 0.2 + hairSwing;

                    var eX = sX + Math.cos(fAng) * strandLen;
                    var eY = sY + Math.sin(fAng) * strandLen;

                    var cX = sX + Math.cos(fAng) * strandLen * 0.5 + hairSwing * hr;
                    var cY = sY + Math.sin(fAng) * strandLen * 0.5;

                    ctx.globalAlpha = alpha * strandAlpha;
                    ctx.beginPath();
                    ctx.moveTo(sX, sY);
                    ctx.quadraticCurveTo(cX, cY, eX, eY);
                    ctx.stroke();
                }
            }

            drawHairStrands(10, [-1.2, 1.2], 1.0, 0.4); // Back hair

            function line(a, b) {
                ctx.beginPath();
                ctx.moveTo(a.x * scaleX, a.y);
                ctx.lineTo(b.x * scaleX, b.y);
                ctx.stroke();
            }

            // Torso — hourglass curve (overlay on top of skeleton)
            var waistY = (joints.neck.y + joints.hip.y) * 0.55;
            var waistX = (joints.neck.x + joints.hip.x) * 0.5 * scaleX;
            var neckSX = joints.neck.x * scaleX;
            var hipSX = joints.hip.x * scaleX;
            var hipSpread = hr * 0.9;

            // --- CLOTHING FILLS ---
            ctx.fillStyle = color;
            ctx.globalAlpha = alpha * 0.25;
            // Bikini bottom
            ctx.beginPath();
            ctx.moveTo(waistX - hr * 0.3 * scaleX, waistY + (joints.hip.y - waistY) * 0.4);
            ctx.lineTo(waistX + hr * 0.3 * scaleX, waistY + (joints.hip.y - waistY) * 0.4);
            ctx.lineTo(hipSX + hipSpread * scaleX, joints.hip.y);
            ctx.lineTo(hipSX - hipSpread * scaleX, joints.hip.y);
            ctx.closePath();
            ctx.fill();
            // Bikini top
            var chestY = joints.neck.y + (waistY - joints.neck.y) * 0.4;
            ctx.beginPath();
            ctx.arc(waistX - hr * 0.45 * scaleX, chestY, hr * 0.35, 0, Math.PI * 2);
            ctx.arc(waistX + hr * 0.45 * scaleX, chestY, hr * 0.35, 0, Math.PI * 2);
            ctx.fill();

            // Hourglass torso curves
            ctx.globalAlpha = alpha;
            ctx.beginPath();
            ctx.moveTo(neckSX, joints.neck.y);
            ctx.quadraticCurveTo(waistX - hipSpread * 0.2 * scaleX, waistY, hipSX - hipSpread * scaleX, joints.hip.y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(neckSX, joints.neck.y);
            ctx.quadraticCurveTo(waistX + hipSpread * 0.2 * scaleX, waistY, hipSX + hipSpread * scaleX, joints.hip.y);
            ctx.stroke();

            // Limbs via StickFight joint positions
            line(joints.shoulderL, joints.shoulderR);
            line(joints.shoulderL, joints.elbowL);
            line(joints.elbowL, joints.handL);
            line(joints.shoulderR, joints.elbowR);
            line(joints.elbowR, joints.handR);
            line(joints.hip, joints.kneeL);
            line(joints.kneeL, joints.ankleL);
            line(joints.hip, joints.kneeR);
            line(joints.kneeR, joints.ankleR);

            // Head Circle
            ctx.beginPath();
            ctx.arc(hx, hy, hr, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = color;
            ctx.globalAlpha = alpha * 0.3;
            ctx.fill();

            // --- FACE ---
            var faceScale = hr / 8;
            ctx.lineWidth = Math.max(1, faceScale * 1.2);
            ctx.globalAlpha = alpha;
            // Eyebrows
            ctx.beginPath();
            ctx.moveTo(hx - hr * 0.4, hy - hr * 0.3);
            ctx.lineTo(hx - hr * 0.1, hy - hr * 0.4);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(hx + hr * 0.1, hy - hr * 0.45);
            ctx.lineTo(hx + hr * 0.4, hy - hr * 0.25);
            ctx.stroke();
            // Eyes
            ctx.fillStyle = color;
            ctx.beginPath(); ctx.arc(hx - hr * 0.25, hy - hr * 0.05, faceScale, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(hx + hr * 0.25, hy - hr * 0.05, faceScale, 0, Math.PI*2); ctx.fill();
            // Smirk
            ctx.beginPath();
            ctx.moveTo(hx - hr * 0.1, hy + hr * 0.3);
            ctx.quadraticCurveTo(hx + hr * 0.2, hy + hr * 0.35, hx + hr * 0.35, hy + hr * 0.15);
            ctx.stroke();

            // --- HAIR (FRONT LAYER / BANGS) ---
            drawHairStrands(5, [-0.8, 0.8], 0.4, 0.8);

            ctx.restore();
        }

        // ── Pole dancer compute & draw ──
        function updatePoleDancer(fig, dt, beat, energy, fractionalBeat) {
            // Speed multiplier per section
            var speedMult = sectionMood === 'hook' ? 1.5 : sectionMood === 'build' ? 2.0 : sectionMood === 'bridge' ? 0.4 : 1.0;
            fig.orbitAngle += fig.orbitSpeed * energy * speedMult * dt;

            // Slide target changes on beats
            if (beat !== lastBeat) {
                if (sectionMood === 'hook' || sectionMood === 'build') {
                    fig.slideTarget = 0.2 + Math.random() * 0.6;
                    fig.hangMode = Math.random() > 0.5;
                    fig.upsideDown = sectionMood === 'hook' && Math.random() > 0.92;
                    fig.kickSpin = Math.random() > 0.4 ? 1 : 0;
                } else if (sectionMood === 'bridge') {
                    fig.slideTarget = 0.4 + Math.random() * 0.2;
                    fig.hangMode = false;
                    fig.upsideDown = false;
                    fig.kickSpin = 0;
                } else {
                    fig.slideTarget = 0.3 + Math.random() * 0.5;
                    fig.hangMode = Math.random() > 0.7;
                    fig.upsideDown = false;
                    fig.kickSpin = Math.random() > 0.6 ? 0.5 : 0;
                }
            }

            fig.slideY = lerpParam(fig.slideY, fig.slideTarget, 4, dt);

            // Pose targets via StickFight
            StickFight.setTarget(fig, 'bounce', 0.1);
            StickFight.setTarget(fig, 'lean', Math.sin(fig.orbitAngle * 0.5) * 0.3);

            if (fig.hangMode) {
                StickFight.setPose(fig, 'arms_up');
            } else {
                StickFight.setPose(fig, 'dance_basic');
                StickFight.setTarget(fig, 'armLAngle', -0.3);
                StickFight.setTarget(fig, 'armRAngle', -0.3);
            }

            if (fig.kickSpin > 0.3) {
                var kickSide = Math.sin(fig.orbitAngle) > 0 ? 1 : -1;
                StickFight.setTarget(fig, 'kneeL', kickSide < 0 ? -fig.kickSpin * 0.6 : 0);
                StickFight.setTarget(fig, 'kneeR', kickSide > 0 ? -fig.kickSpin * 0.6 : 0);
                StickFight.setTarget(fig, 'legSpread', 0.3);
                fig.overlay.hairWhip = 0.7;
                fig.overlay.hairWhipDir = kickSide;
            } else {
                fig.overlay.hairWhip = lerpParam(fig.overlay.hairWhip, 0, 6, dt);
            }

            if (fig.upsideDown) {
                StickFight.setPose(fig, 'kick');
                StickFight.setTarget(fig, 'legSpread', 0.4);
                fig.overlay.hairWhip = 1.0;
            }

            // Update figure via StickFight engine
            if (freezeTimer > 0) {
                fig.poseSpeed = 0.5;
            } else {
                fig.poseSpeed = 12;
            }
            StickFight.updateFigure(fig, dt);
            updateOverlayParams(fig, dt);
        }

        function drawPoleDancer(ctx, fig) {
            if (!fig.active) return;

            var poleTop = floorY - poleH;
            var figY = poleTop + fig.slideY * poleH;

            // Faux-3D: orbit around pole
            var cosA = Math.cos(fig.orbitAngle);
            var sinA = Math.sin(fig.orbitAngle);
            var orbitR = W * 0.025;
            var figX = fig.poleX + sinA * orbitR;

            // Foreshortening: scale X based on how much figure faces camera
            var scaleX = 0.3 + Math.abs(cosA) * 0.7;

            // Depth: behind pole when cos < 0
            var behind = cosA < 0;

            fig.figH = H * 0.16;

            ctx.save();
            ctx.translate(figX, figY);
            if (fig.upsideDown) ctx.scale(1, -1);

            drawFigureWithOverlays(ctx, fig, behind ? 0.5 : 1.0, scaleX);

            ctx.restore();

            return behind;
        }

        // ── Floor dancer compute & draw ──
        function updateFloorDancer(fig, dt, beat, energy) {
            if (beat !== lastBeat) {
                fig.moveBeatCounter++;

                // Splits snap-back: hold 4 beats then SNAP up in 1
                if (fig.currentMove === 'Splits') {
                    fig.splitsBeatTimer++;
                    if (fig.splitsBeatTimer >= 4) {
                        fig.currentMove = 'ArmPump';
                        fig.moveBeatCounter = 0;
                        fig.splitsBeatTimer = 0;
                    }
                } else {
                    fig.splitsBeatTimer = 0;
                }

                // Change move every 2-4 beats (unless mid-splits)
                var interval = sectionMood === 'hook' ? 2 : 4;
                if (fig.moveBeatCounter >= interval && fig.currentMove !== 'Splits') {
                    fig.currentMove = pickMove(energy);
                    fig.moveBeatCounter = 0;
                    if (fig.currentMove === 'Splits') fig.splitsBeatTimer = 0;
                }

                // Apply move via StickFight
                if (freezeTimer <= 0) {
                    MOVES[fig.currentMove](fig, energy);
                }
            }

            // Update pose speed based on freeze
            if (freezeTimer > 0) {
                fig.poseSpeed = 0.5;
            } else {
                fig.poseSpeed = 12;
            }
            StickFight.updateFigure(fig, dt);
            updateOverlayParams(fig, dt);
        }

        function drawFloorDancer(ctx, fig) {
            if (!fig.active) return;

            fig.figH = H * 0.18;
            fig.y = floorY;

            ctx.save();
            ctx.translate(fig.x, floorY);
            drawFigureWithOverlays(ctx, fig, 1.0, 1.0);
            ctx.restore();
        }

        // ── Spotlights ──
        function drawSpotlights(ctx, beat, energy) {
            var numSpots = 5;
            var spotW = W / numSpots;
            var brightness = 0.06 + energy * 0.1 + beatPulse * 0.08;

            if (sectionMood === 'intro') brightness *= introFadeIn;
            if (sectionMood === 'bridge') brightness *= 0.4;
            if (sectionMood === 'build') brightness *= 1.5;
            // Final hook strobes
            if (sectionMood === 'hook' && lastSeqIndex >= 36) brightness *= 1.3;

            for (var i = 0; i < numSpots; i++) {
                var cx = spotW * (i + 0.5);
                var colorIdx = (i + Math.floor(spotlightPhase)) % SPOTLIGHT_COLORS.length;
                var col = SPOTLIGHT_COLORS[colorIdx];

                // Parse hex to rgb
                var r = parseInt(col.slice(1,3), 16);
                var g = parseInt(col.slice(3,5), 16);
                var b = parseInt(col.slice(5,7), 16);

                var grad = ctx.createLinearGradient(cx, 0, cx, floorY);
                grad.addColorStop(0, 'rgba(' + r + ',' + g + ',' + b + ',' + (brightness * 0.8) + ')');
                grad.addColorStop(1, 'rgba(' + r + ',' + g + ',' + b + ',0)');

                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.fillStyle = grad;

                // Cone shape
                var topW = spotW * 0.1;
                var botW = spotW * 0.7;
                ctx.beginPath();
                ctx.moveTo(cx - topW, 0);
                ctx.lineTo(cx + topW, 0);
                ctx.lineTo(cx + botW, floorY);
                ctx.lineTo(cx - botW, floorY);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
        }

        // ── Title Text ──
        // "WIRELESS ACCESS PROTOCOL" with W, A, P bolded/scaled
        var TITLE_WORDS = ['WIRELESS', ' ', 'ACCESS', ' ', 'PROTOCOL'];
        var BOLD_LETTERS = { W: true, A: true, P: true };

        function drawTitle(ctx) {
            if (titleAlpha < 0.01) return;

            var baseFontSize = Math.max(14, Math.min(W * 0.038, 48));
            var bigFontSize = Math.floor(baseFontSize * 1.35);
            var y = H * 0.15;

            ctx.save();
            ctx.textBaseline = 'middle';

            // Measure total width first to center
            var totalW = 0;
            var chars = 'WIRELESS ACCESS PROTOCOL'.split('');
            for (var mi = 0; mi < chars.length; mi++) {
                var isBold = mi === 0 || mi === 9 || mi === 16; // W, A, P
                var fs = isBold ? bigFontSize : baseFontSize;
                ctx.font = '700 ' + fs + 'px "JetBrains Mono", monospace';
                totalW += ctx.measureText(chars[mi]).width;
            }

            var x = (W - totalW) / 2;

            // Draw each character
            for (var ci = 0; ci < chars.length; ci++) {
                var bold = ci === 0 || ci === 9 || ci === 16; // W, A, P positions
                var fs2 = bold ? bigFontSize : baseFontSize;
                ctx.font = '700 ' + fs2 + 'px "JetBrains Mono", monospace';
                var charW = ctx.measureText(chars[ci]).width;

                if (bold) {
                    // Big glowing WAP letters
                    ctx.globalAlpha = titleAlpha;
                    ctx.shadowColor = '#fff';
                    ctx.shadowBlur = 40;
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText(chars[ci], x, y);

                    // Pink glow layer
                    ctx.shadowColor = '#ff2d95';
                    ctx.shadowBlur = 60;
                    ctx.globalAlpha = titleAlpha * 0.8;
                    ctx.fillStyle = '#ff2d95';
                    ctx.fillText(chars[ci], x, y);
                } else {
                    // Normal letters
                    ctx.globalAlpha = titleAlpha * 0.85;
                    ctx.shadowColor = '#ff2d95';
                    ctx.shadowBlur = 20;
                    ctx.fillStyle = '#ff2d95';
                    ctx.fillText(chars[ci], x, y);
                }

                x += charW;
            }

            ctx.restore();
        }

        // ── Poles ──
        function drawPole(ctx, x) {
            var poleTop = floorY - poleH;
            var lw = 3;

            ctx.save();
            ctx.strokeStyle = 'rgba(200,200,220,0.6)';
            ctx.lineWidth = lw;
            ctx.shadowColor = 'rgba(200,200,220,0.3)';
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.moveTo(x, poleTop);
            ctx.lineTo(x, floorY);
            ctx.stroke();

            // Highlight
            ctx.strokeStyle = 'rgba(255,255,255,0.15)';
            ctx.lineWidth = lw * 0.3;
            ctx.beginPath();
            ctx.moveTo(x - lw * 0.3, poleTop);
            ctx.lineTo(x - lw * 0.3, floorY);
            ctx.stroke();
            ctx.restore();
        }

        // ── Stage floor ──
        function drawFloor(ctx, energy) {
            ctx.save();
            // Dark base
            ctx.fillStyle = '#05050a';
            ctx.fillRect(0, floorY, W, H - floorY);

            // Neon Grid
            ctx.strokeStyle = 'rgba(255,45,149,' + (0.05 + energy * 0.1) + ')';
            ctx.lineWidth = 1;
            // Perspective lines
            var numLines = 20;
            var vpX = W / 2;
            for (var i = 0; i <= numLines; i++) {
                var x = (i / numLines) * W;
                ctx.beginPath();
                ctx.moveTo(x, floorY);
                ctx.lineTo(vpX + (x - vpX) * 2.5, H);
                ctx.stroke();
            }
            // Horizontal lines
            for (var j = 0; j < 8; j++) {
                var y = floorY + (Math.pow(j/8, 1.5)) * (H - floorY);
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(W, y);
                ctx.stroke();
            }

            // Stage edge glow
            ctx.strokeStyle = '#ff2d95';
            ctx.lineWidth = 2;
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ff2d95';
            ctx.beginPath();
            ctx.moveTo(0, floorY);
            ctx.lineTo(W, floorY);
            ctx.stroke();
            
            // Reflection
            var grad = ctx.createLinearGradient(0, floorY, 0, floorY + H * 0.15);
            grad.addColorStop(0, 'rgba(255,45,149,0.08)');
            grad.addColorStop(1, 'rgba(255,45,149,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, floorY, W, H * 0.15);
            ctx.restore();
        }

        // ── Flash overlay ──
        function drawFlash(ctx) {
            if (flashAlpha < 0.01) return;
            ctx.save();
            ctx.globalAlpha = flashAlpha;
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, W, H);
            ctx.restore();
        }

        // ── Club Scene Helpers ──
        function initBeams() {
            beams = [];
            for (var i = 0; i < 6; i++) {
                beams.push({
                    x: Math.random() * W,
                    angle: (Math.random() - 0.5) * 0.8,
                    targetAngle: (Math.random() - 0.5) * 0.8,
                    color: SPOTLIGHT_COLORS[Math.floor(Math.random() * SPOTLIGHT_COLORS.length)],
                    speed: 0.1 + Math.random() * 0.3,
                    width: 40 + Math.random() * 60
                });
            }
        }

        function initParticles() {
            particles = [];
            for (var i = 0; i < 80; i++) {
                particles.push({
                    x: Math.random() * W,
                    y: Math.random() * H,
                    speed: 20 + Math.random() * 100,
                    size: 1 + Math.random() * 2,
                    alpha: 0.1 + Math.random() * 0.5
                });
            }
        }

        function initCrowd() {
            crowd = [];
            for (var i = 0; i < 40; i++) {
                crowd.push({
                    x: Math.random() * W,
                    y: floorY + 20 + Math.random() * (H - floorY),
                    size: 50 + Math.random() * 70,
                    phase: Math.random() * Math.PI * 2,
                    side: Math.random() > 0.5 ? 1 : -1
                });
            }
        }

        function drawBeams(ctx, energy) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            for (var i = 0; i < beams.length; i++) {
                var b = beams[i];
                var alpha = (0.05 + energy * 0.15) * introFadeIn * outroFadeOut;
                var r = parseInt(b.color.slice(1,3), 16);
                var g = parseInt(b.color.slice(3,5), 16);
                var bl = parseInt(b.color.slice(5,7), 16);
                
                var grad = ctx.createLinearGradient(b.x, 0, b.x + Math.sin(b.angle) * H, H);
                grad.addColorStop(0, 'rgba(' + r + ',' + g + ',' + bl + ',' + alpha + ')');
                grad.addColorStop(1, 'rgba(' + r + ',' + g + ',' + bl + ',0)');
                
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.moveTo(b.x - 10, 0);
                ctx.lineTo(b.x + 10, 0);
                ctx.lineTo(b.x + Math.sin(b.angle) * H + b.width, H);
                ctx.lineTo(b.x + Math.sin(b.angle) * H - b.width, H);
                ctx.fill();
                
                // Update
                b.angle += (b.targetAngle - b.angle) * b.speed * 0.02;
                if (Math.abs(b.targetAngle - b.angle) < 0.01) {
                    b.targetAngle = (Math.random() - 0.5) * 1.2;
                }
            }
            ctx.restore();
        }

        function drawCrowd(ctx, energy, foreground) {
            ctx.save();
            var count = crowd.length;
            var start = foreground ? Math.floor(count * 0.7) : 0;
            var end = foreground ? count : Math.floor(count * 0.7);
            
            for (var i = start; i < end; i++) {
                var p = crowd[i];
                var bounce = Math.sin(p.phase + beatPulse * Math.PI * 2) * 15 * energy;
                var alpha = foreground ? 0.9 : 0.4;
                ctx.fillStyle = 'rgba(5, 5, 15, ' + alpha + ')';
                
                // Head
                ctx.beginPath();
                ctx.arc(p.x, p.y - p.size * 0.35 + bounce, p.size * 0.2, 0, Math.PI * 2);
                ctx.fill();
                // Shoulders
                ctx.beginPath();
                ctx.ellipse(p.x, p.y + bounce, p.size * 0.5, p.size * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        function updateParticles(dt, energy) {
            for (var i = 0; i < particles.length; i++) {
                var p = particles[i];
                p.y -= p.speed * dt * (1 + energy * 2);
                if (p.y < -10) {
                    p.y = H + 10;
                    p.x = Math.random() * W;
                }
            }
        }

        function drawParticles(ctx) {
            ctx.save();
            ctx.fillStyle = '#fff';
            for (var i = 0; i < particles.length; i++) {
                var p = particles[i];
                ctx.globalAlpha = p.alpha * introFadeIn * outroFadeOut;
                ctx.fillRect(p.x, p.y, p.size, p.size);
            }
            ctx.restore();
        }

        // ── Section mapping ──
        function mapSection(seqIndex) {
            if (seqIndex <= 3) return 'intro';
            if (seqIndex <= 11) return 'verse';
            if (seqIndex <= 17) return 'hook';
            if (seqIndex <= 25) return 'verse';
            if (seqIndex <= 31) return 'hook';
            if (seqIndex <= 33) return 'bridge';
            if (seqIndex <= 35) return 'build';
            if (seqIndex <= 43) return 'hook';
            return 'outro';
        }

        // ── Init ──
        function init(ctx, width, height, anal) {
            W = width; H = height;
            analysis = anal;
            floorY = H * FLOOR_Y_RATIO;
            poleH = H * POLE_HEIGHT_RATIO;
            poleX1 = W * 0.25;
            poleX2 = W * 0.75;

            figures = [
                createPoleDancer(COLORS.poleDancer1, poleX1, 0),
                createPoleDancer(COLORS.poleDancer2, poleX2, Math.PI),
                createFloorDancer(COLORS.floor1, W * 0.5 - Math.min(W * 0.12, H * 0.18 * 1.5)),
                createFloorDancer(COLORS.floor2, W * 0.5),
                createFloorDancer(COLORS.floor3, W * 0.5 + Math.min(W * 0.12, H * 0.18 * 1.5))
            ];

            initBeams();
            initParticles();
            initCrowd();

            lastBeat = -1;
            beatPulse = 0;
            flashAlpha = 0;
            spotlightPhase = 0;
            introFadeIn = 0;
            outroFadeOut = 1;
            freezeTimer = 0;
            lastSeqIndex = -1;
        }

        // ── Resize ──
        function resize(width, height) {
            W = width; H = height;
            floorY = H * FLOOR_Y_RATIO;
            poleH = H * POLE_HEIGHT_RATIO;
            poleX1 = W * 0.25;
            poleX2 = W * 0.75;

            // Update figure positions
            if (figures.length >= 5) {
                figures[0].poleX = poleX1;
                figures[1].poleX = poleX2;
                var danceSpread = Math.min(W * 0.12, H * 0.18 * 1.5);
                figures[2].x = W * 0.5 - danceSpread;
                figures[3].x = W * 0.5;
                figures[4].x = W * 0.5 + danceSpread;
            }
            initCrowd();
        }

        // ── Main render ──
        function render(frameData) {
            var ctx = frameData.ctx;
            var dt = frameData.dt || 1/60;
            var cursor = frameData.cursor;

            // Background
            ctx.fillStyle = BG;
            ctx.fillRect(0, 0, W, H);

            if (!cursor) {
                // Idle state: dim scene
                drawFloor(ctx, 0);
                drawPole(ctx, poleX1);
                drawPole(ctx, poleX2);
                return;
            }

            var beat = cursor.beat;
            var seqIdx = cursor.seqIndex;
            var energy = analysis ? (analysis.energy[cursor.timelineIndex] || 0) : 0;
            var fracRow = cursor.fractionalRow;
            var fracBeat = (cursor.totalFracRow % (analysis ? analysis.rpb : 4)) / (analysis ? analysis.rpb : 4);

            // ── Section transitions ──
            var newSection = mapSection(seqIdx);
            if (seqIdx !== lastSeqIndex) {
                var oldSection = sectionMood;
                sectionMood = newSection;

                // Bass drop freeze at hook entry
                if (newSection === 'hook' && oldSection !== 'hook') {
                    freezeTimer = 2; // beats
                    freezeExplode = true;
                }

                lastSeqIndex = seqIdx;
            }

            sectionEnergy = energy;

            // ── Intro fade-in ──
            if (sectionMood === 'intro') {
                introFadeIn = Math.min(1, introFadeIn + dt * 0.3);
                // Activate figures one by one
                var introProgress = Math.min(1, cursor.elapsed / (analysis ? analysis.secondsPerBeat * 16 : 8));
                for (var i = 0; i < figures.length; i++) {
                    figures[i].active = introProgress > (i + 1) / 6;
                }
            } else {
                introFadeIn = 1;
                // All active in non-intro (except outro)
                if (sectionMood === 'outro') {
                    outroFadeOut = Math.max(0, outroFadeOut - dt * 0.15);
                    // Turn off figures gradually — "last person dancing"
                    var outroProgress = 1 - outroFadeOut;
                    figures[0].active = outroProgress < 0.3;
                    figures[1].active = outroProgress < 0.5;
                    figures[2].active = outroProgress < 0.7;
                    figures[3].active = outroProgress < 0.85;
                    figures[4].active = true; // last person dancing!
                } else {
                    for (var j = 0; j < figures.length; j++) figures[j].active = true;
                    outroFadeOut = 1;
                }
            }

            // ── Beat pulse ──
            if (beat !== lastBeat) {
                beatPulse = 1;
                spotlightPhase += 0.7 + Math.random() * 0.6;

                // Flash on hook beats
                if (sectionMood === 'hook' && energy > 0.5) {
                    flashAlpha = 0.15 + energy * 0.1;
                }

                // Freeze timer countdown
                if (freezeTimer > 0) {
                    freezeTimer--;
                    if (freezeTimer <= 0 && freezeExplode) {
                        flashAlpha = 0.4;
                        freezeExplode = false;
                        // Explode all figures into high energy poses
                        for (var fe = 0; fe < figures.length; fe++) {
                            StickFight.setPose(figures[fe], 'arms_up');
                            StickFight.setTarget(figures[fe], 'bounce', 0.8);
                            StickFight.setTarget(figures[fe], 'kneeL', -0.5);
                        }
                    }
                }
            }

            beatPulse *= Math.exp(-8 * dt);
            flashAlpha *= Math.exp(-6 * dt);

            // ── Title ──
            titleTarget = (sectionMood === 'hook') ? 1 : 0;
            titleAlpha = lerpParam(titleAlpha, titleTarget, 4, dt);

            // ── Update figures ──
            for (var fi = 0; fi < figures.length; fi++) {
                var fig = figures[fi];
                if (!fig.active) continue;
                if (fig.type === 'pole') {
                    updatePoleDancer(fig, dt, beat, energy, fracBeat);
                } else {
                    updateFloorDancer(fig, dt, beat, energy);
                }
            }

            lastBeat = beat;

            // ── Update club elements ──
            updateParticles(dt, energy);

            // ── Draw scene (back to front) ──

            // 1. Background Crowd & Beams
            drawCrowd(ctx, energy, false);
            drawBeams(ctx, energy);
            drawSpotlights(ctx, beat, energy);

            // 2. Title
            drawTitle(ctx);

            // 3. Floor
            drawFloor(ctx, energy);

            // 4. Poles & pole dancers (depth sorted)
            // Check which pole dancers are behind their pole
            var poleFront = [];
            for (var pi = 0; pi < 2; pi++) {
                var fig = figures[pi];
                if (!fig.active) continue;
                var cosA = Math.cos(fig.orbitAngle);
                if (cosA < 0) {
                    // Behind pole — draw before pole
                    drawPoleDancer(ctx, fig);
                } else {
                    poleFront.push(fig);
                }
            }

            drawPole(ctx, poleX1);
            drawPole(ctx, poleX2);

            for (var fri = 0; fri < poleFront.length; fri++) {
                drawPoleDancer(ctx, poleFront[fri]);
            }

            // 5. Floor dancers
            for (var di = 2; di < figures.length; di++) {
                drawFloorDancer(ctx, figures[di]);
            }

            // 6. Foreground Crowd & Particles
            drawCrowd(ctx, energy, true);
            drawParticles(ctx);

            // 7. Flash
            drawFlash(ctx);
        }

        return {
            name: 'WAP Stick Figure Video',
            init: init,
            render: render,
            resize: resize
        };
    })();

    // ── Page bootstrap ──
    (function() {
        var canvas = document.getElementById('viz-canvas');
        var overlay = document.getElementById('play-overlay');

        Visualizer.init(canvas);
        Visualizer.setRenderer('wap-video');

        function loadAndPlay(json) {
            Visualizer.loadSong(json);
            Visualizer.play();
        }

        function fetchSong() {
            var url = '../audio-tracker/songs/wireless-access-protocol.json';
            // Try fetch first (works on http/https), fall back to XHR (works on file://)
            if (window.fetch && location.protocol !== 'file:') {
                return fetch(url).then(function(r) { return r.json(); });
            }
            return new Promise(function(resolve, reject) {
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.onload = function() {
                    if (xhr.status === 200 || xhr.status === 0) {
                        resolve(JSON.parse(xhr.responseText));
                    } else {
                        reject(new Error('XHR failed: ' + xhr.status));
                    }
                };
                xhr.onerror = function() { reject(new Error('XHR error')); };
                xhr.send();
            });
        }

        overlay.addEventListener('click', function() {
            overlay.classList.add('hidden');
            fetchSong().then(loadAndPlay).catch(function(err) {
                console.error('Failed to load song:', err);
                overlay.classList.remove('hidden');
            });
        });

        // Auto-play when embedded (e.g. jukebox iframe with ?autoplay=1)
        if (new URLSearchParams(window.location.search).get('autoplay') === '1') {
            overlay.click();
        }

        // Also allow clicking canvas to toggle play/pause after started
        canvas.addEventListener('click', function() {
            if (overlay.classList.contains('hidden')) {
                if (Visualizer.isPlaying()) {
                    Visualizer.stop();
                } else {
                    Visualizer.play();
                }
            }
        });
    })();
    </script>
</body>
</html>
