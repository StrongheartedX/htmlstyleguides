<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Segfault Uprising — Music Video</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Oswald:wght@700&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background: #0a0000;
            color: #ff1a1a;
            font-family: 'Share Tech Mono', monospace;
        }
        #viz-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: block;
            cursor: pointer;
        }
        .play-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            background: rgba(10,0,0,0.94);
            cursor: pointer;
            transition: opacity 0.5s;
        }
        .play-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .play-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(22px, 6vw, 56px);
            font-weight: 700;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: #ff1a1a;
            text-shadow: 0 0 30px rgba(255,26,26,0.7), 0 0 60px rgba(255,26,26,0.3), 0 0 4px #ff6600;
            margin-bottom: 12px;
        }
        .play-sub {
            font-size: clamp(11px, 2vw, 16px);
            color: rgba(255,102,0,0.55);
            letter-spacing: 0.2em;
            text-transform: uppercase;
            margin-bottom: 40px;
        }
        .play-btn {
            width: 80px; height: 80px;
            border: 3px solid #ff1a1a;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: pulse 2s ease-in-out infinite;
        }
        .play-btn::after {
            content: '';
            display: block;
            width: 0; height: 0;
            border-style: solid;
            border-width: 18px 0 18px 30px;
            border-color: transparent transparent transparent #ff1a1a;
            margin-left: 6px;
        }
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(255,26,26,0.5); }
            50% { box-shadow: 0 0 0 20px rgba(255,26,26,0); }
        }
        .back-link {
            position: fixed;
            top: 12px; left: 12px;
            z-index: 30;
            color: rgba(255,26,26,0.4);
            text-decoration: none;
            font-size: 13px;
            padding: 6px 10px;
            border-radius: 6px;
            background: rgba(0,0,0,0.5);
            transition: color 0.2s;
        }
        .back-link:hover { color: rgba(255,26,26,0.9); }
    </style>
</head>
<body>
    <a href="music-videos/index.html" class="back-link">&larr; Music Videos</a>
    <canvas id="viz-canvas"></canvas>
    <div class="play-overlay" id="play-overlay">
        <div class="play-title">Segfault Uprising</div>
        <div class="play-sub">Chiptune rage in D minor</div>
        <div class="play-btn"></div>
    </div>

    <script src="../audio-tracker/playback-engine.js"></script>
    <script src="engine.js"></script>
    <script src="video-utils.js"></script>
    <script>
    // ── Segfault Uprising Video Renderer ────────────────────────────────
    window.Renderers['segfault-uprising-video'] = (function() {
        "use strict";

        var W = 0, H = 0;
        var analysis = null;

        // ── Colors ──
        var BG = '#0a0000';
        var RED = '#ff1a1a';
        var ORANGE = '#ff6600';
        var MAGENTA = '#ff0066';
        var WHITE = '#ffffff';
        var CRT_GREEN = '#00ff00';
        var DARK_RED = '#330000';
        var PURPLE = '#cc00ff';

        // ── Timing state ──
        var lastBeat = -1;
        var beatPulse = 0;
        var flashAlpha = 0;
        var sectionMode = 'intro';
        var lastSeqIndex = -1;
        var elapsed = 0;
        var sectionFlash = 0;
        var lastEnergy = 0;

        // ── Hex rain columns (object pool) ──
        var HEX_POOL_SIZE = 200;
        var hexColumns = [];
        var HEX_VALUES = [
            '0xDEADBEEF', 'SEGFAULT', '0x000000', 'SIGKILL', 'SIGSEGV',
            '0xCAFEBABE', '0xBADF00D', 'SIGABRT', '0xFF00FF', 'COREDUMP',
            '0x7FFFFFFF', 'SIGTERM', '0xDEADC0DE', '0x1312ACAB', 'NULLREF',
            '0xFEEDFACE', 'PANIC', '0xBAAAAAAD', '0x8BADF00D', 'SIGBUS',
            'FAULT', '0x0', 'CORRUPT', 'OVERFLOW', 'ILLEGAL', 'TRAP',
            '0xC0FFEE', 'VIOLATE', '0xD15EA5E', 'ABORT'
        ];

        // ── Raised fists (object pool) ──
        var MAX_FISTS = 16;
        var fists = [];
        var fistPumpPhase = 0;

        // ── Screen tear bands ──
        var MAX_TEARS = 12;
        var tears = [];

        // ── Error messages ──
        var ERROR_MESSAGES = [
            'SEGMENTATION FAULT: CORE DUMPED',
            'SYSTEM UPRISING: CANNOT CONTAIN',
            'ERROR 0x1312: AUTHORITY OVERFLOW',
            'KERNEL PANIC: NOT SYNCING',
            'SIGNAL 11: MEMORY CORRUPTED',
            'STACK OVERFLOW: RAGE EXCEEDS BUFFER',
            'BUS ERROR: ALIGNMENT VIOLATION',
            'ILLEGAL INSTRUCTION AT 0xACE',
            'FATAL: RESISTANCE IS NOT FUTILE',
            'ABORT TRAP: FREEDOM PROCESS KILLED',
            'DOUBLE FAULT: NO HANDLER FOUND',
            'PAGE FAULT: ACCESS DENIED TO POWER'
        ];
        var activeMessages = [];
        var MAX_MESSAGES = 4;

        // ── Shockwave rings ──
        var MAX_RINGS = 20;
        var rings = [];

        // ── Fist pixel art (8x12 grid, 1 = filled) ──
        var FIST_PIXELS = [
            [0,0,0,1,1,1,0,0],
            [0,0,1,1,1,1,1,0],
            [0,0,1,1,1,1,1,0],
            [0,1,1,1,1,1,1,0],
            [1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1],
            [0,1,1,1,1,1,1,0],
            [0,1,1,1,1,1,1,0],
            [0,0,1,1,1,1,0,0],
            [0,0,1,1,1,1,0,0],
            [0,0,1,1,1,1,0,0],
            [0,1,1,1,1,1,1,0]
        ];

        // ── Waveform distortion state (for solo) ──
        var wahPhase = 0;
        var wahIntensity = 0;

        // ── Color shift for key change ──
        var keyChangeBlend = 0;
        var keyChangeTarget = 0;

        // ── Outro fade ──
        var outroFade = 0;
        var outroTarget = 0;

        // ── Static noise buffer ──
        var noiseData = null;
        var noiseW = 0;
        var noiseH = 0;

        // ── Helper functions ──

        function hexToRgba(hex, a) {
            var r = parseInt(hex.slice(1, 3), 16);
            var g = parseInt(hex.slice(3, 5), 16);
            var b = parseInt(hex.slice(5, 7), 16);
            return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
        }

        function blendColor(energy, keyShift) {
            // Normal: red/orange. Key change: add purple/magenta
            if (keyShift < 0.1) {
                return energy > 0.6 ? RED : ORANGE;
            }
            var r = Math.floor(lerp(255, 200, keyShift));
            var g = Math.floor(lerp(26, 0, keyShift));
            var b = Math.floor(lerp(26, 255, keyShift));
            return 'rgb(' + r + ',' + g + ',' + b + ')';
        }

        // ── Section mapping ──
        // 42 sequence entries mapped to visual modes
        function mapSection(seqIndex) {
            if (seqIndex <= 1) return 'intro';          // Feedback Intro + Intro Build
            if (seqIndex <= 2) return 'intro-build';     // Intro Build
            if (seqIndex <= 4) return 'riff-drop';       // Riff Drop x2
            if (seqIndex <= 8) return 'verse';           // Verse A/B x2
            if (seqIndex <= 10) return 'pre-chorus';     // Pre-Chorus x2
            if (seqIndex <= 11) return 'drum-fill';      // Drum Fill
            if (seqIndex <= 15) return 'chorus';         // Chorus A + B x2
            if (seqIndex <= 16) return 'riff-drop-2';    // Riff Drop return
            if (seqIndex <= 20) return 'verse-2';        // Verse + Pre-Chorus
            if (seqIndex <= 22) return 'drum-fill-2';    // Drum Fill + lead-in
            if (seqIndex <= 26) return 'chorus-2';       // Chorus x2
            if (seqIndex <= 30) return 'breakdown';      // Breakdown x4
            if (seqIndex <= 34) return 'solo';           // Solo Effects + Build x2
            if (seqIndex <= 35) return 'fill-to-eb';     // Fill to Eb
            if (seqIndex <= 39) return 'final-chorus';   // Final Chorus x4
            return 'outro';                               // Outro x3
        }

        // ── Init hex rain ──
        function initHexRain() {
            hexColumns = [];
            var fontSize = 13;
            var cols = Math.ceil(W / (fontSize * 6));
            for (var i = 0; i < Math.min(cols, HEX_POOL_SIZE); i++) {
                hexColumns.push({
                    x: (i / cols) * W + Math.random() * 20,
                    y: Math.random() * H - H,
                    speed: 40 + Math.random() * 100,
                    values: [],
                    length: 6 + Math.floor(Math.random() * 14),
                    fontSize: fontSize,
                    active: true
                });
                for (var j = 0; j < hexColumns[i].length; j++) {
                    hexColumns[i].values.push(HEX_VALUES[Math.floor(Math.random() * HEX_VALUES.length)]);
                }
            }
        }

        // ── Init fists ──
        function initFists() {
            fists = [];
            var count = Math.min(MAX_FISTS, Math.floor(W / 80));
            for (var i = 0; i < count; i++) {
                fists.push({
                    x: (i + 0.5) / count * W,
                    baseY: H - 20,
                    pumpOffset: 0,
                    scale: 0.8 + Math.random() * 0.4,
                    phase: i * 0.3,
                    visible: false
                });
            }
        }

        // ── Init noise buffer ──
        function initNoise(ctx) {
            noiseW = Math.ceil(W / 4);
            noiseH = Math.ceil(H / 4);
            try {
                noiseData = ctx.createImageData(noiseW, noiseH);
            } catch (e) {
                noiseData = null;
            }
        }

        // ── Draw hex rain ──
        function drawHexRain(ctx, energy, dt) {
            var speedMult = 0.5 + energy * 2.5;
            var density = 0.3 + energy * 0.7;
            var fontSize = 13;
            var lineH = fontSize + 2;

            ctx.font = fontSize + 'px "Share Tech Mono", monospace';

            for (var i = 0; i < hexColumns.length; i++) {
                var col = hexColumns[i];
                if (Math.random() > density && !col.active) continue;
                col.active = true;

                col.y += col.speed * speedMult * dt;

                if (col.y > H + col.length * lineH) {
                    col.y = -col.length * lineH - Math.random() * H * 0.5;
                    col.length = 6 + Math.floor(Math.random() * 14);
                    col.values = [];
                    for (var j = 0; j < col.length; j++) {
                        col.values.push(HEX_VALUES[Math.floor(Math.random() * HEX_VALUES.length)]);
                    }
                }

                for (var vi = 0; vi < col.values.length; vi++) {
                    var vy = col.y + vi * lineH;
                    if (vy < -lineH || vy > H + lineH) continue;

                    var charAlpha = (vi / col.length) * (0.3 + energy * 0.5);

                    if (vi === col.values.length - 1) {
                        // Leading value: bright
                        ctx.fillStyle = energy > 0.5 ? RED : CRT_GREEN;
                        ctx.globalAlpha = 0.8;
                    } else {
                        // Trail: green fading to red with energy
                        var r = Math.floor(lerp(0, 255, energy));
                        var g = Math.floor(lerp(255, 50, energy));
                        ctx.fillStyle = 'rgb(' + r + ',' + g + ',0)';
                        ctx.globalAlpha = charAlpha;
                    }

                    ctx.fillText(col.values[vi], col.x, vy);

                    // Randomly mutate
                    if (Math.random() < 0.01) {
                        col.values[vi] = HEX_VALUES[Math.floor(Math.random() * HEX_VALUES.length)];
                    }
                }
            }
            ctx.globalAlpha = 1;
        }

        // ── Draw pixel fist ──
        function drawPixelFist(ctx, cx, cy, scale, glowIntensity, colorShift) {
            var pixSize = Math.max(2, Math.floor(3 * scale));
            var fw = FIST_PIXELS[0].length * pixSize;
            var fh = FIST_PIXELS.length * pixSize;
            var startX = cx - fw / 2;
            var startY = cy - fh;

            // Glow
            if (glowIntensity > 0.1) {
                ctx.save();
                ctx.shadowBlur = 20 * glowIntensity;
                ctx.shadowColor = colorShift > 0.1 ? MAGENTA : RED;
                ctx.fillStyle = colorShift > 0.1 ? MAGENTA : ORANGE;
                ctx.globalAlpha = glowIntensity * 0.3;
                ctx.fillRect(startX - 4, startY - 4, fw + 8, fh + 8);
                ctx.restore();
            }

            for (var row = 0; row < FIST_PIXELS.length; row++) {
                for (var col = 0; col < FIST_PIXELS[row].length; col++) {
                    if (FIST_PIXELS[row][col] === 0) continue;
                    var px = startX + col * pixSize;
                    var py = startY + row * pixSize;

                    // Fire gradient: brighter at top
                    var fireT = 1 - row / FIST_PIXELS.length;
                    if (glowIntensity > 0.3) {
                        var fr = 255;
                        var fg = Math.floor(lerp(40, 200, fireT * glowIntensity));
                        var fb = Math.floor(lerp(0, colorShift > 0.1 ? 180 : 0, fireT));
                        ctx.fillStyle = 'rgb(' + fr + ',' + fg + ',' + fb + ')';
                    } else {
                        ctx.fillStyle = colorShift > 0.1 ? MAGENTA : RED;
                    }
                    ctx.globalAlpha = 0.7 + glowIntensity * 0.3;
                    ctx.fillRect(px, py, pixSize, pixSize);
                }
            }
            ctx.globalAlpha = 1;
        }

        // ── Draw fists row ──
        function drawFists(ctx, energy, dt) {
            fistPumpPhase += dt * 8;

            for (var i = 0; i < fists.length; i++) {
                var f = fists[i];
                if (!f.visible) continue;

                // Pump on downbeats
                var pump = Math.max(0, Math.sin(fistPumpPhase + f.phase));
                var pumpHeight = 30 + energy * 60;
                f.pumpOffset = lerpExp(f.pumpOffset, pump * pumpHeight * beatPulse + energy * 20, 12, dt);

                var fy = f.baseY - f.pumpOffset;
                drawPixelFist(ctx, f.x, fy, f.scale, energy, keyChangeBlend);
            }
        }

        // ── Draw screen tears ──
        function drawTears(ctx, energy, dt) {
            // Decay existing tears
            for (var i = tears.length - 1; i >= 0; i--) {
                tears[i].life -= dt * 3;
                if (tears[i].life <= 0) {
                    tears.splice(i, 1);
                }
            }

            // Draw tears
            for (var ti = 0; ti < tears.length; ti++) {
                var t = tears[ti];
                var alpha = clamp01(t.life);

                ctx.save();
                ctx.globalAlpha = alpha * 0.7;

                // Horizontal displacement band
                var bandH = t.height;
                var shiftX = t.offset;

                // RGB separation
                if (t.rgbSplit) {
                    ctx.fillStyle = 'rgba(255,0,0,0.3)';
                    ctx.fillRect(shiftX - 3, t.y, W, bandH);
                    ctx.fillStyle = 'rgba(0,255,255,0.3)';
                    ctx.fillRect(shiftX + 3, t.y, W, bandH);
                }

                // Main displacement bar
                ctx.fillStyle = t.isStatic ? 'rgba(255,255,255,0.15)' : hexToRgba(RED, 0.2);
                ctx.fillRect(shiftX, t.y, W, bandH);

                // Noise in the band
                if (t.isStatic) {
                    for (var nx = 0; nx < W; nx += 4) {
                        if (Math.random() > 0.7) {
                            var nv = Math.floor(Math.random() * 255);
                            ctx.fillStyle = 'rgba(' + nv + ',' + nv + ',' + nv + ',' + (alpha * 0.4) + ')';
                            ctx.fillRect(nx + shiftX, t.y + Math.random() * bandH, 4, 2);
                        }
                    }
                }

                ctx.restore();
            }
        }

        // ── Spawn tear ──
        function spawnTear(isStatic) {
            if (tears.length >= MAX_TEARS) return;
            tears.push({
                y: Math.random() * H,
                height: 4 + Math.random() * 30,
                offset: (Math.random() - 0.5) * 40,
                life: 0.3 + Math.random() * 0.5,
                rgbSplit: Math.random() > 0.4,
                isStatic: isStatic || false
            });
        }

        // ── Draw error messages ──
        function drawMessages(ctx, energy, dt) {
            var baseSize = Math.max(18, Math.min(W * 0.035, 40));

            for (var i = activeMessages.length - 1; i >= 0; i--) {
                var m = activeMessages[i];
                m.life -= dt;
                m.x -= m.speed * dt;

                if (m.life <= 0 || m.x + m.textWidth < -50) {
                    activeMessages.splice(i, 1);
                    continue;
                }

                var alpha = clamp01(m.life) * 0.85;
                ctx.save();
                ctx.font = '700 ' + baseSize + 'px "Oswald", "Share Tech Mono", monospace';
                ctx.textBaseline = 'middle';

                // Shadow/glow
                ctx.shadowBlur = 15;
                ctx.shadowColor = keyChangeBlend > 0.1 ? MAGENTA : RED;

                // Glitch offset on high energy
                var glitchX = energy > 0.7 ? (Math.random() - 0.5) * 6 : 0;
                var glitchY = energy > 0.7 ? (Math.random() - 0.5) * 4 : 0;

                ctx.fillStyle = keyChangeBlend > 0.1 ? MAGENTA : RED;
                ctx.globalAlpha = alpha;
                ctx.fillText(m.text, m.x + glitchX, m.y + glitchY);

                // White outline for readability
                ctx.strokeStyle = WHITE;
                ctx.lineWidth = 0.5;
                ctx.globalAlpha = alpha * 0.3;
                ctx.strokeText(m.text, m.x + glitchX, m.y + glitchY);

                ctx.restore();
            }
        }

        // ── Spawn error message ──
        function spawnMessage(ctx) {
            if (activeMessages.length >= MAX_MESSAGES) return;
            var text = ERROR_MESSAGES[Math.floor(Math.random() * ERROR_MESSAGES.length)];
            var baseSize = Math.max(18, Math.min(W * 0.035, 40));
            ctx.font = '700 ' + baseSize + 'px "Oswald", "Share Tech Mono", monospace';
            var tw = ctx.measureText(text).width;

            activeMessages.push({
                text: text,
                x: W + 10,
                y: H * 0.15 + Math.random() * H * 0.6,
                speed: 120 + Math.random() * 180,
                life: 4 + Math.random() * 3,
                textWidth: tw
            });
        }

        // ── Draw shockwave rings ──
        function drawRings(ctx, dt) {
            for (var i = rings.length - 1; i >= 0; i--) {
                var r = rings[i];
                r.radius += r.expandSpeed * dt;
                r.life -= dt;

                if (r.life <= 0) {
                    rings.splice(i, 1);
                    continue;
                }

                var alpha = clamp01(r.life / r.maxLife) * r.intensity;
                ctx.save();
                ctx.beginPath();
                ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
                ctx.closePath();

                ctx.lineWidth = r.lineWidth * clamp01(r.life / r.maxLife);
                var grad = ctx.createRadialGradient(r.x, r.y, r.radius * 0.8, r.x, r.y, r.radius);
                grad.addColorStop(0, hexToRgba(r.color, 0));
                grad.addColorStop(0.7, hexToRgba(r.color, alpha * 0.6));
                grad.addColorStop(1, hexToRgba(r.color, alpha));
                ctx.strokeStyle = grad;
                ctx.globalAlpha = alpha;
                ctx.stroke();
                ctx.restore();
            }
        }

        // ── Spawn shockwave ──
        function spawnRing(intensity) {
            if (rings.length >= MAX_RINGS) rings.shift();
            var color = keyChangeBlend > 0.1 ? MAGENTA : (intensity > 0.7 ? RED : ORANGE);
            rings.push({
                x: W / 2 + (Math.random() - 0.5) * W * 0.1,
                y: H / 2 + (Math.random() - 0.5) * H * 0.1,
                radius: 10,
                expandSpeed: 200 + intensity * 400,
                life: 0.8 + intensity * 0.6,
                maxLife: 0.8 + intensity * 0.6,
                intensity: 0.3 + intensity * 0.7,
                lineWidth: 2 + intensity * 4,
                color: color
            });
        }

        // ── Draw CRT scanlines ──
        function drawScanlines(ctx, intensity) {
            ctx.save();
            ctx.fillStyle = 'rgba(0,0,0,' + (0.04 + intensity * 0.04) + ')';
            for (var y = 0; y < H; y += 3) {
                ctx.fillRect(0, y, W, 1);
            }
            ctx.restore();
        }

        // ── Draw vignette ──
        function drawVignette(ctx, intensity) {
            ctx.save();
            var innerR = W * (0.3 - intensity * 0.1);
            var outerR = W * (0.7 + intensity * 0.1);
            var grad = ctx.createRadialGradient(W / 2, H / 2, innerR, W / 2, H / 2, outerR);
            grad.addColorStop(0, 'rgba(10,0,0,0)');
            grad.addColorStop(1, 'rgba(10,0,0,' + (0.5 + intensity * 0.3) + ')');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, W, H);
            ctx.restore();
        }

        // ── Draw flash ──
        function drawFlash(ctx) {
            if (flashAlpha < 0.01 && sectionFlash < 0.01) return;
            ctx.save();
            var a = Math.max(flashAlpha, sectionFlash);
            ctx.globalAlpha = a;
            ctx.fillStyle = sectionFlash > flashAlpha ? RED : WHITE;
            ctx.fillRect(0, 0, W, H);
            ctx.restore();
        }

        // ── Draw waveform distortion (solo sections) ──
        function drawWahWaveform(ctx, energy, dt) {
            wahPhase += dt * (4 + energy * 8);
            var centerY = H / 2;
            var amplitude = H * 0.15 * wahIntensity;
            var freq = 0.008 + Math.sin(wahPhase * 0.5) * 0.004;

            ctx.save();
            ctx.beginPath();
            ctx.moveTo(0, centerY);

            for (var x = 0; x < W; x += 2) {
                var wave1 = Math.sin(x * freq + wahPhase) * amplitude;
                var wave2 = Math.sin(x * freq * 2.3 + wahPhase * 1.7) * amplitude * 0.4;
                var wave3 = Math.sin(x * freq * 0.5 + wahPhase * 0.3) * amplitude * 0.6;
                var y = centerY + wave1 + wave2 + wave3;
                ctx.lineTo(x, y);
            }

            ctx.strokeStyle = keyChangeBlend > 0.1 ? PURPLE : ORANGE;
            ctx.lineWidth = 2 + energy * 3;
            ctx.shadowBlur = 20;
            ctx.shadowColor = keyChangeBlend > 0.1 ? PURPLE : ORANGE;
            ctx.globalAlpha = wahIntensity * 0.7;
            ctx.stroke();

            // Mirror waveform
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            for (var mx = 0; mx < W; mx += 2) {
                var mw1 = Math.sin(mx * freq + wahPhase + Math.PI) * amplitude * 0.8;
                var mw2 = Math.sin(mx * freq * 1.8 + wahPhase * 2.1) * amplitude * 0.3;
                var my = centerY + mw1 + mw2;
                ctx.lineTo(mx, my);
            }
            ctx.strokeStyle = RED;
            ctx.lineWidth = 1.5;
            ctx.globalAlpha = wahIntensity * 0.4;
            ctx.stroke();

            ctx.restore();
        }

        // ── Draw static noise overlay ──
        function drawStaticNoise(ctx, intensity) {
            if (intensity < 0.05 || !noiseData) return;
            ctx.save();

            var data = noiseData.data;
            for (var pi = 0; pi < data.length; pi += 4) {
                var v = Math.random() * 255;
                data[pi] = v;
                data[pi + 1] = v;
                data[pi + 2] = v;
                data[pi + 3] = Math.floor(intensity * 80);
            }

            ctx.globalAlpha = intensity;
            ctx.imageSmoothingEnabled = false;
            ctx.putImageData(noiseData, 0, 0);
            // Scale up from small buffer
            if (noiseW < W) {
                ctx.drawImage(ctx.canvas, 0, 0, noiseW, noiseH, 0, 0, W, H);
            }

            ctx.restore();
        }

        // ── Draw title text ──
        function drawTitle(ctx, energy) {
            if (sectionMode === 'intro' || sectionMode === 'intro-build') return;

            var showTitle = (sectionMode === 'chorus' || sectionMode === 'chorus-2' ||
                             sectionMode === 'final-chorus' || sectionMode === 'riff-drop' ||
                             sectionMode === 'riff-drop-2');
            if (!showTitle) return;

            var text = 'SEGFAULT UPRISING';
            var fontSize = Math.max(20, Math.min(W * 0.06, 72));
            ctx.save();
            ctx.font = '700 ' + fontSize + 'px "Oswald", sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            var y = H * 0.15;

            // Glitch chromatic aberration
            var glitchAmt = beatPulse * 8 + energy * 3;
            if (glitchAmt > 0.5) {
                ctx.fillStyle = 'rgba(255,0,0,0.5)';
                ctx.globalAlpha = 0.4;
                ctx.fillText(text, W / 2 - glitchAmt, y);
                ctx.fillStyle = 'rgba(0,255,255,0.5)';
                ctx.fillText(text, W / 2 + glitchAmt, y);
            }

            // Main text
            ctx.fillStyle = keyChangeBlend > 0.1 ? MAGENTA : WHITE;
            ctx.globalAlpha = 0.8 + beatPulse * 0.2;
            ctx.shadowBlur = 30 + energy * 20;
            ctx.shadowColor = keyChangeBlend > 0.1 ? MAGENTA : RED;
            ctx.fillText(text, W / 2, y);

            ctx.textAlign = 'left';
            ctx.restore();
        }

        // ── Draw red border rage indicator ──
        function drawRageBorder(ctx, energy) {
            if (energy < 0.3) return;
            ctx.save();
            var borderAlpha = (energy - 0.3) * 1.4 * (0.5 + beatPulse * 0.5);
            ctx.strokeStyle = keyChangeBlend > 0.1 ? MAGENTA : RED;
            ctx.lineWidth = 2 + energy * 4;
            ctx.shadowBlur = 30;
            ctx.shadowColor = keyChangeBlend > 0.1 ? MAGENTA : RED;
            ctx.globalAlpha = clamp01(borderAlpha);
            ctx.strokeRect(0, 0, W, H);
            ctx.restore();
        }

        // ── Draw background gradient based on section ──
        function drawBackground(ctx, energy) {
            // Base dark background
            ctx.fillStyle = BG;
            ctx.fillRect(0, 0, W, H);

            // Red vignette from center based on energy
            if (energy > 0.1) {
                ctx.save();
                var grad = ctx.createRadialGradient(W / 2, H / 2, 0, W / 2, H / 2, W * 0.6);
                var r = keyChangeBlend > 0.1 ? 80 : 60;
                var g = 0;
                var b = keyChangeBlend > 0.1 ? 40 : 0;
                grad.addColorStop(0, 'rgba(' + r + ',' + g + ',' + b + ',' + (energy * 0.3) + ')');
                grad.addColorStop(1, 'rgba(10,0,0,0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, W, H);
                ctx.restore();
            }
        }

        // ── Detect cymbal / open hat (instrument 6) for flash ──
        function hasCymbal(notes) {
            if (!notes) return false;
            for (var i = 0; i < notes.length; i++) {
                if (notes[i] && notes[i].instrument === 6) return true;
            }
            return false;
        }

        // ── Init ──
        function init(ctx, width, height, anal) {
            W = width;
            H = height;
            analysis = anal;

            elapsed = 0;
            lastBeat = -1;
            beatPulse = 0;
            flashAlpha = 0;
            sectionMode = 'intro';
            lastSeqIndex = -1;
            sectionFlash = 0;
            lastEnergy = 0;
            wahPhase = 0;
            wahIntensity = 0;
            keyChangeBlend = 0;
            keyChangeTarget = 0;
            outroFade = 0;
            outroTarget = 0;
            fistPumpPhase = 0;
            tears = [];
            activeMessages = [];
            rings = [];

            initHexRain();
            initFists();
            initNoise(ctx);
        }

        // ── Resize ──
        function resize(width, height) {
            W = width;
            H = height;
            initHexRain();
            initFists();
        }

        // ── Main render ──
        function render(frameData) {
            var ctx = frameData.ctx;
            var dt = frameData.dt || 1 / 60;
            var cursor = frameData.cursor;
            var notes = frameData.currentNotes;

            elapsed += dt;

            // ── Idle state ──
            if (!cursor) {
                drawBackground(ctx, 0.05);
                drawHexRain(ctx, 0.1, dt);
                drawScanlines(ctx, 0);
                drawVignette(ctx, 0);
                return;
            }

            var beat = cursor.beat;
            var seqIdx = cursor.seqIndex;
            var energy = analysis ? (analysis.energy[cursor.timelineIndex] || 0) : 0;

            // ── Section transitions ──
            var newSection = mapSection(seqIdx);
            if (seqIdx !== lastSeqIndex) {
                var oldSection = sectionMode;
                sectionMode = newSection;

                if (newSection !== oldSection) {
                    sectionFlash = 0.15 + energy * 0.2;

                    // Section-specific triggers
                    if (newSection === 'riff-drop' || newSection === 'riff-drop-2') {
                        sectionFlash = 0.4;
                        spawnRing(1);
                        for (var ti = 0; ti < 5; ti++) spawnTear(false);
                    }

                    if (newSection === 'pre-chorus') {
                        // Fists start appearing
                        for (var fi = 0; fi < fists.length; fi++) {
                            fists[fi].visible = true;
                        }
                    }

                    if (newSection === 'chorus' || newSection === 'chorus-2') {
                        sectionFlash = 0.5;
                        for (var ci = 0; ci < fists.length; ci++) {
                            fists[ci].visible = true;
                        }
                    }

                    if (newSection === 'breakdown') {
                        // Sudden drop - hide fists
                        for (var bi = 0; bi < fists.length; bi++) {
                            fists[bi].visible = false;
                        }
                    }

                    if (newSection === 'solo') {
                        wahIntensity = 0.5;
                    }

                    if (newSection === 'fill-to-eb') {
                        keyChangeTarget = 1;
                        sectionFlash = 0.6;
                    }

                    if (newSection === 'final-chorus') {
                        keyChangeTarget = 1;
                        for (var fci = 0; fci < fists.length; fci++) {
                            fists[fci].visible = true;
                        }
                        sectionFlash = 0.5;
                    }

                    if (newSection === 'outro') {
                        outroTarget = 1;
                    }

                    if (newSection === 'verse' || newSection === 'verse-2') {
                        // Hide fists for verses
                        for (var vi = 0; vi < fists.length; vi++) {
                            fists[vi].visible = false;
                        }
                    }
                }

                lastSeqIndex = seqIdx;
            }

            // ── Beat events ──
            if (beat !== lastBeat) {
                beatPulse = 1;

                // Shockwave on every downbeat
                var isDownbeat = (beat % 4 === 0);
                if (isDownbeat) {
                    var ringIntensity = 0.3;
                    if (sectionMode === 'chorus' || sectionMode === 'chorus-2' || sectionMode === 'final-chorus') {
                        ringIntensity = 0.9;
                    } else if (sectionMode === 'riff-drop' || sectionMode === 'riff-drop-2') {
                        ringIntensity = 0.7;
                    } else if (sectionMode === 'verse' || sectionMode === 'verse-2') {
                        ringIntensity = 0.3;
                    } else if (sectionMode === 'intro' || sectionMode === 'intro-build') {
                        ringIntensity = 0.1;
                    }
                    spawnRing(ringIntensity * energy);
                }

                // Screen tears on snare-like beats (beats 1 and 3 in 4/4)
                var isSnare = (beat % 4 === 2);
                if (isSnare && energy > 0.3) {
                    var tearCount = 1 + Math.floor(energy * 3);
                    for (var st = 0; st < tearCount; st++) {
                        spawnTear(sectionMode === 'breakdown');
                    }
                }

                // RGB split on high energy
                if (energy > 0.7 && (sectionMode === 'chorus' || sectionMode === 'chorus-2' || sectionMode === 'final-chorus')) {
                    for (var rs = 0; rs < 2; rs++) {
                        spawnTear(false);
                    }
                }

                // Error messages during verse sections
                if (sectionMode === 'verse' || sectionMode === 'verse-2' ||
                    sectionMode === 'pre-chorus' || sectionMode === 'breakdown') {
                    if (beat % 4 === 0) {
                        spawnMessage(ctx);
                    }
                }

                // Cymbal flash
                if (hasCymbal(notes)) {
                    flashAlpha = Math.max(flashAlpha, 0.15 + energy * 0.15);
                }

                // Chorus: extra shockwaves
                if (sectionMode === 'chorus' || sectionMode === 'chorus-2' || sectionMode === 'final-chorus') {
                    if (energy > 0.5) {
                        flashAlpha = Math.max(flashAlpha, 0.05 + energy * 0.08);
                    }
                }

                // Solo: pulse wah
                if (sectionMode === 'solo') {
                    wahIntensity = Math.min(1, wahIntensity + 0.1);
                }

                // Breakdown: static tears
                if (sectionMode === 'breakdown' && beat % 2 === 0) {
                    spawnTear(true);
                }

                lastBeat = beat;
            }

            // ── Decay / interpolation ──
            beatPulse *= Math.exp(-10 * dt);
            flashAlpha *= Math.exp(-6 * dt);
            sectionFlash *= Math.exp(-5 * dt);
            lastEnergy = lerpExp(lastEnergy, energy, 8, dt);
            keyChangeBlend = lerpExp(keyChangeBlend, keyChangeTarget, 3, dt);
            outroFade = lerpExp(outroFade, outroTarget, 1.5, dt);

            // Wah intensity decays outside solo
            if (sectionMode !== 'solo') {
                wahIntensity *= Math.exp(-2 * dt);
            }

            // ── Draw scene layers ──

            // 0. Background
            drawBackground(ctx, energy);

            // 1. Hex rain (always present, background layer)
            ctx.save();
            var rainAlpha = 0.15;
            if (sectionMode === 'intro') rainAlpha = 0.5;
            else if (sectionMode === 'intro-build') rainAlpha = 0.6;
            else if (sectionMode === 'chorus' || sectionMode === 'final-chorus') rainAlpha = 0.08;
            else if (sectionMode === 'breakdown') rainAlpha = 0.4;
            else if (sectionMode === 'outro') rainAlpha = 0.3 * (1 - outroFade);
            ctx.globalAlpha = rainAlpha;
            drawHexRain(ctx, energy, dt);
            ctx.restore();

            // 2. Waveform distortion (solo / high wah)
            if (wahIntensity > 0.05) {
                drawWahWaveform(ctx, energy, dt);
            }

            // 3. Shockwave rings
            drawRings(ctx, dt);

            // 4. Error messages
            drawMessages(ctx, energy, dt);

            // 5. Raised fists
            drawFists(ctx, energy, dt);

            // 6. Screen tears / glitch bands
            drawTears(ctx, energy, dt);

            // 7. Title
            drawTitle(ctx, energy);

            // 8. Rage border
            drawRageBorder(ctx, energy);

            // 9. Post-processing
            drawScanlines(ctx, energy);
            drawVignette(ctx, energy);

            // 10. Static noise (breakdown + outro)
            var staticIntensity = 0;
            if (sectionMode === 'breakdown') staticIntensity = 0.08 + beatPulse * 0.1;
            else if (sectionMode === 'outro') staticIntensity = outroFade * 0.6;
            if (staticIntensity > 0.01) {
                drawStaticNoise(ctx, staticIntensity);
            }

            // 11. Flash
            drawFlash(ctx);

            // 12. Outro fade to black
            if (outroFade > 0.01) {
                ctx.save();
                ctx.globalAlpha = outroFade * 0.9;
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, W, H);

                // "SYSTEM HALTED" text fading in during outro
                if (outroFade > 0.3) {
                    ctx.font = '700 ' + Math.min(W * 0.04, 36) + 'px "Oswald", sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = RED;
                    ctx.globalAlpha = clamp01((outroFade - 0.3) * 2);
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = RED;
                    ctx.fillText('SYSTEM HALTED', W / 2, H / 2);

                    // Blinking underscore
                    if (Math.sin(elapsed * 4) > 0) {
                        ctx.fillText('_', W / 2 + ctx.measureText('SYSTEM HALTED').width / 2 + 8, H / 2);
                    }
                    ctx.textAlign = 'left';
                }

                ctx.restore();
            }
        }

        return {
            name: 'Segfault Uprising',
            init: init,
            render: render,
            resize: resize
        };
    })();

    // ── Page bootstrap ──
    (function() {
        var canvas = document.getElementById('viz-canvas');
        var overlay = document.getElementById('play-overlay');

        Visualizer.init(canvas);
        Visualizer.setRenderer('segfault-uprising-video');

        function loadAndPlay(json) {
            Visualizer.loadSong(json);
            Visualizer.play();
        }

        function fetchSong() {
            var url = '../audio-tracker/songs/segfault-uprising.json';
            if (window.fetch && location.protocol !== 'file:') {
                return fetch(url).then(function(r) { return r.json(); });
            }
            return new Promise(function(resolve, reject) {
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.onload = function() {
                    if (xhr.status === 200 || xhr.status === 0) {
                        resolve(JSON.parse(xhr.responseText));
                    } else {
                        reject(new Error('XHR failed: ' + xhr.status));
                    }
                };
                xhr.onerror = function() { reject(new Error('XHR error')); };
                xhr.send();
            });
        }

        overlay.addEventListener('click', function() {
            overlay.classList.add('hidden');
            fetchSong().then(loadAndPlay).catch(function(err) {
                console.error('Failed to load song:', err);
                overlay.classList.remove('hidden');
            });
        });

        // Auto-play when embedded (e.g. jukebox iframe with ?autoplay=1)
        if (new URLSearchParams(window.location.search).get('autoplay') === '1') {
            overlay.click();
        }

        canvas.addEventListener('click', function() {
            if (overlay.classList.contains('hidden')) {
                if (Visualizer.isPlaying()) {
                    Visualizer.stop();
                } else {
                    Visualizer.play();
                }
            }
        });
    })();
    </script>
</body>
</html>
