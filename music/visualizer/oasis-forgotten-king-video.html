<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Oasis of the Forgotten King — Music Video</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background: #1a0f05;
            color: #fff;
            font-family: 'Cinzel', serif;
        }
        #viz-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: block;
            cursor: pointer;
        }
        .play-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            background: rgba(26,15,5,0.92);
            cursor: pointer;
            transition: opacity 0.5s;
        }
        .play-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .play-title {
            font-size: clamp(18px, 4vw, 42px);
            font-weight: 700;
            letter-spacing: 0.06em;
            color: #d4a24e;
            text-shadow: 0 0 30px rgba(212,162,78,0.5), 0 0 60px rgba(212,162,78,0.2);
            margin-bottom: 12px;
            text-align: center;
        }
        .play-sub {
            font-size: clamp(11px, 1.8vw, 16px);
            color: rgba(255,255,255,0.45);
            margin-bottom: 40px;
            font-weight: 400;
        }
        .play-btn {
            width: 80px; height: 80px;
            border: 3px solid #d4a24e;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: pulse 2s ease-in-out infinite;
        }
        .play-btn::after {
            content: '';
            display: block;
            width: 0; height: 0;
            border-style: solid;
            border-width: 18px 0 18px 30px;
            border-color: transparent transparent transparent #d4a24e;
            margin-left: 6px;
        }
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(212,162,78,0.4); }
            50% { box-shadow: 0 0 0 20px rgba(212,162,78,0); }
        }
        .back-link {
            position: fixed;
            top: 12px; left: 12px;
            z-index: 30;
            color: rgba(255,255,255,0.4);
            text-decoration: none;
            font-size: 13px;
            padding: 6px 10px;
            border-radius: 6px;
            background: rgba(0,0,0,0.4);
            transition: color 0.2s;
            font-family: sans-serif;
        }
        .back-link:hover { color: rgba(255,255,255,0.8); }
    </style>
</head>
<body>
    <a href="music-videos/index.html" class="back-link">&larr; Music Videos</a>
    <canvas id="viz-canvas"></canvas>
    <div class="play-overlay" id="play-overlay">
        <div class="play-title">Oasis of the Forgotten King</div>
        <div class="play-sub">a desert journey in chiptune</div>
        <div class="play-btn"></div>
    </div>

    <script src="../audio-tracker/playback-engine.js"></script>
    <script src="engine.js"></script>
    <script>
    // ── Oasis of the Forgotten King — Video Renderer ──────────────────
    window.Renderers['oasis-forgotten-king-video'] = (function() {
        "use strict";

        var W = 0, H = 0;
        var analysis = null;

        // ── Scene enum ──
        // desert, oasis, descent, spectral, lament, throne, departure, silence
        var scene = 'desert';
        var sceneProgress = 0;   // 0-1 progress within current scene
        var sceneTransition = 0; // 0-1 blending between scenes
        var prevScene = 'desert';

        // ── Palette ──
        var PAL = {
            desertSky:    ['#1a0f05', '#4a2510', '#c2691d', '#e8a840', '#f5d98a'],
            desertSand:   '#d4a24e',
            desertDark:   '#1a0f05',
            oasisWater:   '#2d8a9e',
            oasisGreen:   '#3a7a3a',
            underwaterBg: '#0a2a3a',
            underwaterLight: '#1a6a7e',
            spectralPurple: '#6a3d8a',
            spectralSilver: '#b8b8d0',
            spectralGlow: '#9a6abf',
            ghostWhite:   'rgba(180,180,210,0.4)',
            lamentGold:   '#d4a24e',
            crownGold:    '#f5d98a',
            returnWarm:   '#c2691d'
        };

        // ── State ──
        var lastBeat = -1;
        var beatPulse = 0;
        var lastSeqIndex = -1;
        var totalTime = 0;

        // Traveler
        var travelerX = 0;
        var travelerTargetX = 0;
        var travelerY = 0;

        // Dune particles
        var sandParticles = [];
        var NUM_SAND = 60;

        // Stars
        var stars = [];
        var NUM_STARS = 80;

        // Ghost figures
        var ghosts = [];
        var NUM_GHOSTS = 8;

        // Water ripples
        var ripples = [];

        // Spectral particles
        var spectralMotes = [];
        var NUM_MOTES = 50;

        // Title
        var titleAlpha = 0;
        var titleTarget = 0;
        var subtitleText = '';

        // Scene-specific
        var waterLevel = 0;       // 0 = surface, 1 = submerged
        var waterTarget = 0;
        var kingCrownTilt = 0;
        var throneGlow = 0;
        var departureFade = 1;

        // ── Section mapping from sequence index ──
        // seq 0-1: Thirst (desert approach)
        // seq 2: Thirst->Oasis Bridge
        // seq 3-7: Oasis (arrival, lingering)
        // seq 8-9: Hidden Entrance (descent begins)
        // seq 10: Hidden->Spectral Bridge
        // seq 11-15: Spectral Court
        // seq 16: Spectral->Lament Dissolve
        // seq 17-24: King's Lament + Throne Crumbles
        // seq 25-26: Throne Crumbles
        // seq 27: Throne->Departure Bridge
        // seq 28-30: Departure
        // seq 31: Departure Fade
        // seq 32: Silent Footsteps
        function mapScene(seqIdx) {
            if (seqIdx <= 1) return 'desert';
            if (seqIdx <= 2) return 'oasis-approach';
            if (seqIdx <= 7) return 'oasis';
            if (seqIdx <= 9) return 'descent';
            if (seqIdx <= 10) return 'descent-deep';
            if (seqIdx <= 15) return 'spectral';
            if (seqIdx <= 16) return 'lament-transition';
            if (seqIdx <= 22) return 'lament';
            if (seqIdx <= 26) return 'throne';
            if (seqIdx <= 27) return 'departure-bridge';
            if (seqIdx <= 30) return 'departure';
            return 'silence';
        }

        // ── Helpers ──
        function lerp(a, b, t) { return a + (b - a) * t; }
        function lerpExp(cur, tgt, speed, dt) {
            return cur + (tgt - cur) * (1 - Math.exp(-speed * dt));
        }
        function hexToRgb(hex) {
            var r = parseInt(hex.slice(1,3), 16);
            var g = parseInt(hex.slice(3,5), 16);
            var b = parseInt(hex.slice(5,7), 16);
            return [r, g, b];
        }
        function rgba(r, g, b, a) {
            return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
        }

        // ── Init arrays ──
        function initParticles() {
            sandParticles = [];
            for (var i = 0; i < NUM_SAND; i++) {
                sandParticles.push({
                    x: Math.random() * W,
                    y: Math.random() * H,
                    vx: 20 + Math.random() * 60,
                    vy: -5 + Math.random() * 10,
                    size: 1 + Math.random() * 2,
                    alpha: 0.1 + Math.random() * 0.3
                });
            }
            stars = [];
            for (var s = 0; s < NUM_STARS; s++) {
                stars.push({
                    x: Math.random() * W,
                    y: Math.random() * H * 0.5,
                    size: 0.5 + Math.random() * 1.5,
                    twinkle: Math.random() * Math.PI * 2,
                    speed: 0.5 + Math.random() * 2
                });
            }
            ghosts = [];
            for (var g = 0; g < NUM_GHOSTS; g++) {
                ghosts.push({
                    x: W * 0.2 + Math.random() * W * 0.6,
                    y: H * 0.4 + Math.random() * H * 0.3,
                    sway: Math.random() * Math.PI * 2,
                    height: 40 + Math.random() * 50,
                    alpha: 0,
                    type: g < 2 ? 'musician' : (g < 3 ? 'king' : 'courtier')
                });
            }
            spectralMotes = [];
            for (var m = 0; m < NUM_MOTES; m++) {
                spectralMotes.push({
                    x: Math.random() * W,
                    y: Math.random() * H,
                    vx: -10 + Math.random() * 20,
                    vy: -30 - Math.random() * 30,
                    size: 1 + Math.random() * 3,
                    alpha: 0.1 + Math.random() * 0.4,
                    hue: Math.random() > 0.5 ? 270 : 45 // purple or gold
                });
            }
            ripples = [];
        }

        // ── Draw: Desert Sky ──
        function drawDesertSky(ctx, energy, timeFrac) {
            var grad = ctx.createLinearGradient(0, 0, 0, H * 0.7);
            var intensity = 0.5 + energy * 0.3;
            grad.addColorStop(0, PAL.desertSky[0]);
            grad.addColorStop(0.3, PAL.desertSky[1]);
            grad.addColorStop(0.6, PAL.desertSky[2]);
            grad.addColorStop(0.85, PAL.desertSky[3]);
            grad.addColorStop(1, PAL.desertSky[4]);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, W, H * 0.7);

            // Sun
            var sunX = W * 0.7;
            var sunY = H * 0.18;
            var sunR = W * 0.04 + beatPulse * 5;
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            var sunGrad = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunR * 3);
            sunGrad.addColorStop(0, 'rgba(245,217,138,' + (0.5 + energy * 0.3) + ')');
            sunGrad.addColorStop(0.3, 'rgba(232,168,64,' + (0.2 + energy * 0.15) + ')');
            sunGrad.addColorStop(1, 'rgba(232,168,64,0)');
            ctx.fillStyle = sunGrad;
            ctx.fillRect(sunX - sunR * 3, sunY - sunR * 3, sunR * 6, sunR * 6);
            ctx.fillStyle = '#f5d98a';
            ctx.beginPath();
            ctx.arc(sunX, sunY, sunR, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        // ── Draw: Stars (for night/underground scenes) ──
        function drawStars(ctx, alpha) {
            if (alpha < 0.01) return;
            ctx.save();
            ctx.fillStyle = '#fff';
            for (var i = 0; i < stars.length; i++) {
                var s = stars[i];
                var tw = Math.sin(s.twinkle + totalTime * s.speed) * 0.5 + 0.5;
                ctx.globalAlpha = alpha * tw * 0.6;
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        // ── Draw: Sand Dunes ──
        function drawDunes(ctx, energy) {
            var baseY = H * 0.55;
            ctx.save();

            // Far dunes
            ctx.fillStyle = '#8a5a20';
            ctx.beginPath();
            ctx.moveTo(0, baseY + 30);
            for (var x = 0; x <= W; x += 4) {
                var y = baseY + 30 + Math.sin(x * 0.004 + 0.5) * 30 + Math.sin(x * 0.008 + 1.2) * 15;
                ctx.lineTo(x, y);
            }
            ctx.lineTo(W, H);
            ctx.lineTo(0, H);
            ctx.fill();

            // Near dunes
            ctx.fillStyle = PAL.desertSand;
            ctx.beginPath();
            ctx.moveTo(0, baseY + 60);
            for (var x2 = 0; x2 <= W; x2 += 4) {
                var y2 = baseY + 60 + Math.sin(x2 * 0.003 + 2) * 35 + Math.sin(x2 * 0.009) * 20;
                ctx.lineTo(x2, y2);
            }
            ctx.lineTo(W, H);
            ctx.lineTo(0, H);
            ctx.fill();

            // Heat shimmer
            if (energy > 0.1) {
                ctx.globalAlpha = 0.03 + energy * 0.04;
                ctx.globalCompositeOperation = 'lighter';
                for (var sh = 0; sh < 8; sh++) {
                    var shY = baseY + 20 + sh * 15;
                    var shX = Math.sin(totalTime * 1.5 + sh * 0.7) * 30;
                    ctx.fillStyle = '#f5d98a';
                    ctx.fillRect(shX, shY, W, 2);
                }
            }

            ctx.restore();
        }

        // ── Draw: Oasis (palm trees + water) ──
        function drawOasis(ctx, energy) {
            var oasisCX = W * 0.5;
            var oasisY = H * 0.62;
            var waterW = W * 0.35;
            var waterH = H * 0.08;

            // Water
            ctx.save();
            var wGrad = ctx.createRadialGradient(oasisCX, oasisY, 0, oasisCX, oasisY, waterW * 0.6);
            wGrad.addColorStop(0, 'rgba(45,138,158,0.7)');
            wGrad.addColorStop(0.7, 'rgba(45,138,158,0.3)');
            wGrad.addColorStop(1, 'rgba(45,138,158,0)');
            ctx.fillStyle = wGrad;
            ctx.beginPath();
            ctx.ellipse(oasisCX, oasisY, waterW * 0.5, waterH, 0, 0, Math.PI * 2);
            ctx.fill();

            // Water shimmer
            ctx.globalCompositeOperation = 'lighter';
            for (var wr = 0; wr < 5; wr++) {
                var ripR = 10 + wr * 15 + Math.sin(totalTime * 2 + wr) * 5;
                ctx.strokeStyle = 'rgba(100,200,220,' + (0.1 + beatPulse * 0.1) + ')';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.ellipse(oasisCX, oasisY, ripR, ripR * 0.3, 0, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.restore();

            // Palm trees
            drawPalmTree(ctx, oasisCX - waterW * 0.35, oasisY - 10, 80 + energy * 10);
            drawPalmTree(ctx, oasisCX + waterW * 0.3, oasisY - 5, 70 + energy * 10);
            drawPalmTree(ctx, oasisCX - waterW * 0.1, oasisY - 15, 90 + energy * 10);
        }

        function drawPalmTree(ctx, x, y, height) {
            ctx.save();
            // Trunk
            ctx.strokeStyle = '#5a3a1a';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(x, y);
            var topX = x + Math.sin(totalTime * 0.5) * 3;
            var topY = y - height;
            ctx.quadraticCurveTo(x + 5, y - height * 0.5, topX, topY);
            ctx.stroke();

            // Fronds
            ctx.strokeStyle = PAL.oasisGreen;
            ctx.lineWidth = 2;
            for (var f = 0; f < 6; f++) {
                var angle = (f / 6) * Math.PI * 2 + totalTime * 0.3;
                var frondLen = 25 + Math.sin(angle + totalTime) * 8;
                var fx = topX + Math.cos(angle) * frondLen;
                var fy = topY + Math.sin(angle) * frondLen * 0.4 + Math.abs(Math.cos(angle)) * 10;
                ctx.beginPath();
                ctx.moveTo(topX, topY);
                ctx.quadraticCurveTo(
                    topX + Math.cos(angle) * frondLen * 0.6,
                    topY + Math.sin(angle) * frondLen * 0.2,
                    fx, fy
                );
                ctx.stroke();
            }
            ctx.restore();
        }

        // ── Draw: Traveler silhouette ──
        function drawTraveler(ctx, x, y, scale, alpha) {
            if (alpha < 0.01) return;
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(scale, scale);
            ctx.globalAlpha = alpha;

            var color = '#0a0804';

            // Body
            ctx.fillStyle = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';

            // Head
            ctx.beginPath();
            ctx.arc(0, -55, 6, 0, Math.PI * 2);
            ctx.fill();

            // Hood/cloak outline
            ctx.beginPath();
            ctx.moveTo(-4, -60);
            ctx.quadraticCurveTo(-10, -55, -8, -48);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(4, -60);
            ctx.quadraticCurveTo(10, -55, 8, -48);
            ctx.stroke();

            // Body (cloak)
            ctx.beginPath();
            ctx.moveTo(-8, -48);
            ctx.lineTo(-12, 0);
            ctx.lineTo(12, 0);
            ctx.lineTo(8, -48);
            ctx.closePath();
            ctx.fill();

            // Walking staff
            var staffLean = Math.sin(totalTime * 2) * 3;
            ctx.beginPath();
            ctx.moveTo(10 + staffLean, -40);
            ctx.lineTo(14 + staffLean, 5);
            ctx.stroke();

            // Walking legs (subtle)
            var legPhase = totalTime * 3;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-4 + Math.sin(legPhase) * 4, 12);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(4 + Math.sin(legPhase + Math.PI) * 4, 12);
            ctx.stroke();

            ctx.restore();
        }

        // ── Draw: Underwater / Underground scene ──
        function drawUnderwater(ctx, depth, energy) {
            // Background gradient
            var grad = ctx.createLinearGradient(0, 0, 0, H);
            var d = Math.min(1, depth);
            grad.addColorStop(0, 'rgba(10,42,58,' + d + ')');
            grad.addColorStop(0.5, 'rgba(15,60,80,' + d + ')');
            grad.addColorStop(1, 'rgba(5,25,40,' + d + ')');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, W, H);

            // Caustics / light rays
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = d * (0.04 + energy * 0.06);
            for (var r = 0; r < 6; r++) {
                var rx = W * 0.3 + r * W * 0.08 + Math.sin(totalTime * 0.8 + r * 1.3) * 40;
                var grad2 = ctx.createLinearGradient(rx, 0, rx + 30, H);
                grad2.addColorStop(0, 'rgba(100,200,220,0.4)');
                grad2.addColorStop(1, 'rgba(100,200,220,0)');
                ctx.fillStyle = grad2;
                ctx.beginPath();
                ctx.moveTo(rx - 5, 0);
                ctx.lineTo(rx + 5, 0);
                ctx.lineTo(rx + 40, H);
                ctx.lineTo(rx - 20, H);
                ctx.fill();
            }
            ctx.restore();

            // Bubbles
            ctx.save();
            ctx.strokeStyle = 'rgba(100,200,220,0.3)';
            ctx.lineWidth = 1;
            for (var b = 0; b < 15; b++) {
                var bx = W * 0.2 + (b / 15) * W * 0.6;
                var by = H - ((totalTime * 40 + b * 80) % (H + 40));
                var br = 2 + Math.sin(b * 3.14) * 2;
                ctx.globalAlpha = d * 0.3;
                ctx.beginPath();
                ctx.arc(bx + Math.sin(totalTime + b) * 10, by, br, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.restore();

            // Palace ruins (columns)
            if (depth > 0.3) {
                drawRuins(ctx, depth, energy);
            }
        }

        // ── Draw: Submerged Palace Ruins ──
        function drawRuins(ctx, depth, energy) {
            ctx.save();
            var ruinAlpha = Math.min(1, (depth - 0.3) / 0.4);
            ctx.globalAlpha = ruinAlpha * 0.6;

            var floorY = H * 0.85;
            var colColor = 'rgba(120,100,80,0.5)';

            // Floor tiles
            ctx.fillStyle = 'rgba(80,65,50,0.3)';
            ctx.fillRect(W * 0.15, floorY, W * 0.7, H * 0.05);

            // Columns
            for (var c = 0; c < 6; c++) {
                var cx = W * 0.2 + c * W * 0.12;
                var colH = 100 + Math.sin(c * 1.7) * 30;
                // Some columns are broken
                var broken = c === 2 || c === 4;
                var drawH = broken ? colH * 0.5 : colH;

                ctx.fillStyle = colColor;
                ctx.fillRect(cx - 5, floorY - drawH, 10, drawH);

                // Capital
                if (!broken) {
                    ctx.fillRect(cx - 8, floorY - drawH - 5, 16, 5);
                }

                // Rubble for broken columns
                if (broken) {
                    ctx.fillStyle = 'rgba(100,80,60,0.3)';
                    for (var rb = 0; rb < 4; rb++) {
                        ctx.fillRect(
                            cx - 10 + Math.sin(rb * 2.1) * 12,
                            floorY - 5 - rb * 4,
                            6 + rb * 2, 4
                        );
                    }
                }
            }

            // Archway in the center
            ctx.strokeStyle = 'rgba(140,120,90,0.4)';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.arc(W * 0.5, floorY - 80, 50, Math.PI, 0);
            ctx.stroke();

            ctx.restore();
        }

        // ── Draw: Ghost Figures ──
        function drawGhosts(ctx, intensity, isLament) {
            ctx.save();
            for (var i = 0; i < ghosts.length; i++) {
                var g = ghosts[i];
                if (g.alpha < 0.01) continue;

                var gx = g.x + Math.sin(g.sway + totalTime * 0.7) * 8;
                var gy = g.y + Math.sin(g.sway + totalTime * 0.5 + 1) * 4;
                var ga = g.alpha * (0.3 + intensity * 0.4 + beatPulse * 0.2);

                ctx.save();
                ctx.translate(gx, gy);
                ctx.globalAlpha = ga;

                if (g.type === 'king') {
                    drawGhostKing(ctx, g.height, isLament);
                } else if (g.type === 'musician') {
                    drawGhostMusician(ctx, g.height, i);
                } else {
                    drawGhostCourtier(ctx, g.height);
                }

                ctx.restore();
            }
            ctx.restore();
        }

        function drawGhostKing(ctx, h, isLament) {
            var col = PAL.spectralSilver;

            // Glow
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            var glow = ctx.createRadialGradient(0, -h * 0.5, 0, 0, -h * 0.5, h * 0.8);
            glow.addColorStop(0, 'rgba(154,106,191,' + (0.1 + throneGlow * 0.15) + ')');
            glow.addColorStop(1, 'rgba(154,106,191,0)');
            ctx.fillStyle = glow;
            ctx.fillRect(-h, -h * 1.3, h * 2, h * 1.5);
            ctx.restore();

            ctx.strokeStyle = col;
            ctx.fillStyle = col;
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';

            // Head
            ctx.beginPath();
            ctx.arc(0, -h + 8, 8, 0, Math.PI * 2);
            ctx.stroke();

            // Crown (tilted during lament)
            ctx.save();
            ctx.translate(0, -h);
            ctx.rotate(kingCrownTilt * 0.3);
            ctx.beginPath();
            ctx.moveTo(-8, 0);
            ctx.lineTo(-10, -10);
            ctx.lineTo(-5, -6);
            ctx.lineTo(0, -12);
            ctx.lineTo(5, -6);
            ctx.lineTo(10, -10);
            ctx.lineTo(8, 0);
            ctx.strokeStyle = PAL.crownGold;
            ctx.fillStyle = 'rgba(245,217,138,0.3)';
            ctx.fill();
            ctx.stroke();
            ctx.restore();

            // Robe (wider for king)
            ctx.beginPath();
            ctx.moveTo(-6, -h + 16);
            ctx.lineTo(-16, 0);
            ctx.lineTo(16, 0);
            ctx.lineTo(6, -h + 16);
            ctx.closePath();
            ctx.fillStyle = 'rgba(154,106,191,0.15)';
            ctx.fill();
            ctx.strokeStyle = col;
            ctx.stroke();

            // Throne outline behind
            ctx.save();
            ctx.globalAlpha = 0.2;
            ctx.strokeStyle = PAL.spectralPurple;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(-22, 5);
            ctx.lineTo(-22, -h - 15);
            ctx.lineTo(-15, -h - 20);
            ctx.lineTo(15, -h - 20);
            ctx.lineTo(22, -h - 15);
            ctx.lineTo(22, 5);
            ctx.stroke();
            ctx.restore();
        }

        function drawGhostMusician(ctx, h, index) {
            var col = PAL.spectralSilver;
            ctx.strokeStyle = col;
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';

            // Head
            ctx.beginPath();
            ctx.arc(0, -h + 6, 5, 0, Math.PI * 2);
            ctx.stroke();

            // Body
            ctx.beginPath();
            ctx.moveTo(0, -h + 11);
            ctx.lineTo(0, -h * 0.3);
            ctx.stroke();

            // Arms holding instrument
            var armWave = Math.sin(totalTime * 3 + index * 2) * 5;
            ctx.beginPath();
            ctx.moveTo(0, -h * 0.6);
            ctx.lineTo(-12 + armWave, -h * 0.4);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, -h * 0.6);
            ctx.lineTo(12 - armWave, -h * 0.4);
            ctx.stroke();

            // Instrument (simplified lute/pipe shape)
            if (index % 2 === 0) {
                // Pipe
                ctx.beginPath();
                ctx.moveTo(12 - armWave, -h * 0.45);
                ctx.lineTo(20 - armWave, -h * 0.55);
                ctx.stroke();
            } else {
                // Lute body
                ctx.beginPath();
                ctx.arc(-12 + armWave, -h * 0.35, 6, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Legs
            ctx.beginPath();
            ctx.moveTo(0, -h * 0.3);
            ctx.lineTo(-5, 0);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, -h * 0.3);
            ctx.lineTo(5, 0);
            ctx.stroke();
        }

        function drawGhostCourtier(ctx, h) {
            var col = PAL.ghostWhite;
            ctx.strokeStyle = PAL.spectralSilver;
            ctx.lineWidth = 1.5;
            ctx.lineCap = 'round';

            // Head
            ctx.beginPath();
            ctx.arc(0, -h + 5, 4, 0, Math.PI * 2);
            ctx.stroke();

            // Robed body (simple triangle)
            ctx.beginPath();
            ctx.moveTo(-4, -h + 9);
            ctx.lineTo(-10, 0);
            ctx.lineTo(10, 0);
            ctx.lineTo(4, -h + 9);
            ctx.closePath();
            ctx.fillStyle = 'rgba(180,180,210,0.08)';
            ctx.fill();
            ctx.stroke();
        }

        // ── Draw: Spectral Motes ──
        function drawMotes(ctx, intensity) {
            ctx.save();
            for (var i = 0; i < spectralMotes.length; i++) {
                var m = spectralMotes[i];
                var hue = m.hue;
                var a = m.alpha * intensity;
                if (a < 0.01) continue;

                ctx.globalAlpha = a;
                ctx.globalCompositeOperation = 'lighter';

                if (hue === 270) {
                    ctx.fillStyle = 'rgba(154,106,191,' + a + ')';
                    ctx.shadowColor = PAL.spectralGlow;
                } else {
                    ctx.fillStyle = 'rgba(212,162,78,' + a + ')';
                    ctx.shadowColor = PAL.lamentGold;
                }
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(m.x, m.y, m.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;
            ctx.restore();
        }

        // ── Draw: Sand particles blowing ──
        function drawSandParticles(ctx, intensity) {
            ctx.save();
            ctx.fillStyle = '#e8a840';
            for (var i = 0; i < sandParticles.length; i++) {
                var p = sandParticles[i];
                ctx.globalAlpha = p.alpha * intensity;
                ctx.fillRect(p.x, p.y, p.size, p.size * 0.5);
            }
            ctx.restore();
        }

        // ── Draw: Title text ──
        function drawTitle(ctx) {
            if (titleAlpha < 0.01) return;
            ctx.save();
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.globalAlpha = titleAlpha;

            var fontSize = Math.max(16, Math.min(W * 0.035, 40));
            ctx.font = '700 ' + fontSize + 'px "Cinzel", serif';

            // Glow
            ctx.shadowColor = PAL.lamentGold;
            ctx.shadowBlur = 30;
            ctx.fillStyle = PAL.lamentGold;
            ctx.fillText('OASIS OF THE FORGOTTEN KING', W * 0.5, H * 0.12);

            // White overlay
            ctx.shadowBlur = 0;
            ctx.globalAlpha = titleAlpha * 0.5;
            ctx.fillStyle = '#fff';
            ctx.fillText('OASIS OF THE FORGOTTEN KING', W * 0.5, H * 0.12);

            // Subtitle
            if (subtitleText) {
                ctx.globalAlpha = titleAlpha * 0.5;
                ctx.font = '400 ' + Math.floor(fontSize * 0.5) + 'px "Cinzel", serif';
                ctx.fillStyle = PAL.spectralSilver;
                ctx.shadowBlur = 0;
                ctx.fillText(subtitleText, W * 0.5, H * 0.12 + fontSize * 0.8);
            }

            ctx.restore();
        }

        // ── Update particles ──
        function updateParticles(dt, energy) {
            // Sand
            for (var i = 0; i < sandParticles.length; i++) {
                var p = sandParticles[i];
                p.x += p.vx * dt * (0.5 + energy);
                p.y += p.vy * dt;
                if (p.x > W + 10) { p.x = -10; p.y = H * 0.4 + Math.random() * H * 0.4; }
            }
            // Motes
            for (var j = 0; j < spectralMotes.length; j++) {
                var m = spectralMotes[j];
                m.x += m.vx * dt;
                m.y += m.vy * dt * (0.3 + energy * 0.7);
                if (m.y < -10) { m.y = H + 10; m.x = Math.random() * W; }
                if (m.x < -10 || m.x > W + 10) { m.x = Math.random() * W; }
            }
        }

        // ── Init ──
        function init(ctx, width, height, anal) {
            W = width; H = height;
            analysis = anal;
            totalTime = 0;
            lastBeat = -1;
            lastSeqIndex = -1;
            scene = 'desert';
            prevScene = 'desert';
            sceneTransition = 0;
            waterLevel = 0;
            waterTarget = 0;
            travelerX = W * 0.15;
            travelerTargetX = W * 0.15;
            travelerY = H * 0.72;
            titleAlpha = 0;
            titleTarget = 0;
            departureFade = 1;
            kingCrownTilt = 0;
            throneGlow = 0;
            initParticles();
        }

        // ── Resize ──
        function resize(width, height) {
            W = width; H = height;
            initParticles();
        }

        // ── Main render ──
        function render(frameData) {
            var ctx = frameData.ctx;
            var dt = frameData.dt || 1/60;
            var cursor = frameData.cursor;

            totalTime += dt;

            // ── Background clear ──
            ctx.fillStyle = PAL.desertDark;
            ctx.fillRect(0, 0, W, H);

            if (!cursor) {
                // Idle: static desert
                drawDesertSky(ctx, 0, 0);
                drawDunes(ctx, 0);
                drawTraveler(ctx, W * 0.3, H * 0.72, 1, 0.8);
                return;
            }

            var beat = cursor.beat;
            var seqIdx = cursor.seqIndex;
            var energy = analysis ? (analysis.energy[cursor.timelineIndex] || 0) : 0;

            // ── Beat pulse ──
            if (beat !== lastBeat) {
                beatPulse = 1;
                lastBeat = beat;
            }
            beatPulse *= Math.exp(-6 * dt);

            // ── Scene transitions ──
            var newScene = mapScene(seqIdx);
            if (seqIdx !== lastSeqIndex) {
                if (newScene !== scene) {
                    prevScene = scene;
                    scene = newScene;
                    sceneTransition = 0;
                }
                lastSeqIndex = seqIdx;

                // Update ghost visibility based on scene
                for (var gi = 0; gi < ghosts.length; gi++) {
                    if (scene === 'spectral' || scene === 'lament' || scene === 'lament-transition' || scene === 'throne') {
                        ghosts[gi].alpha = 0.5 + Math.random() * 0.5;
                    } else {
                        ghosts[gi].alpha = 0;
                    }
                }
            }
            sceneTransition = Math.min(1, sceneTransition + dt * 0.8);

            // ── Traveler position based on scene ──
            if (scene === 'desert') {
                travelerTargetX = W * 0.15 + (seqIdx / 2) * W * 0.15;
                travelerY = H * 0.72;
            } else if (scene === 'oasis-approach') {
                travelerTargetX = W * 0.4;
                travelerY = H * 0.70;
            } else if (scene === 'oasis') {
                travelerTargetX = W * 0.48;
                travelerY = H * 0.68;
            } else if (scene === 'descent' || scene === 'descent-deep') {
                travelerTargetX = W * 0.5;
                travelerY = H * 0.5 + waterLevel * H * 0.2;
            } else if (scene === 'departure' || scene === 'departure-bridge') {
                travelerTargetX = W * 0.5 + (seqIdx - 27) * W * 0.08;
                travelerY = H * 0.72;
            } else if (scene === 'silence') {
                travelerTargetX = W * 0.85;
                travelerY = H * 0.72;
            }
            travelerX = lerpExp(travelerX, travelerTargetX, 2, dt);

            // ── Water level ──
            if (scene === 'descent') {
                waterTarget = 0.5;
            } else if (scene === 'descent-deep' || scene === 'spectral') {
                waterTarget = 1;
            } else if (scene === 'lament-transition' || scene === 'lament' || scene === 'throne') {
                waterTarget = 1;
            } else if (scene === 'departure-bridge' || scene === 'departure') {
                waterTarget = lerpExp(waterTarget, 0, 1.5, dt);
            } else {
                waterTarget = 0;
            }
            waterLevel = lerpExp(waterLevel, waterTarget, 1.5, dt);

            // ── Title and subtitle ──
            if (scene === 'oasis' && sceneTransition > 0.5) {
                titleTarget = 1;
                subtitleText = 'The Traveler Arrives';
            } else if (scene === 'spectral') {
                titleTarget = 1;
                subtitleText = 'The Spectral Court';
            } else if (scene === 'lament' || scene === 'lament-transition') {
                titleTarget = 1;
                subtitleText = "The King's Lament";
            } else if (scene === 'throne') {
                titleTarget = 1;
                subtitleText = 'The Throne Crumbles';
            } else if (scene === 'departure' || scene === 'departure-bridge') {
                titleTarget = 0.5;
                subtitleText = 'Departure';
            } else {
                titleTarget = 0;
                subtitleText = '';
            }
            titleAlpha = lerpExp(titleAlpha, titleTarget, 3, dt);

            // ── King crown tilt during lament ──
            if (scene === 'lament' || scene === 'throne') {
                kingCrownTilt = lerpExp(kingCrownTilt, 0.5 + energy * 0.3, 2, dt);
                throneGlow = 0.4 + energy * 0.4 + beatPulse * 0.3;
            } else {
                kingCrownTilt = lerpExp(kingCrownTilt, 0, 2, dt);
                throneGlow = lerpExp(throneGlow, 0, 3, dt);
            }

            // ── Departure fade ──
            if (scene === 'silence') {
                departureFade = lerpExp(departureFade, 0, 0.5, dt);
            } else {
                departureFade = 1;
            }

            // ── Update ──
            updateParticles(dt, energy);

            // ── DRAW LAYERS ──

            var isDesertScene = (scene === 'desert' || scene === 'oasis-approach' || scene === 'oasis' ||
                                 scene === 'departure' || scene === 'departure-bridge' || scene === 'silence');
            var isUnderwaterScene = (scene === 'descent' || scene === 'descent-deep' || scene === 'spectral' ||
                                     scene === 'lament-transition' || scene === 'lament' || scene === 'throne');

            // Blend between desert and underwater
            if (waterLevel < 0.95) {
                ctx.save();
                ctx.globalAlpha = 1 - waterLevel;
                drawDesertSky(ctx, energy, totalTime);
                drawStars(ctx, scene === 'desert' ? 0.3 : 0);
                drawDunes(ctx, energy);
                if (isDesertScene && (scene === 'oasis-approach' || scene === 'oasis')) {
                    drawOasis(ctx, energy);
                }
                drawSandParticles(ctx, isDesertScene ? (0.3 + energy * 0.5) : 0);
                ctx.restore();
            }

            if (waterLevel > 0.05) {
                drawUnderwater(ctx, waterLevel, energy);
            }

            // Ghost figures (spectral/lament scenes)
            if (isUnderwaterScene || scene === 'lament-transition') {
                var ghostIntensity = 0;
                if (scene === 'spectral') ghostIntensity = 0.8;
                else if (scene === 'lament' || scene === 'lament-transition') ghostIntensity = 1;
                else if (scene === 'throne') ghostIntensity = 0.6 + beatPulse * 0.3;
                else if (scene === 'descent-deep') ghostIntensity = 0.2;
                drawGhosts(ctx, ghostIntensity, scene === 'lament' || scene === 'throne');
                drawMotes(ctx, ghostIntensity * (0.5 + energy * 0.5));
            }

            // Return to surface scenes
            if (scene === 'departure' || scene === 'departure-bridge' || scene === 'silence') {
                ctx.save();
                ctx.globalAlpha = departureFade;
                drawDesertSky(ctx, energy * 0.5, totalTime);
                drawDunes(ctx, energy * 0.3);
                // Fading motes still visible during departure
                drawMotes(ctx, 0.2 * departureFade);
                ctx.restore();
            }

            // Traveler
            var travelerAlpha = 1;
            var travelerScale = 1;
            if (scene === 'desert') {
                travelerAlpha = 0.9;
                travelerScale = 0.7 + sceneTransition * 0.3;
            } else if (scene === 'descent' || scene === 'descent-deep') {
                travelerAlpha = 0.6;
                travelerScale = 0.8;
            } else if (isUnderwaterScene) {
                travelerAlpha = 0.3;
                travelerScale = 0.6;
            } else if (scene === 'silence') {
                travelerAlpha = departureFade * 0.8;
            }
            drawTraveler(ctx, travelerX, travelerY, travelerScale, travelerAlpha);

            // Title
            drawTitle(ctx);

            // Vignette
            drawVignette(ctx, energy);

            // Scene-specific overlays
            if (scene === 'throne') {
                // Screen shake on heavy beats
                if (beatPulse > 0.5) {
                    ctx.save();
                    ctx.globalAlpha = beatPulse * 0.08;
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(0, 0, W, H);
                    ctx.restore();
                }
            }
        }

        function drawVignette(ctx, energy) {
            ctx.save();
            var vigR = Math.max(W, H) * 0.7;
            var vig = ctx.createRadialGradient(W * 0.5, H * 0.5, vigR * 0.3, W * 0.5, H * 0.5, vigR);
            vig.addColorStop(0, 'rgba(0,0,0,0)');
            vig.addColorStop(1, 'rgba(0,0,0,' + (0.4 + energy * 0.15) + ')');
            ctx.fillStyle = vig;
            ctx.fillRect(0, 0, W, H);
            ctx.restore();
        }

        return {
            name: 'Oasis of the Forgotten King',
            init: init,
            render: render,
            resize: resize
        };
    })();

    // ── Page bootstrap ──
    (function() {
        var canvas = document.getElementById('viz-canvas');
        var overlay = document.getElementById('play-overlay');

        Visualizer.init(canvas);
        Visualizer.setRenderer('oasis-forgotten-king-video');

        function loadAndPlay(json) {
            Visualizer.loadSong(json);
            Visualizer.play();
        }

        function fetchSong() {
            var url = '../audio-tracker/songs/oasis-of-the-forgotten-king.json';
            if (window.fetch && location.protocol !== 'file:') {
                return fetch(url).then(function(r) { return r.json(); });
            }
            return new Promise(function(resolve, reject) {
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.onload = function() {
                    if (xhr.status === 200 || xhr.status === 0) {
                        resolve(JSON.parse(xhr.responseText));
                    } else {
                        reject(new Error('XHR failed: ' + xhr.status));
                    }
                };
                xhr.onerror = function() { reject(new Error('XHR error')); };
                xhr.send();
            });
        }

        overlay.addEventListener('click', function() {
            overlay.classList.add('hidden');
            fetchSong().then(loadAndPlay).catch(function(err) {
                console.error('Failed to load song:', err);
                overlay.classList.remove('hidden');
            });
        });

        // Auto-play when embedded (e.g. jukebox iframe with ?autoplay=1)
        if (new URLSearchParams(window.location.search).get('autoplay') === '1') {
            overlay.click();
        }

        canvas.addEventListener('click', function() {
            if (overlay.classList.contains('hidden')) {
                if (Visualizer.isPlaying()) {
                    Visualizer.stop();
                } else {
                    Visualizer.play();
                }
            }
        });
    })();
    </script>
</body>
</html>
