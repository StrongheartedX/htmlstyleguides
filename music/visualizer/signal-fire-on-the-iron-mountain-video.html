<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Signal Fire on the Iron Mountain — Music Video</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="video-base-styles.css">
    <style>
        :root {
            --vid-bg: #0a0e1a;
            --vid-bg-rgb: 10,14,26;
            --vid-font: 'Cinzel', serif;
            --vid-accent: #ff8830;
            --vid-accent-r: 255;
            --vid-accent-g: 136;
            --vid-accent-b: 48;
            --vid-overlay-alpha: 0.94;
            --vid-title-weight: 700;
            --vid-title-spacing: 0.10em;
            --vid-sub-font: sans-serif;
        }
    </style>
</head>
<body>
    <a href="music-videos/index.html" class="back-link">&larr; Music Videos</a>
    <canvas id="viz-canvas"></canvas>
    <div class="play-overlay" id="play-overlay">
        <div class="play-title">Signal Fire on the Iron Mountain</div>
        <div class="play-sub">a mountain messenger's journey</div>
        <div class="play-btn"></div>
    </div>

    <script src="../audio-tracker/playback-engine.js"></script>
    <script src="engine.js"></script>
    <script src="stick-fight-engine.js"></script>
    <script src="video-utils.js"></script>
    <script src="base-renderer.js"></script>
    <script>
    // ── Signal Fire on the Iron Mountain — Video Renderer ───────────────
    (function() {
        "use strict";

        var W = 0, H = 0;
        var analysis = null;

        // ── Palette ──
        var NIGHT_DARK  = '#0a0e1a';
        var NIGHT_MID   = '#0d1520';
        var FOREST_DARK = '#0a1210';
        var TORCH_CORE  = '#ffaa44';
        var TORCH_OUTER = '#ff8830';
        var TORCH_HOT   = '#ffe080';
        var WOLF_EYE    = '#88cc44';
        var SNOW_WHITE  = '#e8f0ff';
        var SNOW_PALE   = '#c8d8f0';
        var FIRE_GOLD   = '#ffcc00';
        var FIRE_ORANGE = '#ff6600';
        var FIRE_WHITE  = '#ffffff';
        var STAR_COLOR  = '#c8d8ff';
        var MTN_FAR     = '#1a2440';
        var MTN_MID     = '#121830';
        var MTN_NEAR    = '#0a0e1a';
        var CLOUD_COLOR = '#2a3858';

        // ── State ──
        var beatPulse = 0;
        var flashAlpha = 0;
        var scrollX = 0;
        var elapsed = 0;
        var lastSeqIndex = -1;
        var currentScene = 'intro';

        // Runner
        var runnerFig = null;
        var runnerPhase = 0;
        var poseToggle = 0;

        // Mountains — 4 parallax layers
        var mtnLayers = [];
        var MTN_LAYER_COUNT = 4;

        // Trees
        var trees = [];
        var TREE_COUNT = 40;

        // Wolf eyes
        var wolfEyes = [];
        var WOLF_EYE_COUNT = 8;

        // Stars
        var stars = [];
        var STAR_COUNT = 120;

        // Snow particles
        var snowParticles = [];
        var SNOW_COUNT = 80;

        // Torch particles
        var torchParticles = [];
        var TORCH_PARTICLE_MAX = 30;

        // Signal fire
        var signalFireParticles = [];
        var SIGNAL_FIRE_MAX = 100;
        var signalFireIntensity = 0;
        var signalFireTargetIntensity = 0;

        // Chain of distant fires
        var chainFires = [];
        var chainFiresLit = 0;
        var CHAIN_FIRE_COUNT = 12;

        // Scene transition
        var sceneFlash = 0;
        var introFade = 1;
        var outroFade = 0;

        // Sky color targets
        var skyTopR = 10, skyTopG = 14, skyTopB = 26;
        var skyBotR = 13, skyBotG = 21, skyBotB = 32;
        var targetSkyTopR = 10, targetSkyTopG = 14, targetSkyTopB = 26;
        var targetSkyBotR = 13, targetSkyBotG = 21, targetSkyBotB = 32;

        // Bridge gap
        var bridgeGapActive = false;
        var bridgeLeapProgress = 0;

        // Ground Y
        var groundFrac = 0.75;

        // ── Helpers ──
        function lerpColor(hexA, hexB, t) {
            var a = hexToRgb(hexA);
            var b = hexToRgb(hexB);
            var r = Math.round(a.r + (b.r - a.r) * t);
            var g = Math.round(a.g + (b.g - a.g) * t);
            var bl = Math.round(a.b + (b.b - a.b) * t);
            return 'rgb(' + r + ',' + g + ',' + bl + ')';
        }

        function noise(x) {
            // Simple deterministic noise
            var s = Math.sin(x * 127.1) * 43758.5453;
            return s - Math.floor(s);
        }

        function mountainProfile(x, seed, roughness) {
            var y = 0;
            var amp = 1;
            var freq = 0.001;
            for (var o = 0; o < 4; o++) {
                y += Math.sin(x * freq + seed * 17.3 + o * 5.7) * amp;
                y += Math.cos(x * freq * 1.7 + seed * 11.1 + o * 3.3) * amp * 0.5;
                amp *= roughness;
                freq *= 2.1;
            }
            return y;
        }

        // ── Section mapping ──
        // 0-1:  Intro - Lone Horn
        // 2-4:  Intro - Motif Emerges
        // 5-10: Forest Run
        // 11-14: Wolf Eyes
        // 15-20: Wolf Chase
        // 21-23: Broken Bridge + Recovery
        // 24-28: Above the Clouds
        // 29-32: Summit Approach
        // 33-39: Signal Fire!
        // 40-44: Chain of Fires
        // 45-48: Outro - Horizon
        function mapScene(seqIdx) {
            if (seqIdx <= 1)  return 'intro';
            if (seqIdx <= 4)  return 'motif';
            if (seqIdx <= 10) return 'forest';
            if (seqIdx <= 14) return 'wolves';
            if (seqIdx <= 20) return 'chase';
            if (seqIdx <= 23) return 'bridge';
            if (seqIdx <= 28) return 'clouds';
            if (seqIdx <= 32) return 'summit';
            if (seqIdx <= 39) return 'fire';
            if (seqIdx <= 44) return 'chain';
            return 'outro';
        }

        function sceneTreeDensity(scene) {
            if (scene === 'forest' || scene === 'wolves') return 1.0;
            if (scene === 'chase') return 0.6;
            if (scene === 'motif') return 0.3;
            if (scene === 'bridge') return 0.15;
            return 0;
        }

        function sceneShowStars(scene) {
            return scene === 'intro' || scene === 'motif' || scene === 'clouds' ||
                   scene === 'chain' || scene === 'outro';
        }

        function sceneShowSnow(scene) {
            return scene === 'clouds' || scene === 'summit';
        }

        function sceneSkyColors(scene) {
            if (scene === 'intro' || scene === 'motif') {
                return { tr: 8, tg: 10, tb: 22, br: 12, bg: 16, bb: 30 };
            }
            if (scene === 'forest' || scene === 'wolves') {
                return { tr: 6, tg: 12, tb: 14, br: 10, bg: 18, bb: 16 };
            }
            if (scene === 'chase') {
                return { tr: 8, tg: 10, tb: 18, br: 12, bg: 14, bb: 20 };
            }
            if (scene === 'bridge') {
                return { tr: 10, tg: 12, tb: 24, br: 14, bg: 18, bb: 30 };
            }
            if (scene === 'clouds') {
                return { tr: 16, tg: 20, tb: 40, br: 24, bg: 30, bb: 50 };
            }
            if (scene === 'summit') {
                return { tr: 14, tg: 16, tb: 32, br: 20, bg: 24, bb: 40 };
            }
            if (scene === 'fire') {
                return { tr: 40, tg: 20, tb: 10, br: 60, bg: 30, bb: 15 };
            }
            if (scene === 'chain') {
                return { tr: 14, tg: 12, tb: 24, br: 20, bg: 16, bb: 30 };
            }
            // outro
            return { tr: 6, tg: 6, tb: 14, br: 8, bg: 8, bb: 18 };
        }

        // ── Generate mountain layers ──
        function generateMountains() {
            mtnLayers = [];
            for (var i = 0; i < MTN_LAYER_COUNT; i++) {
                var layer = {
                    seed: i * 7.3 + 2.1,
                    parallaxSpeed: 0.15 + i * 0.25,
                    baseY: 0.45 + i * 0.1,
                    amplitude: 0.12 - i * 0.015,
                    roughness: 0.55 + i * 0.05,
                    darkness: 0.3 + i * 0.2
                };
                mtnLayers.push(layer);
            }
        }

        // ── Generate trees ──
        function generateTrees() {
            trees = [];
            for (var i = 0; i < TREE_COUNT; i++) {
                trees.push({
                    baseX: Math.random() * 3000,
                    height: 60 + Math.random() * 100,
                    width: 8 + Math.random() * 12,
                    branchCount: 3 + Math.floor(Math.random() * 4),
                    parallaxSpeed: 0.6 + Math.random() * 0.4
                });
            }
        }

        // ── Generate wolf eyes ──
        function generateWolfEyes() {
            wolfEyes = [];
            for (var i = 0; i < WOLF_EYE_COUNT; i++) {
                wolfEyes.push({
                    baseX: 200 + Math.random() * 2000,
                    y: 0.55 + Math.random() * 0.18,
                    separation: 8 + Math.random() * 6,
                    blinkTimer: Math.random() * 5,
                    blinkDuration: 0.15 + Math.random() * 0.1,
                    blinkInterval: 2 + Math.random() * 4,
                    size: 2 + Math.random() * 2,
                    brightness: 0.5 + Math.random() * 0.5
                });
            }
        }

        // ── Generate stars ──
        function generateStars() {
            stars = [];
            for (var i = 0; i < STAR_COUNT; i++) {
                stars.push({
                    x: Math.random() * W,
                    y: Math.random() * H * 0.5,
                    size: 0.5 + Math.random() * 2,
                    twinklePhase: Math.random() * Math.PI * 2,
                    twinkleSpeed: 1 + Math.random() * 3,
                    brightness: 0.3 + Math.random() * 0.7
                });
            }
        }

        // ── Generate snow ──
        function generateSnow() {
            snowParticles = [];
            for (var i = 0; i < SNOW_COUNT; i++) {
                snowParticles.push({
                    x: Math.random() * W,
                    y: Math.random() * H,
                    size: 1 + Math.random() * 2.5,
                    speedY: 15 + Math.random() * 30,
                    drift: (Math.random() - 0.5) * 25,
                    alpha: 0.3 + Math.random() * 0.5
                });
            }
        }

        // ── Generate chain fires ──
        function generateChainFires() {
            chainFires = [];
            for (var i = 0; i < CHAIN_FIRE_COUNT; i++) {
                var xFrac = 0.05 + (i / (CHAIN_FIRE_COUNT - 1)) * 0.9;
                chainFires.push({
                    x: xFrac,
                    y: 0.30 + Math.sin(i * 1.4 + 0.7) * 0.08 + Math.sin(i * 0.6) * 0.04,
                    lit: false,
                    litAlpha: 0,
                    size: 3 + Math.random() * 3,
                    flickerPhase: Math.random() * Math.PI * 2
                });
            }
            chainFiresLit = 0;
        }

        // ── Draw sky ──
        function drawSky(ctx) {
            var grad = ctx.createLinearGradient(0, 0, 0, H);
            grad.addColorStop(0, 'rgb(' + Math.round(skyTopR) + ',' + Math.round(skyTopG) + ',' + Math.round(skyTopB) + ')');
            grad.addColorStop(1, 'rgb(' + Math.round(skyBotR) + ',' + Math.round(skyBotG) + ',' + Math.round(skyBotB) + ')');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, W, H);
        }

        // ── Draw stars ──
        function drawStars(ctx, alpha) {
            if (alpha < 0.01) return;
            ctx.save();
            for (var i = 0; i < stars.length; i++) {
                var s = stars[i];
                var twinkle = 0.5 + 0.5 * Math.sin(s.twinklePhase + elapsed * s.twinkleSpeed);
                var a = s.brightness * twinkle * alpha;
                if (a < 0.02) continue;
                ctx.globalAlpha = a;
                ctx.fillStyle = STAR_COLOR;
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        // ── Draw mountain layer ──
        function drawMountainLayer(ctx, layer, colorStr) {
            var offset = scrollX * layer.parallaxSpeed;
            ctx.fillStyle = colorStr;
            ctx.beginPath();
            ctx.moveTo(0, H);
            var step = 4;
            for (var x = -step; x <= W + step; x += step) {
                var worldX = x + offset;
                var profileY = mountainProfile(worldX, layer.seed, layer.roughness);
                var y = H * layer.baseY - profileY * H * layer.amplitude;
                ctx.lineTo(x, y);
            }
            ctx.lineTo(W, H);
            ctx.closePath();
            ctx.fill();
        }

        // ── Draw all mountain layers ──
        function drawMountains(ctx, energy) {
            for (var i = 0; i < mtnLayers.length; i++) {
                var layer = mtnLayers[i];
                var dark = layer.darkness;
                // In fire scene, warm up mountain colors
                var r, g, b;
                if (currentScene === 'fire') {
                    var warmth = signalFireIntensity * 0.3;
                    r = Math.round(10 + dark * 30 + warmth * 60);
                    g = Math.round(12 + dark * 16 + warmth * 20);
                    b = Math.round(20 + dark * 20);
                } else if (currentScene === 'clouds') {
                    r = Math.round(16 + dark * 24);
                    g = Math.round(20 + dark * 28);
                    b = Math.round(40 + dark * 30);
                } else {
                    r = Math.round(10 + dark * 18);
                    g = Math.round(14 + dark * 20);
                    b = Math.round(26 + dark * 28);
                }
                drawMountainLayer(ctx, layer, 'rgb(' + r + ',' + g + ',' + b + ')');
            }
        }

        // ── Draw trees ──
        function drawTrees(ctx, density) {
            if (density < 0.01) return;
            var visibleCount = Math.floor(TREE_COUNT * density);
            ctx.save();
            var groundY = H * groundFrac;
            for (var i = 0; i < visibleCount; i++) {
                var tree = trees[i];
                var screenX = (tree.baseX - scrollX * tree.parallaxSpeed) % (W * 1.5);
                if (screenX < -60) screenX += W * 1.5 + 120;
                if (screenX > W + 60) continue;

                var treeH = tree.height * (H / 800);
                var treeW = tree.width * (H / 800);
                var baseY = groundY - 10;

                // Trunk
                ctx.fillStyle = 'rgba(8,14,10,0.9)';
                ctx.fillRect(screenX - treeW * 0.15, baseY - treeH, treeW * 0.3, treeH);

                // Branches / canopy — triangular silhouette
                ctx.fillStyle = 'rgba(6,16,10,0.85)';
                ctx.beginPath();
                ctx.moveTo(screenX, baseY - treeH - treeH * 0.4);
                ctx.lineTo(screenX - treeW * 0.8, baseY - treeH * 0.3);
                ctx.lineTo(screenX + treeW * 0.8, baseY - treeH * 0.3);
                ctx.closePath();
                ctx.fill();

                // Second canopy tier
                ctx.beginPath();
                ctx.moveTo(screenX, baseY - treeH - treeH * 0.15);
                ctx.lineTo(screenX - treeW * 0.6, baseY - treeH * 0.55);
                ctx.lineTo(screenX + treeW * 0.6, baseY - treeH * 0.55);
                ctx.closePath();
                ctx.fill();
            }
            ctx.restore();
        }

        // ── Draw wolf eyes ──
        function drawWolfEyes(ctx, dt) {
            ctx.save();
            var groundY = H * groundFrac;
            for (var i = 0; i < wolfEyes.length; i++) {
                var w = wolfEyes[i];
                w.blinkTimer += dt;
                var blinking = (w.blinkTimer % w.blinkInterval) < w.blinkDuration;
                if (blinking) continue;

                var screenX = (w.baseX - scrollX * 0.7) % (W * 1.2);
                if (screenX < -20) screenX += W * 1.2 + 40;
                if (screenX > W + 20) continue;
                var eyeY = H * w.y;

                var flicker = 0.7 + 0.3 * Math.sin(elapsed * 5 + i * 2.3);
                var alpha = w.brightness * flicker;

                // Left eye
                ctx.globalAlpha = alpha;
                ctx.fillStyle = WOLF_EYE;
                ctx.shadowColor = WOLF_EYE;
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(screenX - w.separation * 0.5, eyeY, w.size, 0, Math.PI * 2);
                ctx.fill();

                // Right eye
                ctx.beginPath();
                ctx.arc(screenX + w.separation * 0.5, eyeY, w.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;
            ctx.restore();
        }

        // ── Draw snow ──
        function drawSnow(ctx, dt) {
            ctx.save();
            for (var i = 0; i < snowParticles.length; i++) {
                var p = snowParticles[i];
                p.y += p.speedY * dt;
                p.x += p.drift * dt;
                if (p.y > H + 5) { p.y = -5; p.x = Math.random() * W; }
                if (p.x < -5) p.x = W + 5;
                if (p.x > W + 5) p.x = -5;

                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = SNOW_WHITE;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        // ── Torch flame at runner's hand ──
        function updateTorchParticles(handX, handY, dt, energy) {
            // Spawn new particles
            var spawnCount = 2 + Math.floor(energy * 3);
            for (var s = 0; s < spawnCount; s++) {
                if (torchParticles.length < TORCH_PARTICLE_MAX) {
                    torchParticles.push({
                        x: handX + (Math.random() - 0.5) * 4,
                        y: handY,
                        vx: (Math.random() - 0.5) * 20,
                        vy: -40 - Math.random() * 60,
                        life: 0.3 + Math.random() * 0.4,
                        maxLife: 0.3 + Math.random() * 0.4,
                        size: 2 + Math.random() * 4
                    });
                }
            }

            // Update existing
            var i = torchParticles.length;
            while (i--) {
                var p = torchParticles[i];
                p.life -= dt;
                if (p.life <= 0) {
                    torchParticles.splice(i, 1);
                    continue;
                }
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.vy -= 30 * dt; // rise faster
                p.size *= 0.98;
            }
        }

        function drawTorchFlame(ctx, handX, handY, energy) {
            ctx.save();
            // Glow around torch
            var glowSize = 30 + energy * 20 + beatPulse * 15;
            var torchGrad = ctx.createRadialGradient(handX, handY - 8, 0, handX, handY - 8, glowSize);
            torchGrad.addColorStop(0, 'rgba(255,170,68,0.35)');
            torchGrad.addColorStop(0.4, 'rgba(255,136,48,0.15)');
            torchGrad.addColorStop(1, 'rgba(255,100,20,0)');
            ctx.fillStyle = torchGrad;
            ctx.fillRect(handX - glowSize, handY - 8 - glowSize, glowSize * 2, glowSize * 2);

            // Particles
            for (var i = 0; i < torchParticles.length; i++) {
                var p = torchParticles[i];
                var lifeFrac = p.life / p.maxLife;
                var alpha = lifeFrac;
                // Hot core → cooler outer
                if (lifeFrac > 0.6) {
                    ctx.fillStyle = 'rgba(255,224,128,' + alpha + ')';
                } else if (lifeFrac > 0.3) {
                    ctx.fillStyle = 'rgba(255,170,68,' + alpha + ')';
                } else {
                    ctx.fillStyle = 'rgba(255,100,20,' + (alpha * 0.7) + ')';
                }
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * lifeFrac, 0, Math.PI * 2);
                ctx.fill();
            }

            // Core flame shape
            ctx.fillStyle = 'rgba(255,224,128,0.6)';
            ctx.beginPath();
            ctx.ellipse(handX, handY - 10, 3 + energy * 2, 8 + energy * 4, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // ── Signal fire on peak ──
        function updateSignalFire(dt, energy) {
            signalFireIntensity = lerpExp(signalFireIntensity, signalFireTargetIntensity, 3, dt);

            if (signalFireIntensity < 0.01) return;

            // Spawn particles
            var spawnRate = Math.floor(signalFireIntensity * 8);
            for (var s = 0; s < spawnRate; s++) {
                if (signalFireParticles.length < SIGNAL_FIRE_MAX) {
                    var peakX = W * 0.65;
                    var peakY = H * 0.22;
                    signalFireParticles.push({
                        x: peakX + (Math.random() - 0.5) * 20 * signalFireIntensity,
                        y: peakY,
                        vx: (Math.random() - 0.5) * 60 * signalFireIntensity,
                        vy: -80 - Math.random() * 120 * signalFireIntensity,
                        life: 0.5 + Math.random() * 0.8,
                        maxLife: 0.5 + Math.random() * 0.8,
                        size: 3 + Math.random() * 8 * signalFireIntensity
                    });
                }
            }

            // Update
            var i = signalFireParticles.length;
            while (i--) {
                var p = signalFireParticles[i];
                p.life -= dt;
                if (p.life <= 0) {
                    signalFireParticles.splice(i, 1);
                    continue;
                }
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.vy -= 40 * dt;
                p.size *= 0.99;
            }
        }

        function drawSignalFire(ctx) {
            if (signalFireIntensity < 0.01) return;

            var peakX = W * 0.65;
            var peakY = H * 0.22;

            ctx.save();

            // Massive glow
            var glowR = 80 + signalFireIntensity * 150;
            var fireGrad = ctx.createRadialGradient(peakX, peakY - 20, 0, peakX, peakY - 20, glowR);
            fireGrad.addColorStop(0, 'rgba(255,204,0,' + (signalFireIntensity * 0.5) + ')');
            fireGrad.addColorStop(0.3, 'rgba(255,102,0,' + (signalFireIntensity * 0.3) + ')');
            fireGrad.addColorStop(0.7, 'rgba(255,60,0,' + (signalFireIntensity * 0.1) + ')');
            fireGrad.addColorStop(1, 'rgba(255,40,0,0)');
            ctx.fillStyle = fireGrad;
            ctx.fillRect(peakX - glowR, peakY - 20 - glowR, glowR * 2, glowR * 2);

            // Particles
            for (var i = 0; i < signalFireParticles.length; i++) {
                var p = signalFireParticles[i];
                var lifeFrac = p.life / p.maxLife;
                var alpha = lifeFrac * signalFireIntensity;
                if (lifeFrac > 0.5) {
                    ctx.fillStyle = 'rgba(255,240,180,' + alpha + ')';
                } else if (lifeFrac > 0.2) {
                    ctx.fillStyle = 'rgba(255,170,40,' + alpha + ')';
                } else {
                    ctx.fillStyle = 'rgba(255,80,10,' + (alpha * 0.6) + ')';
                }
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * lifeFrac, 0, Math.PI * 2);
                ctx.fill();
            }

            // Core blaze
            ctx.fillStyle = 'rgba(255,255,200,' + (signalFireIntensity * 0.7) + ')';
            ctx.beginPath();
            ctx.ellipse(peakX, peakY - 15, 8 * signalFireIntensity, 20 * signalFireIntensity, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // ── Draw chain of distant fires ──
        function drawChainFires(ctx, dt) {
            ctx.save();
            for (var i = 0; i < chainFires.length; i++) {
                var cf = chainFires[i];
                if (cf.lit) {
                    cf.litAlpha = Math.min(1, cf.litAlpha + dt * 2);
                }
                if (cf.litAlpha < 0.01) continue;

                var fx = cf.x * W;
                var fy = cf.y * H;
                var flicker = 0.7 + 0.3 * Math.sin(elapsed * 6 + cf.flickerPhase);
                var alpha = cf.litAlpha * flicker;

                // Glow
                var gSize = (10 + cf.size * 4) * cf.litAlpha;
                var gGrad = ctx.createRadialGradient(fx, fy, 0, fx, fy, gSize);
                gGrad.addColorStop(0, 'rgba(255,204,0,' + (alpha * 0.6) + ')');
                gGrad.addColorStop(0.5, 'rgba(255,102,0,' + (alpha * 0.3) + ')');
                gGrad.addColorStop(1, 'rgba(255,60,0,0)');
                ctx.fillStyle = gGrad;
                ctx.fillRect(fx - gSize, fy - gSize, gSize * 2, gSize * 2);

                // Core dot
                ctx.fillStyle = 'rgba(255,230,150,' + alpha + ')';
                ctx.beginPath();
                ctx.arc(fx, fy, cf.size * cf.litAlpha, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        // ── Draw ground path ──
        function drawGround(ctx) {
            var groundY = H * groundFrac;
            ctx.fillStyle = 'rgba(6,8,14,0.95)';
            ctx.fillRect(0, groundY, W, H - groundY);

            // Path surface
            ctx.strokeStyle = 'rgba(30,26,40,0.5)';
            ctx.lineWidth = 1;
            var pathY = groundY + 2;
            ctx.beginPath();
            ctx.moveTo(0, pathY);
            for (var x = 0; x < W; x += 8) {
                var wobble = Math.sin((x + scrollX * 0.5) * 0.02) * 1.5;
                ctx.lineTo(x, pathY + wobble);
            }
            ctx.stroke();
        }

        // ── Draw bridge gap ──
        function drawBridgeGap(ctx) {
            if (!bridgeGapActive) return;
            var groundY = H * groundFrac;
            var gapLeft = W * 0.4;
            var gapRight = W * 0.6;

            // Clear the gap (draw dark void)
            ctx.fillStyle = 'rgba(2,4,8,1)';
            ctx.fillRect(gapLeft, groundY, gapRight - gapLeft, H - groundY);

            // Bridge edges
            ctx.fillStyle = 'rgba(20,16,10,0.9)';
            ctx.fillRect(gapLeft - 10, groundY, 10, 6);
            ctx.fillRect(gapRight, groundY, 10, 6);

            // Depth lines in void
            ctx.strokeStyle = 'rgba(15,12,20,0.3)';
            ctx.lineWidth = 1;
            for (var i = 0; i < 5; i++) {
                var vy = groundY + 20 + i * 15;
                ctx.beginPath();
                ctx.moveTo(gapLeft + 5, vy);
                ctx.lineTo(gapRight - 5, vy);
                ctx.stroke();
            }
        }

        // ── Draw clouds ──
        function drawClouds(ctx) {
            if (currentScene !== 'clouds' && currentScene !== 'summit') return;
            ctx.save();
            var cloudY = H * 0.55;
            for (var i = 0; i < 6; i++) {
                var cx = (i * W * 0.4 - scrollX * 0.08 + W * 0.2) % (W * 2.4);
                if (cx < -200) cx += W * 2.4;
                var cy = cloudY + Math.sin(i * 1.7 + elapsed * 0.3) * 15;
                var cw = 80 + i * 20;

                ctx.globalAlpha = 0.15 + 0.05 * Math.sin(elapsed + i);
                ctx.fillStyle = CLOUD_COLOR;
                ctx.beginPath();
                ctx.ellipse(cx, cy, cw, 15 + i * 3, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(cx - cw * 0.3, cy - 6, cw * 0.6, 12, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(cx + cw * 0.25, cy - 4, cw * 0.5, 10, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        // ── Draw runner with torch ──
        function drawRunnerWithTorch(ctx, energy, dt) {
            if (!runnerFig) return;

            var groundY = H * groundFrac;
            var figH = H * 0.15;
            var runX = W * 0.30;
            var runY = groundY;

            // Bridge leap offset
            if (bridgeGapActive && bridgeLeapProgress > 0 && bridgeLeapProgress < 1) {
                var leapArc = Math.sin(bridgeLeapProgress * Math.PI);
                runY -= leapArc * figH * 1.5;
                runX = lerp(W * 0.30, W * 0.62, bridgeLeapProgress);
            }

            runnerFig.figH = figH;
            runnerFig.x = runX;
            runnerFig.y = runY;

            // Animate running via custom targets
            var legSwing = Math.sin(runnerPhase) * 0.6 * (1 + energy * 0.3);
            var armSwing = Math.sin(runnerPhase + Math.PI) * 0.4 * (1 + energy * 0.2);

            StickFight.setTarget(runnerFig, 'bounce', Math.abs(Math.sin(runnerPhase * 2)) * 0.12);
            StickFight.setTarget(runnerFig, 'lean', 0.2 + energy * 0.15);
            StickFight.setTarget(runnerFig, 'kneeL', -legSwing * 0.7);
            StickFight.setTarget(runnerFig, 'kneeR', legSwing * 0.7);
            StickFight.setTarget(runnerFig, 'legSpread', 0.15 + Math.abs(legSwing) * 0.2);

            // Right arm holds torch (raised)
            StickFight.setTarget(runnerFig, 'armRAngle', -0.8 - energy * 0.2);
            StickFight.setTarget(runnerFig, 'elbowRBend', 0.6);
            // Left arm pumps
            StickFight.setTarget(runnerFig, 'armLAngle', armSwing);
            StickFight.setTarget(runnerFig, 'elbowLBend', 0.5 + Math.abs(armSwing) * 0.3);

            // During intro, more idle
            if (currentScene === 'intro') {
                StickFight.setTarget(runnerFig, 'lean', 0.05);
                StickFight.setTarget(runnerFig, 'legSpread', 0.08);
                StickFight.setTarget(runnerFig, 'kneeL', 0);
                StickFight.setTarget(runnerFig, 'kneeR', 0);
            }

            // During fire/chain/outro, triumphant stance
            if (currentScene === 'fire' || currentScene === 'chain') {
                StickFight.setTarget(runnerFig, 'armRAngle', -1.2);
                StickFight.setTarget(runnerFig, 'elbowRBend', 0.3);
                StickFight.setTarget(runnerFig, 'lean', 0.05);
                StickFight.setTarget(runnerFig, 'legSpread', 0.2);
                StickFight.setTarget(runnerFig, 'kneeL', 0);
                StickFight.setTarget(runnerFig, 'kneeR', 0);
            }

            // Outro — salute then fade
            if (currentScene === 'outro') {
                StickFight.setPose(runnerFig, 'salute');
                StickFight.setTarget(runnerFig, 'armRAngle', -1.0);
            }

            StickFight.updateFigure(runnerFig, dt);

            // Get joints for torch position
            var joints = StickFight.computeJoints(runnerFig);
            var handRWorld = { x: runX + joints.handR.x, y: runY + joints.handR.y };

            // Torch stick
            ctx.save();
            ctx.strokeStyle = '#5a3a1a';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.moveTo(handRWorld.x, handRWorld.y);
            ctx.lineTo(handRWorld.x + 2, handRWorld.y - figH * 0.12);
            ctx.stroke();
            ctx.restore();

            // Torch flame particles
            var torchTipX = handRWorld.x + 2;
            var torchTipY = handRWorld.y - figH * 0.12;
            updateTorchParticles(torchTipX, torchTipY, dt, energy);
            drawTorchFlame(ctx, torchTipX, torchTipY, energy);

            // Draw the stick figure
            StickFight.drawFigure(ctx, runnerFig, joints);
        }

        // ── Draw vignette ──
        function drawVignette(ctx, strength) {
            var vigGrad = ctx.createRadialGradient(W / 2, H / 2, W * 0.25, W / 2, H / 2, W * 0.75);
            vigGrad.addColorStop(0, 'rgba(0,0,0,0)');
            vigGrad.addColorStop(1, 'rgba(0,0,0,' + strength + ')');
            ctx.fillStyle = vigGrad;
            ctx.fillRect(0, 0, W, H);
        }

        // ── Init ──
        function init(ctx, width, height, anal) {
            W = width; H = height;
            analysis = anal;
            beatPulse = 0;
            flashAlpha = 0;
            scrollX = 0;
            elapsed = 0;
            lastSeqIndex = -1;
            currentScene = 'intro';
            introFade = 1;
            outroFade = 0;
            sceneFlash = 0;
            signalFireIntensity = 0;
            signalFireTargetIntensity = 0;
            signalFireParticles = [];
            torchParticles = [];
            bridgeGapActive = false;
            bridgeLeapProgress = 0;
            chainFiresLit = 0;

            skyTopR = 8; skyTopG = 10; skyTopB = 22;
            skyBotR = 12; skyBotG = 16; skyBotB = 30;

            // Create runner
            var figH = H * 0.15;
            var groundY = H * groundFrac;
            runnerFig = StickFight.create({
                x: W * 0.30,
                y: groundY,
                figH: figH,
                facing: 1,
                color: '#8898c8',
                lineWidth: 2.5,
                poseSpeed: 12
            });
            runnerPhase = 0;
            poseToggle = 0;

            generateMountains();
            generateTrees();
            generateWolfEyes();
            generateStars();
            generateSnow();
            generateChainFires();
        }

        // ── Resize ──
        function resize(width, height) {
            W = width; H = height;
            generateStars();
            generateSnow();
        }

        // ── Main render ──
        function render(frameData) {
            var ctx = frameData.ctx;
            var dt = frameData.dt || 1 / 60;
            var cursor = frameData.cursor;
            beatPulse = frameData.beatPulse;
            elapsed += dt;

            // ── Idle state ──
            if (!cursor) {
                drawSky(ctx);
                drawStars(ctx, 0.6);
                drawMountains(ctx, 0);
                drawGround(ctx);
                drawVignette(ctx, 0.5);

                // Dim idle runner with torch glow
                if (runnerFig) {
                    ctx.save();
                    ctx.globalAlpha = 0.5;
                    StickFight.setPose(runnerFig, 'idle');
                    StickFight.setTarget(runnerFig, 'armRAngle', -0.8);
                    StickFight.setTarget(runnerFig, 'elbowRBend', 0.6);
                    StickFight.updateFigure(runnerFig, dt);
                    var idleJoints = StickFight.computeJoints(runnerFig);
                    var idleHandX = runnerFig.x + idleJoints.handR.x + 2;
                    var idleHandY = runnerFig.y + idleJoints.handR.y - runnerFig.figH * 0.12;
                    // Torch glow
                    ctx.globalAlpha = 0.4;
                    var idleGlow = ctx.createRadialGradient(idleHandX, idleHandY, 0, idleHandX, idleHandY, 40);
                    idleGlow.addColorStop(0, 'rgba(255,170,68,0.35)');
                    idleGlow.addColorStop(0.5, 'rgba(255,136,48,0.12)');
                    idleGlow.addColorStop(1, 'rgba(255,100,20,0)');
                    ctx.fillStyle = idleGlow;
                    ctx.fillRect(idleHandX - 40, idleHandY - 40, 80, 80);
                    // Core flame
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = 'rgba(255,224,128,0.6)';
                    ctx.beginPath();
                    ctx.ellipse(idleHandX, idleHandY - 4, 3, 7, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Draw figure
                    ctx.globalAlpha = 0.5;
                    StickFight.drawFigure(ctx, runnerFig, idleJoints);
                    ctx.restore();
                }
                return;
            }

            var seqIdx = cursor.seqIndex;
            var energy = analysis ? (analysis.energy[cursor.timelineIndex] || 0) : 0;
            var beat = cursor.beat;

            // ── Scene transitions ──
            var newScene = mapScene(seqIdx);
            if (seqIdx !== lastSeqIndex) {
                var oldScene = currentScene;
                currentScene = newScene;

                if (newScene !== oldScene) {
                    sceneFlash = 0.4;

                    // Special transitions
                    if (newScene === 'bridge') {
                        bridgeGapActive = true;
                        bridgeLeapProgress = 0;
                    }
                    if (oldScene === 'bridge') {
                        bridgeGapActive = false;
                    }
                    if (newScene === 'fire') {
                        signalFireTargetIntensity = 1;
                        sceneFlash = 0.7; // Big flash for fire ignition
                    }
                    if (newScene === 'outro') {
                        outroFade = 0;
                    }
                }

                // Update sky color targets
                var skyC = sceneSkyColors(newScene);
                targetSkyTopR = skyC.tr; targetSkyTopG = skyC.tg; targetSkyTopB = skyC.tb;
                targetSkyBotR = skyC.br; targetSkyBotG = skyC.bg; targetSkyBotB = skyC.bb;

                lastSeqIndex = seqIdx;
            }

            // ── Beat events ──
            if (frameData.beatChanged) {
                poseToggle = 1 - poseToggle;

                // Light chain fires one by one
                if (currentScene === 'chain' && chainFiresLit < chainFires.length) {
                    chainFires[chainFiresLit].lit = true;
                    chainFiresLit++;
                    if (chainFiresLit <= 2) sceneFlash = 0.15;
                }

                // Bridge leap on first beat of bridge scene
                if (currentScene === 'bridge' && bridgeLeapProgress <= 0) {
                    bridgeLeapProgress = 0.01;
                }

                // Intensify fire on beats
                if (currentScene === 'fire') {
                    flashAlpha = Math.max(flashAlpha, 0.05 + energy * 0.1);
                }
            }

            // ── Decay ──
            flashAlpha *= Math.exp(-5 * dt);
            sceneFlash *= Math.exp(-4 * dt);
            introFade *= Math.exp(-1.5 * dt);
            if (currentScene === 'outro') {
                outroFade = Math.min(1, outroFade + dt * 0.4);
            }

            // ── Smooth sky color ──
            skyTopR = lerpExp(skyTopR, targetSkyTopR, 2, dt);
            skyTopG = lerpExp(skyTopG, targetSkyTopG, 2, dt);
            skyTopB = lerpExp(skyTopB, targetSkyTopB, 2, dt);
            skyBotR = lerpExp(skyBotR, targetSkyBotR, 2, dt);
            skyBotG = lerpExp(skyBotG, targetSkyBotG, 2, dt);
            skyBotB = lerpExp(skyBotB, targetSkyBotB, 2, dt);

            // ── Scroll ──
            var baseSpeed = 60 + energy * 140;
            if (currentScene === 'chase') baseSpeed *= 1.4;
            if (currentScene === 'forest' || currentScene === 'wolves') baseSpeed *= 1.0;
            if (currentScene === 'clouds') baseSpeed *= 0.5;
            if (currentScene === 'summit') baseSpeed *= 0.8;
            if (currentScene === 'fire' || currentScene === 'chain') baseSpeed *= 0.2;
            if (currentScene === 'outro') baseSpeed *= 0.1;
            if (currentScene === 'intro') baseSpeed *= 0.3;
            scrollX += baseSpeed * dt;

            // Runner animation speed
            var runSpeed = 4 + energy * 6;
            if (currentScene === 'intro') runSpeed = 0.5;
            if (currentScene === 'fire' || currentScene === 'chain' || currentScene === 'outro') runSpeed = 0.3;
            runnerPhase += dt * runSpeed;

            // Bridge leap progress
            if (bridgeGapActive && bridgeLeapProgress > 0 && bridgeLeapProgress < 1) {
                bridgeLeapProgress += dt * 0.8;
                if (bridgeLeapProgress >= 1) bridgeLeapProgress = 1;
            }

            // Signal fire
            updateSignalFire(dt, energy);

            // ══════════════════════════════════════════════
            //  DRAW
            // ══════════════════════════════════════════════

            // Sky
            drawSky(ctx);

            // Stars
            var starAlpha = sceneShowStars(currentScene) ? 0.8 : 0;
            if (currentScene === 'fire') starAlpha = 0.2;
            drawStars(ctx, starAlpha);

            // Clouds (above the clouds scene)
            drawClouds(ctx);

            // Mountains
            drawMountains(ctx, energy);

            // Signal fire (behind foreground but on mountain peak)
            drawSignalFire(ctx);

            // Chain of distant fires
            if (currentScene === 'chain' || currentScene === 'outro') {
                drawChainFires(ctx, dt);
            }

            // Trees
            var treeDensity = sceneTreeDensity(currentScene);
            drawTrees(ctx, treeDensity);

            // Wolf eyes (between trees)
            if (currentScene === 'wolves' || currentScene === 'chase') {
                var wolfAlpha = currentScene === 'wolves' ? 1.0 : 0.5;
                ctx.save();
                ctx.globalAlpha = wolfAlpha;
                drawWolfEyes(ctx, dt);
                ctx.restore();
            }

            // Ground
            drawGround(ctx);

            // Bridge gap
            drawBridgeGap(ctx);

            // Snow
            if (sceneShowSnow(currentScene)) {
                drawSnow(ctx, dt);
            }

            // Runner with torch
            drawRunnerWithTorch(ctx, energy, dt);

            // ── Torch light on ground ──
            if (runnerFig) {
                var torchGlowX = runnerFig.x;
                var torchGlowY = H * groundFrac;
                var torchGlowR = 60 + energy * 40 + beatPulse * 20;
                var groundGlow = ctx.createRadialGradient(torchGlowX, torchGlowY, 0, torchGlowX, torchGlowY, torchGlowR);
                groundGlow.addColorStop(0, 'rgba(255,170,68,0.12)');
                groundGlow.addColorStop(1, 'rgba(255,100,20,0)');
                ctx.fillStyle = groundGlow;
                ctx.fillRect(torchGlowX - torchGlowR, torchGlowY - torchGlowR * 0.3, torchGlowR * 2, torchGlowR);
            }

            // ── Fire scene: screen warmth ──
            if (currentScene === 'fire' && signalFireIntensity > 0.1) {
                ctx.save();
                ctx.globalAlpha = signalFireIntensity * 0.08;
                ctx.fillStyle = '#ff6600';
                ctx.fillRect(0, 0, W, H);
                ctx.restore();
            }

            // ── Beat pulse vignette ──
            if (beatPulse > 0.05) {
                var pulseColor = (currentScene === 'fire' || currentScene === 'chain') ? 'rgba(255,140,20,' : 'rgba(100,130,200,';
                var vigGrad = ctx.createRadialGradient(W / 2, H / 2, W * 0.3, W / 2, H / 2, W * 0.7);
                vigGrad.addColorStop(0, pulseColor + '0)');
                vigGrad.addColorStop(1, pulseColor + (beatPulse * 0.08) + ')');
                ctx.fillStyle = vigGrad;
                ctx.fillRect(0, 0, W, H);
            }

            // ── Darkness vignette (always) ──
            var vigStrength = 0.4;
            if (currentScene === 'forest' || currentScene === 'wolves') vigStrength = 0.6;
            if (currentScene === 'fire') vigStrength = 0.2;
            drawVignette(ctx, vigStrength);

            // ── Scene transition flash ──
            if (sceneFlash > 0.01) {
                ctx.save();
                ctx.globalAlpha = sceneFlash;
                var flashColor = (currentScene === 'fire') ? '#ffcc00' : '#ffffff';
                ctx.fillStyle = flashColor;
                ctx.fillRect(0, 0, W, H);
                ctx.restore();
            }

            // ── Flash overlay ──
            if (flashAlpha > 0.01) {
                ctx.save();
                ctx.globalAlpha = flashAlpha;
                ctx.fillStyle = TORCH_HOT;
                ctx.fillRect(0, 0, W, H);
                ctx.restore();
            }

            // ── Intro fade from black ──
            if (introFade > 0.01) {
                ctx.save();
                ctx.globalAlpha = introFade;
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, W, H);
                ctx.restore();
            }

            // ── Outro fade to black ──
            if (outroFade > 0.01) {
                ctx.save();
                ctx.globalAlpha = outroFade;
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, W, H);
                ctx.restore();
            }
        }

        BaseRenderer('signal-fire-video', 'Signal Fire on the Iron Mountain', {
            beatDecay: 8,
            init: init,
            render: render,
            resize: resize
        });
    })();

    // ── Page bootstrap ──
    (function() {
        var canvas = document.getElementById('viz-canvas');
        var overlay = document.getElementById('play-overlay');

        Visualizer.init(canvas);
        Visualizer.setRenderer('signal-fire-video');

        function loadAndPlay(json) {
            Visualizer.loadSong(json);
            Visualizer.play();
        }

        function fetchSong() {
            var url = '../audio-tracker/songs/signal-fire-on-the-iron-mountain.json';
            if (window.fetch && location.protocol !== 'file:') {
                return fetch(url).then(function(r) { return r.json(); });
            }
            return new Promise(function(resolve, reject) {
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.onload = function() {
                    if (xhr.status === 200 || xhr.status === 0) {
                        resolve(JSON.parse(xhr.responseText));
                    } else {
                        reject(new Error('XHR failed: ' + xhr.status));
                    }
                };
                xhr.onerror = function() { reject(new Error('XHR error')); };
                xhr.send();
            });
        }

        overlay.addEventListener('click', function() {
            overlay.classList.add('hidden');
            fetchSong().then(loadAndPlay).catch(function(err) {
                console.error('Failed to load song:', err);
                overlay.classList.remove('hidden');
            });
        });

        if (new URLSearchParams(window.location.search).get('autoplay') === '1') {
            overlay.click();
        }

        canvas.addEventListener('click', function() {
            if (overlay.classList.contains('hidden')) {
                if (Visualizer.isPlaying()) {
                    Visualizer.stop();
                } else {
                    Visualizer.play();
                }
            }
        });
    })();
    </script>
</body>
</html>
