<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Through the Fire and Flames — Music Video</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700;900&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="video-base-styles.css">
    <style>
        :root {
            --vid-bg: #0a0408;
            --vid-bg-rgb: 10,4,8;
            --vid-font: 'JetBrains Mono', monospace;
            --vid-accent: #ff4400;
            --vid-accent-r: 255;
            --vid-accent-g: 68;
            --vid-accent-b: 0;
            --vid-title-min: 18px;
            --vid-title-vw: 4.5vw;
            --vid-title-max: 44px;
            --vid-title-weight: 900;
            --vid-title-spacing: 0.06em;
            --vid-sub-min: 11px;
            --vid-sub-vw: 1.8vw;
            --vid-sub-max: 16px;
        }
        .play-title {
            text-shadow:
                0 0 30px rgba(var(--vid-accent-r), var(--vid-accent-g), var(--vid-accent-b), 0.6),
                0 0 60px rgba(var(--vid-accent-r), var(--vid-accent-g), var(--vid-accent-b), 0.3),
                0 2px 4px rgba(0,0,0,0.8);
        }
        .play-sub { letter-spacing: 0.1em; }
    </style>
</head>
<body>
    <a href="music-videos/index.html" class="back-link">← Music Videos</a>
    <canvas id="viz-canvas"></canvas>
    <div class="play-overlay" id="play-overlay">
        <div class="play-title">Through the Fire and Flames</div>
        <div class="play-sub">5-minute power metal epic</div>
        <div class="play-btn"></div>
    </div>

    <script src="../audio-tracker/playback-engine.js"></script>
    <script src="engine.js"></script>
    <script src="stick-fight-engine.js"></script>
    <script src="video-utils.js"></script>
    <script src="base-renderer.js"></script>
    <script>
    // ── Through the Fire and Flames Video Renderer ─────────────────────
    (function() {
        "use strict";

        var W = 0, H = 0;
        var analysis = null;

        // ── Palette ──
        var COL = {
            bg:         '#0a0408',
            fire1:      '#ff4400',
            fire2:      '#ff8800',
            fire3:      '#ffcc00',
            fire4:      '#fff4cc',
            ember:      '#ff6622',
            dragon:     '#22cc44',
            dragonDark: '#0a5518',
            steel:      '#8899aa',
            steelBright:'#ccdde8',
            sky:        '#060818',
            star:       '#ffffff',
            campfire:   '#ff9944',
            campEmber:  '#cc5500'
        };

        // ── State ──
        var beatPulse = 0;
        var flashAlpha = 0;
        var sectionMood = 'keyboard-intro';
        var lastSeqIndex = -1;
        var globalTime = 0;

        // ── Particle pools ──
        var flames = [];
        var embers = [];
        var dragonFireParticles = [];
        var fretNotes = [];
        var stars = [];
        var chargeParticles = [];

        // ── Scene objects ──
        var warrior1 = null;
        var warrior2 = null;
        var warriors = [];
        var slashTimers = [0, 0]; // per-warrior slash trail timer
        var dragon = { x: 0, y: 0, wingAngle: 0, breathTimer: 0, breathActive: false, headAngle: 0 };
        var campfire = { flicker: 0, windDir: 0 };

        // ── Duel choreography state machine ──
        var duel = {
            phase: 'idle',           // idle, circling, approaching, attacking, separating, clash, finished
            turnToAttack: 0,         // 0 = warrior1 attacks, 1 = warrior2 attacks
            exchangeTimer: 0,        // time in current exchange
            separationTimer: 0,      // cooldown between exchanges
            approachTimer: 0,        // time spent approaching
            clashTimer: 0,           // power clash duration
            warrior1HP: 200,
            warrior2HP: 200,
            finaleKillDone: false,
            finaleBeats: 0,          // beat counter in finale
            circleDir: 1,            // circling direction
            circleTimer: 0,
            lastAttackBeat: -1,      // last beat an attack was triggered
            attackCooldown: 0,       // prevents double-attacks
            centerX: 0,             // center point between warriors
            desiredGap: 0,          // target distance between warriors
            actualGap: 0,           // current distance
            lastSection: '',        // track section changes for HP reset
            slowMoTimer: 0,         // slow motion countdown
            slowMoActive: false,
            victoryTimer: 0         // post-kill victory pose timer
        };

        // ── Section mapping (130 patterns at 200 BPM) ──
        // Rough breakdown for a DragonForce-style song:
        // 0-7: keyboard intro
        // 8-15: verse 1 (twin guitar riff)
        // 16-23: pre-chorus / ascending riff
        // 24-35: chorus 1 (blazing)
        // 36-43: verse 2
        // 44-51: pre-chorus 2
        // 52-63: chorus 2
        // 64-75: guitar solo
        // 76-83: acoustic breakdown
        // 84-91: build back up
        // 92-107: final chorus / blazing finale
        // 108-119: extended solo / shred
        // 120-129: outro / final charge
        function mapSection(seqIndex) {
            if (seqIndex <= 7) return 'keyboard-intro';
            if (seqIndex <= 15) return 'twin-guitar';
            if (seqIndex <= 23) return 'pre-chorus';
            if (seqIndex <= 35) return 'chorus';
            if (seqIndex <= 43) return 'twin-guitar';
            if (seqIndex <= 51) return 'pre-chorus';
            if (seqIndex <= 63) return 'chorus';
            if (seqIndex <= 75) return 'guitar-solo';
            if (seqIndex <= 83) return 'acoustic';
            if (seqIndex <= 91) return 'build';
            if (seqIndex <= 107) return 'chorus';
            if (seqIndex <= 119) return 'guitar-solo';
            return 'finale';
        }

        // ── Helpers ──

        // ── Init particle pools ──
        function initFlames(count) {
            flames = [];
            for (var i = 0; i < count; i++) {
                flames.push({
                    x: rand(0, W), y: H + rand(0, 50),
                    vx: rand(-30, 30), vy: rand(-120, -250),
                    life: 0, maxLife: rand(0.6, 1.8),
                    size: rand(3, 12), phase: rand(0, Math.PI * 2)
                });
            }
        }

        function initEmbers(count) {
            embers = [];
            for (var i = 0; i < count; i++) {
                embers.push({
                    x: rand(0, W), y: rand(0, H),
                    vx: rand(-20, 60), vy: rand(-80, -200),
                    life: rand(0, 2), maxLife: rand(1.5, 3.5),
                    size: rand(1, 3.5), brightness: rand(0.3, 1)
                });
            }
        }

        function initStars(count) {
            stars = [];
            for (var i = 0; i < count; i++) {
                stars.push({
                    x: rand(0, 1), y: rand(0, 0.5),
                    size: rand(0.5, 2.5),
                    twinkle: rand(0, Math.PI * 2),
                    twinkleSpeed: rand(1, 4)
                });
            }
        }

        function initFretNotes() {
            fretNotes = [];
            for (var i = 0; i < 60; i++) {
                fretNotes.push({
                    lane: Math.floor(rand(0, 5)),
                    z: rand(0, 1),
                    speed: rand(0.4, 1.2),
                    color: Math.floor(rand(0, 4)),
                    active: false
                });
            }
        }

        // ── Update functions ──
        function updateFlames(dt, energy, intensity) {
            var spawnRate = intensity * 8;
            for (var i = 0; i < flames.length; i++) {
                var f = flames[i];
                f.life += dt;
                if (f.life >= f.maxLife) {
                    // Respawn
                    f.x = rand(0, W);
                    f.y = H + rand(0, 20);
                    f.vx = rand(-40, 40) * (1 + energy);
                    f.vy = rand(-150, -350) * (0.5 + energy * 1.5);
                    f.life = 0;
                    f.maxLife = rand(0.4, 1.5);
                    f.size = rand(3, 14) * (0.7 + energy * 0.6);
                }
                f.x += f.vx * dt;
                f.y += f.vy * dt;
                f.vx += Math.sin(f.phase + globalTime * 3) * 40 * dt;
            }
        }

        function updateEmbers(dt, energy) {
            for (var i = 0; i < embers.length; i++) {
                var e = embers[i];
                e.life += dt;
                if (e.life >= e.maxLife) {
                    e.x = rand(0, W);
                    e.y = H + rand(0, 20);
                    e.vx = rand(-30, 70);
                    e.vy = rand(-100, -250) * (0.5 + energy);
                    e.life = 0;
                    e.maxLife = rand(1, 3);
                    e.brightness = rand(0.3, 1);
                }
                e.x += e.vx * dt;
                e.y += e.vy * dt;
                e.vx += Math.sin(globalTime * 2 + i) * 15 * dt;
            }
        }

        function updateDragonFire(dt) {
            for (var i = dragonFireParticles.length - 1; i >= 0; i--) {
                var p = dragonFireParticles[i];
                p.life += dt;
                if (p.life >= p.maxLife) {
                    dragonFireParticles.splice(i, 1);
                    continue;
                }
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.vy += 30 * dt; // slight gravity
                p.size *= (1 + 1.5 * dt); // expand
            }
        }

        function spawnDragonFire(originX, originY, dirX, dirY, count) {
            for (var i = 0; i < count; i++) {
                var spread = rand(-0.3, 0.3);
                var speed = rand(200, 600);
                dragonFireParticles.push({
                    x: originX + rand(-10, 10),
                    y: originY + rand(-10, 10),
                    vx: (dirX + spread) * speed,
                    vy: (dirY + spread * 0.5) * speed,
                    life: 0, maxLife: rand(0.3, 0.8),
                    size: rand(4, 16),
                    hue: rand(0, 60) // fire hue
                });
            }
        }

        // ── Draw functions ──

        function drawSkyGradient(ctx, mood, energy) {
            var grad;
            if (mood === 'acoustic') {
                grad = ctx.createLinearGradient(0, 0, 0, H);
                grad.addColorStop(0, '#0a0c24');
                grad.addColorStop(0.4, '#141832');
                grad.addColorStop(1, '#0a0818');
            } else if (mood === 'keyboard-intro') {
                var fade = clamp01(globalTime * 0.15);
                grad = ctx.createLinearGradient(0, 0, 0, H);
                grad.addColorStop(0, '#000000');
                grad.addColorStop(0.5, rgba('#1a0800', fade));
                grad.addColorStop(1, rgba('#2a0400', fade * 0.5));
            } else {
                var fireIntensity = clamp01(energy * 1.5);
                grad = ctx.createLinearGradient(0, 0, 0, H);
                grad.addColorStop(0, COL.sky);
                grad.addColorStop(0.3, rgba('#1a0600', 0.3 + fireIntensity * 0.4));
                grad.addColorStop(0.7, rgba('#2a0800', 0.2 + fireIntensity * 0.5));
                grad.addColorStop(1, rgba('#3a0a00', 0.3 + fireIntensity * 0.4));
            }
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, W, H);
        }

        function drawStars(ctx, alpha) {
            ctx.save();
            for (var i = 0; i < stars.length; i++) {
                var s = stars[i];
                var twinkle = 0.4 + 0.6 * Math.sin(s.twinkle + globalTime * s.twinkleSpeed);
                ctx.globalAlpha = alpha * twinkle;
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(s.x * W, s.y * H, s.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        function drawMountains(ctx, energy) {
            ctx.save();
            var baseY = H * 0.7;
            // Back range
            ctx.fillStyle = rgba('#0a0412', 0.9);
            ctx.beginPath();
            ctx.moveTo(0, baseY);
            for (var x = 0; x <= W; x += 20) {
                var h = Math.sin(x * 0.003) * H * 0.12 + Math.sin(x * 0.008 + 1) * H * 0.06;
                ctx.lineTo(x, baseY - h - H * 0.05);
            }
            ctx.lineTo(W, H);
            ctx.lineTo(0, H);
            ctx.fill();
            // Front range
            ctx.fillStyle = rgba('#060210', 0.95);
            ctx.beginPath();
            ctx.moveTo(0, baseY + H * 0.05);
            for (var x2 = 0; x2 <= W; x2 += 15) {
                var h2 = Math.sin(x2 * 0.005 + 2) * H * 0.08 + Math.sin(x2 * 0.012) * H * 0.04;
                ctx.lineTo(x2, baseY + H * 0.05 - h2);
            }
            ctx.lineTo(W, H);
            ctx.lineTo(0, H);
            ctx.fill();
            // Fire glow on mountains during intense sections
            if (energy > 0.4) {
                var glowGrad = ctx.createLinearGradient(0, baseY - H * 0.2, 0, baseY + H * 0.1);
                glowGrad.addColorStop(0, 'rgba(255,68,0,0)');
                glowGrad.addColorStop(1, rgba('#ff4400', energy * 0.15));
                ctx.fillStyle = glowGrad;
                ctx.fillRect(0, baseY - H * 0.2, W, H * 0.3);
            }
            ctx.restore();
        }

        function drawGround(ctx, energy) {
            var groundY = H * 0.78;
            ctx.save();
            ctx.fillStyle = '#060210';
            ctx.fillRect(0, groundY, W, H - groundY);
            // Fire reflection
            if (energy > 0.2) {
                var grad = ctx.createLinearGradient(0, groundY, 0, groundY + H * 0.12);
                grad.addColorStop(0, rgba('#ff4400', energy * 0.12));
                grad.addColorStop(1, 'rgba(255,68,0,0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, groundY, W, H * 0.12);
            }
            ctx.restore();
        }

        function drawFlames(ctx, energy, intensity) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            for (var i = 0; i < flames.length; i++) {
                var f = flames[i];
                var t = f.life / f.maxLife;
                if (t >= 1) continue;
                var alpha = (1 - t) * intensity * (0.5 + energy * 0.5);
                var size = f.size * (1 + t * 0.8);

                // Color shifts from white-yellow at base to red at top
                var r, g, b;
                if (t < 0.2) {
                    r = 255; g = lerp(255, 200, t * 5); b = lerp(200, 0, t * 5);
                } else if (t < 0.5) {
                    r = 255; g = lerp(200, 100, (t - 0.2) / 0.3); b = 0;
                } else {
                    r = lerp(255, 180, (t - 0.5) * 2); g = lerp(100, 0, (t - 0.5) * 2); b = 0;
                }

                ctx.globalAlpha = alpha;
                ctx.fillStyle = 'rgb(' + Math.floor(r) + ',' + Math.floor(g) + ',' + Math.floor(b) + ')';
                ctx.beginPath();
                ctx.arc(f.x, f.y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        function drawEmbers(ctx, energy) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            for (var i = 0; i < embers.length; i++) {
                var e = embers[i];
                var t = e.life / e.maxLife;
                if (t >= 1) continue;
                var alpha = (1 - t) * e.brightness * (0.3 + energy * 0.5);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = t < 0.5 ? COL.fire3 : COL.ember;
                ctx.fillRect(e.x, e.y, e.size, e.size);
            }
            ctx.restore();
        }

        // ── Warrior drawing (uses StickFight engine) ──
        function drawWarriorExtras(ctx, fig, slashIdx, energy) {
            // Skip extras for ragdolled figures
            if (fig.mode === 'ragdoll') return;
            var joints = StickFight.computeJoints(fig);

            ctx.save();
            ctx.translate(fig.x, fig.y);

            // Helmet crest on head
            var headR = joints.headR;
            ctx.strokeStyle = fig.color;
            ctx.lineWidth = 3;
            ctx.shadowBlur = 8;
            ctx.shadowColor = COL.steelBright;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(joints.head.x, joints.head.y - headR);
            ctx.lineTo(joints.head.x + fig.facing * headR * 0.5, joints.head.y - headR - headR * 0.6);
            ctx.lineTo(joints.head.x - fig.facing * headR * 0.3, joints.head.y - headR + headR * 0.3);
            ctx.stroke();

            // Slash trail effect
            var slashTimer = slashTimers[slashIdx];
            if (slashTimer > 0) {
                var hand = joints.handL;
                var sLen = fig.params.swordLen * fig.figH;
                var sAng = fig.params.swordAngle;
                ctx.globalCompositeOperation = 'lighter';
                ctx.strokeStyle = rgba('#ff8800', slashTimer);
                ctx.lineWidth = 4 + slashTimer * 8;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ff4400';
                ctx.beginPath();
                ctx.arc(hand.x, hand.y, sLen * 0.8,
                    sAng - 1.2 * fig.facing, sAng + 0.5 * fig.facing);
                ctx.stroke();
                ctx.globalCompositeOperation = 'source-over';
            }

            ctx.restore();
        }

        // ── Duel helper: get attacker/defender by turn ──
        function getDuelFighters() {
            if (duel.turnToAttack === 0) {
                return { attacker: warrior1, defender: warrior2, atkIdx: 0, defIdx: 1 };
            }
            return { attacker: warrior2, defender: warrior1, atkIdx: 1, defIdx: 0 };
        }

        // ── Duel helper: move warrior toward a target X ──
        function moveWarriorX(fig, targetX, speed, dt) {
            var dx = targetX - fig.x;
            var dist = Math.abs(dx);
            if (dist < 2) return;
            var step = Math.min(dist, speed * dt);
            fig.x += (dx > 0 ? step : -step);
        }

        // ── Duel helper: ensure warriors face each other ──
        function faceEachOther() {
            if (warrior1.mode === 'ragdoll' || warrior2.mode === 'ragdoll') return;
            warrior1.facing = warrior1.x < warrior2.x ? 1 : -1;
            warrior2.facing = warrior2.x < warrior1.x ? 1 : -1;
        }

        // ── Duel helper: current gap between warriors ──
        function getGap() {
            return Math.abs(warrior2.x - warrior1.x);
        }

        // ── Duel helper: trigger an attack on beat ──
        function triggerDuelAttack(energy) {
            if (duel.finaleKillDone) return;
            var f = getDuelFighters();
            var attacker = f.attacker;
            var defender = f.defender;

            if (attacker.mode === 'ragdoll' || defender.mode === 'ragdoll') return;
            if (attacker.attacking) return;

            // Pick attack move
            var moves = ['slash', 'lunge', 'slash'];
            if (energy > 0.7) moves.push('lunge', 'slash');
            var moveName = moves[Math.floor(Math.random() * moves.length)];

            // Execute attack
            StickFight.attack(attacker, moveName, defender);
            slashTimers[f.atkIdx] = 0.8 + energy * 0.4;

            // Defender reaction: block or take hit
            var blockChance = 0.55;
            if (sectionMood === 'chorus' || sectionMood === 'finale') blockChance = 0.4;
            if (sectionMood === 'twin-guitar') blockChance = 0.7;

            if (Math.random() < blockChance) {
                // Block
                StickFight.setPose(defender, 'block');
                StickFight.setTarget(defender, 'swordAngle', -1.5);
            } else {
                // Hit lands — recoil + blood
                StickFight.setPose(defender, 'recoil');
                var hitX = defender.x;
                var hitY = defender.y - defender.figH * 0.4;
                var impulseDir = attacker.facing;
                StickFight.spawnBlood(hitX, hitY, 4 + Math.floor(energy * 6),
                    impulseDir * 120, -80);

                // Screen shake on hit
                shakeAmount = Math.max(shakeAmount, 3 + energy * 6);

                // HP damage (only matters in finale)
                if (sectionMood === 'finale') {
                    if (f.defIdx === 0) {
                        duel.warrior1HP -= 12 + Math.floor(energy * 8);
                    } else {
                        duel.warrior2HP -= 12 + Math.floor(energy * 8);
                    }
                }
            }

            // Swap turn
            duel.turnToAttack = 1 - duel.turnToAttack;
        }

        // ── Duel helper: trigger a power clash (both attack) ──
        function triggerClash() {
            if (warrior1.mode === 'ragdoll' || warrior2.mode === 'ragdoll') return;
            StickFight.attack(warrior1, 'lunge', warrior2);
            StickFight.attack(warrior2, 'lunge', warrior1);
            slashTimers[0] = 1.0;
            slashTimers[1] = 1.0;
            duel.phase = 'clash';
            duel.clashTimer = 0.3;
            shakeAmount = Math.max(shakeAmount, 15);
            flashAlpha = Math.max(flashAlpha, 0.15);
            // Spark blood from clash point
            var midX = (warrior1.x + warrior2.x) * 0.5;
            var midY = warrior1.y - warrior1.figH * 0.5;
            StickFight.spawnBlood(midX, midY, 3, 0, -100);
        }

        // ── Duel helper: apply the killing blow in finale ──
        function triggerFinaleKill() {
            duel.finaleKillDone = true;
            duel.slowMoActive = true;
            duel.slowMoTimer = 1.5;

            // Warrior1 wins (the "hero")
            var loser = warrior2;
            var winner = warrior1;

            // Big blood burst
            StickFight.spawnBlood(loser.x, loser.y - loser.figH * 0.4, 25,
                winner.facing * 200, -180);

            // Apply dramatic death with dismemberment
            loser.hp = 0;
            StickFight.applyDeath(loser, 'flung', loser.y);

            // Extra dismemberment for spectacle
            StickFight.detachLimb(loser, 'armR', loser.y);

            // Screen effects
            shakeAmount = 25;
            flashAlpha = 0.6;

            // Victory pose for winner
            duel.victoryTimer = 0;
            StickFight.setPose(winner, 'salute');
            StickFight.setTarget(winner, 'swordAngle', -1.8);
        }

        // ── Main duel update — called each frame when warriors are active ──
        function updateDuel(dt, energy, beat, section) {
            var groundY = H * 0.78;

            // Slow-mo effect
            if (duel.slowMoActive) {
                duel.slowMoTimer -= dt;
                dt = dt * 0.25; // quarter speed
                if (duel.slowMoTimer <= 0) {
                    duel.slowMoActive = false;
                }
            }

            // Decay slash timers
            slashTimers[0] = Math.max(0, slashTimers[0] - dt * 3);
            slashTimers[1] = Math.max(0, slashTimers[1] - dt * 3);

            // Cooldown
            duel.attackCooldown = Math.max(0, duel.attackCooldown - dt);

            // Reset HP between non-finale sections
            if (section !== duel.lastSection) {
                duel.lastSection = section;
                if (section !== 'finale') {
                    duel.warrior1HP = 200;
                    duel.warrior2HP = 200;
                }
                duel.finaleBeats = 0;
            }

            // Post-kill victory handling
            if (duel.finaleKillDone) {
                duel.victoryTimer += dt;
                if (duel.victoryTimer > 1.5) {
                    StickFight.setPose(warrior1, 'arms_up');
                    StickFight.setTarget(warrior1, 'swordAngle', -2.0);
                }
                // Update effects for blood/limbs
                StickFight.updateEffects(dt, groundY);
                return;
            }

            faceEachOther();

            var gap = getGap();
            var figH = warrior1.figH;
            var strikeRange = figH * 0.7;  // close enough to hit
            var comfortGap = figH * 1.2;   // normal spacing
            var farGap = figH * 2.5;       // far apart
            var newBeat = (beat !== duel.lastAttackBeat);

            // ── Section-specific behavior ──
            if (section === 'twin-guitar') {
                // Circling phase — slow, tentative
                duel.circleTimer += dt;
                var circleSpeed = 40;
                var cx = (warrior1.x + warrior2.x) * 0.5;

                // Drift warriors in a circle around center
                if (duel.circleTimer > 3) {
                    duel.circleDir *= -1;
                    duel.circleTimer = 0;
                }
                moveWarriorX(warrior1, cx - comfortGap * 0.5 + duel.circleDir * 30, circleSpeed, dt);
                moveWarriorX(warrior2, cx + comfortGap * 0.5 - duel.circleDir * 30, circleSpeed, dt);

                // Guard pose as default
                if (!warrior1.attacking) StickFight.setPose(warrior1, 'guard');
                if (!warrior2.attacking) StickFight.setPose(warrior2, 'guard');

                // Occasional tentative attack (every 4th beat)
                if (newBeat && beat % 4 === 0 && energy > 0.3 && duel.attackCooldown <= 0) {
                    // Approach first
                    moveWarriorX(warrior1, warrior2.x - strikeRange * warrior1.facing, 200, dt);
                    triggerDuelAttack(energy);
                    duel.attackCooldown = 0.8;
                    duel.lastAttackBeat = beat;
                }

                // Bounce on beat
                if (newBeat) {
                    StickFight.setTarget(warrior1, 'bounce', 0.08);
                    StickFight.setTarget(warrior2, 'bounce', 0.08);
                }

            } else if (section === 'pre-chorus') {
                // Escalation — faster exchanges, every other beat
                var targetGap = comfortGap * 0.8;

                // Move toward each other
                if (gap > targetGap) {
                    moveWarriorX(warrior1, warrior2.x - targetGap * 0.5, 100, dt);
                    moveWarriorX(warrior2, warrior1.x + targetGap * 0.5, 100, dt);
                }

                if (!warrior1.attacking && !warrior2.attacking) {
                    StickFight.setPose(warrior1, 'guard');
                    StickFight.setPose(warrior2, 'guard');
                }

                // Attack every other beat
                if (newBeat && beat % 2 === 0 && duel.attackCooldown <= 0) {
                    if (gap > strikeRange) {
                        // Rush in
                        var f = getDuelFighters();
                        moveWarriorX(f.attacker, f.defender.x - strikeRange * f.attacker.facing, 250, dt);
                    }
                    triggerDuelAttack(energy);
                    duel.attackCooldown = 0.4;
                    duel.lastAttackBeat = beat;
                }

                // Separate after attacks land
                if (duel.attackCooldown > 0 && duel.attackCooldown < 0.2 && gap < comfortGap) {
                    moveWarriorX(warrior1, warrior1.x - warrior1.facing * 40, 180, dt);
                    moveWarriorX(warrior2, warrior2.x - warrior2.facing * 40, 180, dt);
                }

                if (newBeat) {
                    StickFight.setTarget(warrior1, 'bounce', 0.1 * energy);
                    StickFight.setTarget(warrior2, 'bounce', 0.1 * energy);
                }

            } else if (section === 'chorus') {
                // Full battle — attack every beat, intense
                var battleGap = strikeRange * 1.1;

                // Close distance aggressively
                if (gap > battleGap) {
                    moveWarriorX(warrior1, warrior2.x - battleGap * 0.5, 180, dt);
                    moveWarriorX(warrior2, warrior1.x + battleGap * 0.5, 180, dt);
                }

                if (!warrior1.attacking && !warrior2.attacking) {
                    StickFight.setPose(warrior1, 'guard');
                    StickFight.setPose(warrior2, 'guard');
                }

                // Attack every beat
                if (newBeat && duel.attackCooldown <= 0) {
                    // Occasional power clash (every 8th beat)
                    if (beat % 8 === 0 && Math.random() > 0.4) {
                        triggerClash();
                    } else {
                        triggerDuelAttack(energy);
                    }
                    duel.attackCooldown = 0.25;
                    duel.lastAttackBeat = beat;
                }

                // Handle clash recoil
                if (duel.phase === 'clash') {
                    duel.clashTimer -= dt;
                    if (duel.clashTimer <= 0) {
                        // Both recoil and separate
                        StickFight.setPose(warrior1, 'recoil');
                        StickFight.setPose(warrior2, 'recoil');
                        moveWarriorX(warrior1, warrior1.x - warrior1.facing * 60, 300, dt);
                        moveWarriorX(warrior2, warrior2.x - warrior2.facing * 60, 300, dt);
                        duel.phase = 'exchanging';
                    }
                }

                // Separate briefly after attacks
                if (!warrior1.attacking && !warrior2.attacking && gap < strikeRange * 0.8) {
                    moveWarriorX(warrior1, warrior1.x - warrior1.facing * 20, 120, dt);
                    moveWarriorX(warrior2, warrior2.x - warrior2.facing * 20, 120, dt);
                }

                if (newBeat) {
                    StickFight.setTarget(warrior1, 'bounce', 0.12 * energy);
                    StickFight.setTarget(warrior2, 'bounce', 0.12 * energy);
                }

            } else if (section === 'guitar-solo') {
                // Rest — guard pose, slow circle, catching breath
                var restGap = farGap;
                if (gap < restGap) {
                    moveWarriorX(warrior1, warrior1.x - warrior1.facing * 30, 50, dt);
                    moveWarriorX(warrior2, warrior2.x - warrior2.facing * 30, 50, dt);
                }
                StickFight.setPose(warrior1, 'guard');
                StickFight.setPose(warrior2, 'guard');
                StickFight.setTarget(warrior1, 'swordAngle', -0.5 + Math.sin(globalTime * 0.5) * 0.1);
                StickFight.setTarget(warrior2, 'swordAngle', -0.5 + Math.sin(globalTime * 0.5 + 1) * 0.1);

                // Slow circling drift
                duel.circleTimer += dt;
                if (duel.circleTimer > 4) {
                    duel.circleDir *= -1;
                    duel.circleTimer = 0;
                }
                moveWarriorX(warrior1, warrior1.x + duel.circleDir * 15, 20, dt);
                moveWarriorX(warrior2, warrior2.x - duel.circleDir * 15, 20, dt);

            } else if (section === 'build') {
                // Tension builds — slow approach, feints
                var buildTargetGap = lerp(farGap, comfortGap, clamp01(energy * 1.5));

                // Slowly approach
                var cx2 = (warrior1.x + warrior2.x) * 0.5;
                moveWarriorX(warrior1, cx2 - buildTargetGap * 0.5, 60 + energy * 80, dt);
                moveWarriorX(warrior2, cx2 + buildTargetGap * 0.5, 60 + energy * 80, dt);

                StickFight.setPose(warrior1, 'guard');
                StickFight.setPose(warrior2, 'guard');

                // Feints — start attack animation then cancel
                if (newBeat && beat % 3 === 0 && energy > 0.4) {
                    var feinter = duel.turnToAttack === 0 ? warrior1 : warrior2;
                    var feintIdx = duel.turnToAttack;
                    // Quick sword raise (feint) — just visual, no real attack
                    StickFight.setTarget(feinter, 'swordAngle', -2.0);
                    StickFight.setTarget(feinter, 'armLAngle', -0.8);
                    StickFight.setTarget(feinter, 'lean', 0.3);
                    slashTimers[feintIdx] = 0.3;
                    duel.turnToAttack = 1 - duel.turnToAttack;
                    duel.lastAttackBeat = beat;
                }

                if (newBeat) {
                    StickFight.setTarget(warrior1, 'bounce', 0.06 * energy);
                    StickFight.setTarget(warrior2, 'bounce', 0.06 * energy);
                }

            } else if (section === 'finale') {
                // Climactic final exchange — fastest, most intense
                var finaleGap = strikeRange * 0.9;

                // Close distance fast
                if (gap > finaleGap) {
                    moveWarriorX(warrior1, warrior2.x - finaleGap * 0.5, 220, dt);
                    moveWarriorX(warrior2, warrior1.x + finaleGap * 0.5, 220, dt);
                }

                if (!warrior1.attacking && !warrior2.attacking) {
                    StickFight.setPose(warrior1, 'guard');
                    StickFight.setPose(warrior2, 'guard');
                }

                // Attack EVERY beat
                if (newBeat && duel.attackCooldown <= 0) {
                    duel.finaleBeats++;

                    // Kill lands ~90% through the finale (~beat 280 of 320)
                    if (duel.finaleBeats >= 280 && !duel.finaleKillDone) {
                        triggerFinaleKill();
                    } else {
                        // Occasional clash
                        if (beat % 6 === 0 && Math.random() > 0.5) {
                            triggerClash();
                        } else {
                            triggerDuelAttack(energy);
                        }
                    }
                    duel.attackCooldown = 0.18;
                    duel.lastAttackBeat = beat;
                }

                // Handle clash
                if (duel.phase === 'clash') {
                    duel.clashTimer -= dt;
                    if (duel.clashTimer <= 0) {
                        StickFight.setPose(warrior1, 'recoil');
                        StickFight.setPose(warrior2, 'recoil');
                        duel.phase = 'exchanging';
                    }
                }

                if (newBeat) {
                    StickFight.setTarget(warrior1, 'bounce', 0.15);
                    StickFight.setTarget(warrior2, 'bounce', 0.15);
                }
            }

            // Relax bounce between beats (all sections)
            if (beatPulse < 0.15) {
                if (!warrior1.attacking) StickFight.setTarget(warrior1, 'bounce', 0);
                if (!warrior2.attacking) StickFight.setTarget(warrior2, 'bounce', 0);
            }

            // Keep warriors on screen
            var margin = figH * 0.5;
            warrior1.x = Math.max(margin, Math.min(W - margin, warrior1.x));
            warrior2.x = Math.max(margin, Math.min(W - margin, warrior2.x));

            // Update blood/gore effects
            StickFight.updateEffects(dt, groundY);
        }

        // ── Dragon drawing ──
        function drawDragon(ctx, energy) {
            if (sectionMood !== 'chorus' && sectionMood !== 'pre-chorus' && sectionMood !== 'finale') return;

            ctx.save();
            ctx.translate(dragon.x, dragon.y);

            var wingSpan = W * 0.18;
            var bodyLen = W * 0.08;

            // Wing flap
            dragon.wingAngle = Math.sin(globalTime * 4) * 0.4 + 0.2;
            var wingY = Math.sin(dragon.wingAngle) * H * 0.06;

            ctx.strokeStyle = COL.dragon;
            ctx.lineWidth = 3;
            ctx.shadowBlur = 15;
            ctx.shadowColor = COL.dragon;
            ctx.lineCap = 'round';

            // Body
            ctx.beginPath();
            ctx.moveTo(-bodyLen, 0);
            ctx.quadraticCurveTo(0, -bodyLen * 0.2, bodyLen * 0.6, bodyLen * 0.1);
            ctx.stroke();

            // Left wing
            ctx.beginPath();
            ctx.moveTo(-bodyLen * 0.3, -bodyLen * 0.1);
            ctx.quadraticCurveTo(-wingSpan * 0.5, -wingSpan * 0.5 + wingY, -wingSpan, wingY * 0.5);
            ctx.lineTo(-wingSpan * 0.7, -bodyLen * 0.05 + wingY * 0.3);
            ctx.lineTo(-wingSpan * 0.4, 0);
            ctx.stroke();

            // Right wing
            ctx.beginPath();
            ctx.moveTo(bodyLen * 0.1, -bodyLen * 0.1);
            ctx.quadraticCurveTo(wingSpan * 0.4, -wingSpan * 0.5 + wingY, wingSpan * 0.8, wingY * 0.5);
            ctx.lineTo(wingSpan * 0.5, -bodyLen * 0.05 + wingY * 0.3);
            ctx.lineTo(bodyLen * 0.2, 0);
            ctx.stroke();

            // Head
            var headX = bodyLen * 0.6 + Math.cos(dragon.headAngle) * bodyLen * 0.2;
            var headY = bodyLen * 0.1 + Math.sin(dragon.headAngle) * bodyLen * 0.1;
            ctx.beginPath();
            ctx.moveTo(bodyLen * 0.6, bodyLen * 0.1);
            ctx.lineTo(headX + bodyLen * 0.15, headY);
            ctx.stroke();
            // Eye
            ctx.fillStyle = COL.fire1;
            ctx.beginPath();
            ctx.arc(headX + bodyLen * 0.1, headY - bodyLen * 0.02, 3, 0, Math.PI * 2);
            ctx.fill();

            // Tail
            ctx.strokeStyle = COL.dragonDark;
            ctx.beginPath();
            ctx.moveTo(-bodyLen, 0);
            ctx.quadraticCurveTo(-bodyLen * 1.5, -bodyLen * 0.3 + Math.sin(globalTime * 3) * 10,
                                  -bodyLen * 1.8, -bodyLen * 0.1);
            ctx.stroke();

            // Dragon fire breath
            if (dragon.breathActive) {
                var fireOriginX = headX + bodyLen * 0.15;
                var fireOriginY = headY + 5;
                spawnDragonFire(dragon.x + fireOriginX, dragon.y + fireOriginY,
                    0.8 + Math.sin(globalTime * 6) * 0.2, 0.5, 3);
            }

            ctx.restore();
        }

        function drawDragonFireParticles(ctx) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            for (var i = 0; i < dragonFireParticles.length; i++) {
                var p = dragonFireParticles[i];
                var t = p.life / p.maxLife;
                var alpha = (1 - t) * 0.8;
                var hue = p.hue + t * 30;
                // Map hue 0-90 to fire colors
                var r = 255;
                var g = Math.floor(lerp(100, 255, clamp01(hue / 60)));
                var b = hue > 40 ? Math.floor(lerp(0, 100, (hue - 40) / 50)) : 0;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * (1 - t * 0.3), 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        // ── Fretboard / note highway ──
        function drawFretboard(ctx, energy, beat) {
            if (sectionMood !== 'guitar-solo') return;

            ctx.save();
            var fbY = H * 0.55;
            var fbH = H * 0.35;
            var vanishY = fbY;
            var bottomY = fbY + fbH;
            var laneW = W * 0.08;
            var centerX = W * 0.5;
            var laneColors = [COL.fire1, COL.fire2, COL.fire3, COL.dragon, COL.steelBright];

            // Highway surface
            ctx.fillStyle = rgba('#0a0412', 0.7);
            ctx.beginPath();
            ctx.moveTo(centerX - laneW * 0.5, vanishY);
            ctx.lineTo(centerX + laneW * 0.5, vanishY);
            ctx.lineTo(centerX + laneW * 3, bottomY);
            ctx.lineTo(centerX - laneW * 3, bottomY);
            ctx.fill();

            // Lane dividers
            ctx.strokeStyle = rgba('#ffffff', 0.15);
            ctx.lineWidth = 1;
            for (var lane = 0; lane <= 5; lane++) {
                var topX = centerX + (lane - 2.5) * laneW * 0.2;
                var botX = centerX + (lane - 2.5) * laneW * 1.2;
                ctx.beginPath();
                ctx.moveTo(topX, vanishY);
                ctx.lineTo(botX, bottomY);
                ctx.stroke();
            }

            // Scrolling notes
            for (var i = 0; i < fretNotes.length; i++) {
                var n = fretNotes[i];
                n.z += dt * n.speed * (1 + energy * 2);
                if (n.z > 1) {
                    n.z = 0;
                    n.lane = Math.floor(rand(0, 5));
                    n.speed = rand(0.3, 1.0);
                    n.color = Math.floor(rand(0, 5));
                    n.active = energy > 0.2;
                }
                if (!n.active) continue;

                var progress = n.z;
                var noteY = vanishY + progress * fbH;
                var noteX = centerX + (n.lane - 2) * laneW * (0.2 + progress * 1.0);
                var noteSize = 4 + progress * 12;

                ctx.globalAlpha = 0.5 + progress * 0.5;
                ctx.fillStyle = laneColors[n.color];
                ctx.shadowBlur = 10;
                ctx.shadowColor = laneColors[n.color];
                ctx.beginPath();
                ctx.arc(noteX, noteY, noteSize, 0, Math.PI * 2);
                ctx.fill();
            }

            // Hit line
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#ffffff';
            ctx.globalAlpha = 0.6 + beatPulse * 0.4;
            ctx.beginPath();
            ctx.moveTo(centerX - laneW * 2.8, bottomY - 20);
            ctx.lineTo(centerX + laneW * 2.8, bottomY - 20);
            ctx.stroke();

            ctx.restore();
        }

        // ── Acoustic campfire scene ──
        function drawCampfireScene(ctx, energy) {
            if (sectionMood !== 'acoustic') return;

            ctx.save();
            var groundY = H * 0.78;

            // Calm fire at center
            var fireX = W * 0.5;
            var fireY = groundY;

            // Fire glow
            var glowR = 80 + Math.sin(globalTime * 5) * 15;
            var grad = ctx.createRadialGradient(fireX, fireY, 5, fireX, fireY, glowR);
            grad.addColorStop(0, rgba('#ff8844', 0.4));
            grad.addColorStop(0.5, rgba('#ff4400', 0.15));
            grad.addColorStop(1, 'rgba(255,68,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(fireX - glowR, fireY - glowR, glowR * 2, glowR * 2);

            // Small campfire flames
            for (var i = 0; i < 8; i++) {
                var angle = (i / 8) * Math.PI * 2 + globalTime * 2;
                var flameH = 20 + Math.sin(angle * 3 + globalTime * 8) * 10;
                var fx = fireX + Math.cos(angle) * 8;

                ctx.fillStyle = i % 2 === 0 ? COL.fire2 : COL.fire3;
                ctx.globalAlpha = 0.5 + Math.sin(globalTime * 6 + i) * 0.3;
                ctx.beginPath();
                ctx.moveTo(fx - 4, fireY);
                ctx.quadraticCurveTo(fx + Math.sin(globalTime * 4 + i) * 5, fireY - flameH * 0.6,
                                      fx, fireY - flameH);
                ctx.quadraticCurveTo(fx - Math.sin(globalTime * 3 + i) * 3, fireY - flameH * 0.4,
                                      fx + 4, fireY);
                ctx.fill();
            }

            // Log silhouettes
            ctx.globalAlpha = 0.8;
            ctx.fillStyle = '#1a0a04';
            ctx.beginPath();
            ctx.ellipse(fireX, fireY + 5, 25, 6, 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(fireX, fireY + 5, 22, 5, -0.4, 0, Math.PI * 2);
            ctx.fill();

            // Sitting warrior silhouettes
            ctx.fillStyle = 'rgba(10,4,8,0.85)';
            // Left figure
            ctx.beginPath();
            ctx.ellipse(fireX - W * 0.08, groundY - 20, 12, 25, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(fireX - W * 0.08, groundY - 50, 8, 0, Math.PI * 2);
            ctx.fill();
            // Right figure
            ctx.beginPath();
            ctx.ellipse(fireX + W * 0.09, groundY - 18, 11, 24, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(fireX + W * 0.09, groundY - 47, 8, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // ── Title overlay ──
        function drawTitle(ctx, alpha) {
            if (alpha < 0.01) return;
            ctx.save();

            var fontSize = Math.max(16, Math.min(W * 0.035, 42));
            ctx.font = '900 ' + fontSize + 'px "Cinzel", serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.globalAlpha = alpha;

            // Fire glow on text
            ctx.shadowColor = '#ff4400';
            ctx.shadowBlur = 40;
            ctx.fillStyle = '#ff6600';
            ctx.fillText('THROUGH THE FIRE AND FLAMES', W * 0.5, H * 0.13);

            // White core
            ctx.shadowColor = '#ffcc00';
            ctx.shadowBlur = 20;
            ctx.fillStyle = '#ffddaa';
            ctx.globalAlpha = alpha * 0.7;
            ctx.fillText('THROUGH THE FIRE AND FLAMES', W * 0.5, H * 0.13);

            ctx.restore();
        }

        // ── Beat flash ──
        function drawFlash(ctx) {
            if (flashAlpha < 0.01) return;
            ctx.save();
            ctx.globalAlpha = flashAlpha;
            ctx.fillStyle = '#ff8844';
            ctx.fillRect(0, 0, W, H);
            ctx.restore();
        }

        // ── Charge particles (finale) ──
        function updateChargeParticles(dt, energy) {
            // Spawn new
            if (sectionMood === 'finale' || sectionMood === 'build') {
                var spawnCount = Math.floor(energy * 5);
                for (var s = 0; s < spawnCount; s++) {
                    if (chargeParticles.length < 200) {
                        var angle = rand(0, Math.PI * 2);
                        var dist = rand(100, Math.max(W, H));
                        chargeParticles.push({
                            x: W * 0.5 + Math.cos(angle) * dist,
                            y: H * 0.5 + Math.sin(angle) * dist,
                            tx: W * 0.5 + rand(-50, 50),
                            ty: H * 0.5 + rand(-50, 50),
                            speed: rand(0.5, 2),
                            life: 0, maxLife: rand(0.5, 1.5),
                            size: rand(1, 4),
                            color: Math.random() > 0.5 ? COL.fire3 : COL.fire1
                        });
                    }
                }
            }

            for (var i = chargeParticles.length - 1; i >= 0; i--) {
                var p = chargeParticles[i];
                p.life += dt;
                if (p.life >= p.maxLife) {
                    chargeParticles.splice(i, 1);
                    continue;
                }
                var t = p.life / p.maxLife;
                p.x = lerp(p.x, p.tx, t * p.speed * dt * 10);
                p.y = lerp(p.y, p.ty, t * p.speed * dt * 10);
            }
        }

        function drawChargeParticles(ctx) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            for (var i = 0; i < chargeParticles.length; i++) {
                var p = chargeParticles[i];
                var t = p.life / p.maxLife;
                ctx.globalAlpha = (1 - t) * 0.7;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        // ── Screen shake helper ──
        var shakeAmount = 0;
        function applyShake(ctx) {
            if (shakeAmount < 0.5) return;
            var sx = (Math.random() - 0.5) * shakeAmount;
            var sy = (Math.random() - 0.5) * shakeAmount;
            ctx.translate(sx, sy);
        }

        // ── Vignette ──
        function drawVignette(ctx, intensity) {
            var grad = ctx.createRadialGradient(W * 0.5, H * 0.5, W * 0.2, W * 0.5, H * 0.5, W * 0.8);
            grad.addColorStop(0, 'rgba(0,0,0,0)');
            grad.addColorStop(1, rgba('#000000', 0.4 + intensity * 0.3));
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, W, H);
        }

        // ══════════════════════════════════════════════════════════
        // ── Init ──
        function init(ctx, width, height, anal) {
            W = width; H = height;
            analysis = anal;
            globalTime = 0;
            beatPulse = 0;
            flashAlpha = 0;
            sectionMood = 'keyboard-intro';
            lastSeqIndex = -1;
            shakeAmount = 0;

            var figH = H * 0.22;
            var groundY = H * 0.78;
            var fightCenter = W * 0.5;
            var fightSpread = figH * 2.0;
            warrior1 = StickFight.create({ x: fightCenter - fightSpread, y: groundY, figH: figH, facing: 1, color: COL.steel, lineWidth: 3, poseSpeed: 12 });
            warrior2 = StickFight.create({ x: fightCenter + fightSpread, y: groundY, figH: figH, facing: -1, color: COL.steel, lineWidth: 3, poseSpeed: 12 });
            // Give both warriors swords
            warrior1.params.swordLen = 0.35;
            warrior1.targets.swordLen = 0.35;
            warrior1.params.swordAngle = -0.8;
            warrior1.targets.swordAngle = -0.8;
            warrior2.params.swordLen = 0.35;
            warrior2.targets.swordLen = 0.35;
            warrior2.params.swordAngle = -0.8;
            warrior2.targets.swordAngle = -0.8;
            StickFight.setPose(warrior1, 'guard');
            StickFight.setPose(warrior2, 'guard');
            warriors = [warrior1, warrior2];
            slashTimers = [0, 0];

            // Reset duel state
            duel.phase = 'idle';
            duel.turnToAttack = 0;
            duel.exchangeTimer = 0;
            duel.separationTimer = 0;
            duel.approachTimer = 0;
            duel.clashTimer = 0;
            duel.warrior1HP = 200;
            duel.warrior2HP = 200;
            duel.finaleKillDone = false;
            duel.finaleBeats = 0;
            duel.circleDir = 1;
            duel.circleTimer = 0;
            duel.lastAttackBeat = -1;
            duel.attackCooldown = 0;
            duel.lastSection = '';
            duel.slowMoTimer = 0;
            duel.slowMoActive = false;
            duel.victoryTimer = 0;

            dragon.x = W * 0.55;
            dragon.y = H * 0.2;

            dragonFireParticles = [];
            chargeParticles = [];

            initFlames(120);
            initEmbers(100);
            initStars(150);
            initFretNotes();
        }

        // ── Resize ──
        function resize(width, height) {
            W = width; H = height;
            if (warrior1) {
                var figH = H * 0.22;
                var fightCenter = W * 0.5;
                var fightSpread = figH * 2.0;
                warrior1.y = H * 0.78;
                warrior1.figH = figH;
                warrior2.y = H * 0.78;
                warrior2.figH = figH;
                // Recalculate from center + figH spread, clamped to screen
                var margin = figH * 0.5;
                warrior1.x = Math.max(margin, Math.min(W - margin, fightCenter - fightSpread));
                warrior2.x = Math.max(margin, Math.min(W - margin, fightCenter + fightSpread));
            }
            dragon.x = W * 0.55;
            dragon.y = H * 0.2;
        }

        // ── Main render ──
        function render(frameData) {
            var ctx = frameData.ctx;
            var dt = frameData.dt || 1/60;
            var cursor = frameData.cursor;
            beatPulse = frameData.beatPulse;

            globalTime += dt;

            // Background
            ctx.fillStyle = COL.bg;
            ctx.fillRect(0, 0, W, H);

            if (!cursor) {
                // Idle: dark sky + stars + mountains
                drawSkyGradient(ctx, 'keyboard-intro', 0);
                drawStars(ctx, 0.5);
                drawMountains(ctx, 0);
                drawGround(ctx, 0);
                drawVignette(ctx, 0);
                return;
            }

            var beat = cursor.beat;
            var seqIdx = cursor.seqIndex;
            var energy = analysis ? (analysis.energy[cursor.timelineIndex] || 0) : 0;

            // ── Section transitions ──
            var newSection = mapSection(seqIdx);
            if (seqIdx !== lastSeqIndex) {
                sectionMood = newSection;
                lastSeqIndex = seqIdx;

                // Flash on major transitions
                if (newSection === 'chorus' || newSection === 'finale') {
                    flashAlpha = 0.5;
                    shakeAmount = 12;
                }
                if (newSection === 'guitar-solo') {
                    flashAlpha = 0.3;
                }
                // Dragon breath triggers
                if (newSection === 'chorus' || newSection === 'finale') {
                    dragon.breathActive = true;
                    dragon.breathTimer = 0;
                }
                if (newSection === 'acoustic') {
                    dragon.breathActive = false;
                }
            }

            // ── Beat detection ──
            if (frameData.beatChanged) {

                // Flash on strong beats in intense sections
                if ((sectionMood === 'chorus' || sectionMood === 'finale') && energy > 0.5) {
                    flashAlpha = Math.max(flashAlpha, 0.08 + energy * 0.12);
                    shakeAmount = Math.max(shakeAmount, 4 + energy * 8);
                }
                if (sectionMood === 'twin-guitar' && energy > 0.4) {
                    flashAlpha = Math.max(flashAlpha, 0.05);
                }
            }

            // Decay
            beatPulse *= Math.exp(-10 * dt); // faster decay at 200 BPM
            flashAlpha *= Math.exp(-8 * dt);
            shakeAmount *= Math.exp(-6 * dt);

            // ── Dragon breath management ──
            if (dragon.breathActive) {
                dragon.breathTimer += dt;
                if (dragon.breathTimer > 3) {
                    dragon.breathActive = false;
                }
                dragon.headAngle = Math.sin(globalTime * 2) * 0.3;
            }
            // Re-trigger breath on chorus beats
            if ((sectionMood === 'chorus' || sectionMood === 'finale') && frameData.beatChanged && Math.random() > 0.7) {
                dragon.breathActive = true;
                dragon.breathTimer = 0;
            }

            // Dragon movement
            var dragonFigH = warrior1 ? warrior1.figH : H * 0.22;
            dragon.x = W * 0.5 + Math.sin(globalTime * 0.5) * Math.min(W * 0.2, dragonFigH * 4);
            dragon.y = H * 0.18 + Math.sin(globalTime * 0.8) * H * 0.05;

            // ── Determine intensity multiplier ──
            var flameIntensity = 0;
            var showWarriors = false;
            var showTitle = false;
            var titleAlpha = 0;
            var starsAlpha = 0;

            switch (sectionMood) {
                case 'keyboard-intro':
                    flameIntensity = clamp01(globalTime * 0.08) * 0.5 + energy * 0.3;
                    starsAlpha = 0.6;
                    showTitle = true;
                    titleAlpha = clamp01(energy * 2);
                    break;
                case 'twin-guitar':
                    flameIntensity = 0.4 + energy * 0.4;
                    showWarriors = true;
                    starsAlpha = 0.3;
                    break;
                case 'pre-chorus':
                    flameIntensity = 0.5 + energy * 0.5;
                    showWarriors = true;
                    starsAlpha = 0.2;
                    break;
                case 'chorus':
                    flameIntensity = 0.7 + energy * 0.3;
                    showWarriors = true;
                    showTitle = true;
                    titleAlpha = 0.8 + beatPulse * 0.2;
                    starsAlpha = 0.1;
                    break;
                case 'guitar-solo':
                    flameIntensity = 0.3 + energy * 0.5;
                    showWarriors = true;
                    starsAlpha = 0.2;
                    break;
                case 'acoustic':
                    flameIntensity = 0;
                    starsAlpha = 0.9;
                    break;
                case 'build':
                    flameIntensity = energy;
                    showWarriors = true;
                    starsAlpha = 0.15;
                    break;
                case 'finale':
                    flameIntensity = 1;
                    showWarriors = true;
                    showTitle = true;
                    titleAlpha = 1;
                    starsAlpha = 0;
                    break;
            }

            // ── Update systems ──
            updateFlames(dt, energy, flameIntensity);
            updateEmbers(dt, energy);
            updateDragonFire(dt);
            updateChargeParticles(dt, energy);

            if (showWarriors) {
                updateDuel(dt, energy, beat, sectionMood);
            }
            StickFight.updateAll(warriors, dt);

            // ── Draw scene ──
            ctx.save();
            applyShake(ctx);

            // Sky
            drawSkyGradient(ctx, sectionMood, energy);

            // Stars (prominent in acoustic, faint otherwise)
            if (starsAlpha > 0.01) {
                drawStars(ctx, starsAlpha);
            }

            // Mountains (not in acoustic close-up)
            if (sectionMood !== 'acoustic') {
                drawMountains(ctx, energy);
            }

            // Dragon (choruses and finale)
            drawDragon(ctx, energy);
            drawDragonFireParticles(ctx);

            // Ground
            drawGround(ctx, energy);

            // Campfire scene (acoustic)
            drawCampfireScene(ctx, energy);

            // Warriors
            if (showWarriors) {
                StickFight.drawAll(ctx, warriors);
                drawWarriorExtras(ctx, warrior1, 0, energy);
                drawWarriorExtras(ctx, warrior2, 1, energy);
                // Blood, dismembered limbs
                StickFight.drawEffects(ctx);
            }

            // Flames from bottom
            if (flameIntensity > 0.01) {
                drawFlames(ctx, energy, flameIntensity);
                drawEmbers(ctx, energy);
            }

            // Fretboard (guitar solo)
            drawFretboard(ctx, energy, beat);

            // Charge particles (build + finale)
            if (sectionMood === 'build' || sectionMood === 'finale') {
                drawChargeParticles(ctx);
            }

            // Title
            if (showTitle) {
                drawTitle(ctx, titleAlpha);
            }

            // Vignette
            drawVignette(ctx, sectionMood === 'acoustic' ? 0.5 : energy * 0.3);

            ctx.restore();

            // Flash on top (outside shake transform)
            drawFlash(ctx);
        }

        BaseRenderer('ttfaf-video', 'Through the Fire and Flames', {
            beatDecay: 10,
            init: init,
            render: render,
            resize: resize
        });
    })();

    // ── Page bootstrap ──
    (function() {
        var canvas = document.getElementById('viz-canvas');
        var overlay = document.getElementById('play-overlay');

        Visualizer.init(canvas);
        Visualizer.setRenderer('ttfaf-video');

        function loadAndPlay(json) {
            Visualizer.loadSong(json);
            Visualizer.play();
        }

        function fetchSong() {
            var url = '../audio-tracker/songs/through-the-fire-and-flames.json';
            if (window.fetch && location.protocol !== 'file:') {
                return fetch(url).then(function(r) { return r.json(); });
            }
            return new Promise(function(resolve, reject) {
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.onload = function() {
                    if (xhr.status === 200 || xhr.status === 0) {
                        resolve(JSON.parse(xhr.responseText));
                    } else {
                        reject(new Error('XHR failed: ' + xhr.status));
                    }
                };
                xhr.onerror = function() { reject(new Error('XHR error')); };
                xhr.send();
            });
        }

        overlay.addEventListener('click', function() {
            overlay.classList.add('hidden');
            fetchSong().then(loadAndPlay).catch(function(err) {
                console.error('Failed to load song:', err);
                overlay.classList.remove('hidden');
            });
        });

        // Auto-play when embedded (e.g. jukebox iframe with ?autoplay=1)
        if (new URLSearchParams(window.location.search).get('autoplay') === '1') {
            overlay.click();
        }

        canvas.addEventListener('click', function() {
            if (overlay.classList.contains('hidden')) {
                if (Visualizer.isPlaying()) {
                    Visualizer.stop();
                } else {
                    Visualizer.play();
                }
            }
        });
    })();
    </script>
</body>
</html>
