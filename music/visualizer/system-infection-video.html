<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>System Infection — Music Video</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background: #0a0a0c;
            color: #fff;
            font-family: 'JetBrains Mono', monospace;
        }
        #viz-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: block;
            cursor: pointer;
        }
        .play-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            background: rgba(10,10,12,0.94);
            cursor: pointer;
            transition: opacity 0.5s;
        }
        .play-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .play-title {
            font-size: clamp(16px, 4vw, 40px);
            font-weight: 700;
            letter-spacing: 0.06em;
            text-transform: uppercase;
            color: #44aadd;
            text-shadow: 0 0 30px rgba(68,136,204,0.4), 0 0 60px rgba(68,136,204,0.2);
            margin-bottom: 12px;
        }
        .play-sub {
            font-size: clamp(12px, 2vw, 18px);
            color: rgba(255,255,255,0.4);
            margin-bottom: 40px;
        }
        .play-btn {
            width: 80px; height: 80px;
            border: 3px solid #4488cc;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: pulse 2s ease-in-out infinite;
        }
        .play-btn::after {
            content: '';
            display: block;
            width: 0; height: 0;
            border-style: solid;
            border-width: 18px 0 18px 30px;
            border-color: transparent transparent transparent #4488cc;
            margin-left: 6px;
        }
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(68,136,204,0.4); }
            50% { box-shadow: 0 0 0 20px rgba(68,136,204,0); }
        }
        .back-link {
            position: fixed;
            top: 12px; left: 12px;
            z-index: 30;
            color: rgba(255,255,255,0.4);
            text-decoration: none;
            font-size: 13px;
            padding: 6px 10px;
            border-radius: 6px;
            background: rgba(0,0,0,0.4);
            transition: color 0.2s;
        }
        .back-link:hover { color: rgba(255,255,255,0.8); }
    </style>
</head>
<body>
    <a href="music-videos/index.html" class="back-link">&larr; Music Videos</a>
    <canvas id="viz-canvas"></canvas>
    <div class="play-overlay" id="play-overlay">
        <div class="play-title">System Infection</div>
        <div class="play-sub">stickdeath arena battle</div>
        <div class="play-btn"></div>
    </div>

    <script src="../audio-tracker/playback-engine.js"></script>
    <script src="engine.js"></script>
    <script src="stick-fight-engine.js"></script>
    <script>
    // ── System Infection Video Renderer ──────────────────────────────
    window.Renderers['system-infection-video'] = (function() {
        "use strict";

        var W = 0, H = 0;
        var analysis = null;

        // ── Palette ──
        var BG_COLOR = '#0a0a0c';
        var GROUND_COLOR = '#161620';
        var GROUND_LINE_COLOR = '#2a2a3a';
        var HERO_COLOR = '#4488cc';
        var ENEMY_COLORS = ['#cc4444', '#cc6644', '#cc5533', '#bb3333', '#dd5555'];
        var SPOTLIGHT_COLOR = 'rgba(68,136,204,';
        var CROWD_COLOR = '#0c0c14';

        // Key change palette (Eb minor, patterns 23-24)
        var KEY_CHANGE_HERO = '#3388aa';
        var KEY_CHANGE_GROUND = '#141420';
        var KEY_CHANGE_SPOTLIGHT = 'rgba(50,120,170,';

        // ── Layout ──
        var GROUND_Y_RATIO = 0.78;
        var groundY = 0;
        var arenaLeft = 0;
        var arenaRight = 0;

        // ── State ──
        var lastBeat = -1;
        var beatPulse = 0;
        var lastSeqIndex = -1;
        var section = 'intro';

        // Screen shake
        var shakeX = 0, shakeY = 0;
        var shakeIntensity = 0;

        // Slow-motion
        var slowMoFactor = 1;
        var slowMoTimer = 0;

        // Hero glow (for breakdown)
        var heroGlow = 0;
        var heroGlowTarget = 0;

        // Spotlight
        var spotlightAlpha = 0;
        var spotlightTarget = 0;

        // Title
        var titleAlpha = 0;
        var titleTarget = 0;

        // Screen pulse (heartbeat in breakdown)
        var screenPulse = 0;

        // Key change blend
        var keyChangeBlend = 0;

        // ── Figures ──
        var hero = null;
        var activeFigs = [];   // enemies currently fighting
        var deadFigs = [];     // ragdolled/dead enemies still drawn
        var allFigs = [];      // hero + active enemies for updateAll

        // Enemy AI state
        var enemyTimers = [];  // per-enemy attack cooldown

        // Wave management
        var waveEnemies = 0;
        var waveSpawned = 0;
        var spawnTimer = 0;
        var spawnInterval = 1.5;
        var currentWaveHP = 100;
        var currentWaveSwords = false;
        var currentWaveFigHMult = 1;

        // Combo tracking for signature moves
        var signatureComboQueue = [];
        var signatureTimer = 0;

        // Beat-synced attack queue for hero
        var heroAttackQueue = [];
        var heroAttackCooldown = 0;

        // Hero state machine: 'seeking', 'engaging', 'attacking', 'dodging', 'post_kill'
        var heroState = 'seeking';
        var heroStateTimer = 0;
        var lastKillTime = 0;
        var heroLastEnemyCount = 0;

        // Track which enemy is currently allowed to attack
        var activeAttackerIdx = -1;
        var activeAttackerTimer = 0;

        // Boss ref
        var boss = null;
        var bossDefeated = false;
        var finalChorusBeats = 0;

        // Intro animation
        var introDropY = -200;
        var introDropDone = false;

        // Outro
        var outroAlpha = 0;
        var outroStarted = false;

        // Crowd silhouettes
        var crowdBumps = [];

        // ── Helpers ──
        function lerp(a, b, t) { return a + (b - a) * t; }
        function lerpExp(current, target, speed, dt) {
            return current + (target - current) * (1 - Math.exp(-speed * dt));
        }
        function rand(min, max) { return min + Math.random() * (max - min); }
        function randInt(min, max) { return Math.floor(rand(min, max + 1)); }
        function pickRandom(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

        // ── Section mapping ──
        function mapSection(seqIndex) {
            if (seqIndex <= 3) return 'intro';
            if (seqIndex <= 7) return 'verse1';
            if (seqIndex <= 11) return 'chorus1';
            if (seqIndex === 12) return 'bridge';
            if (seqIndex <= 15) return 'verse2';
            if (seqIndex <= 18) return 'chorus2';
            if (seqIndex <= 22) return 'breakdown';
            if (seqIndex <= 24) return 'final_chorus';
            return 'outro';
        }

        // ── Arena drawing ──
        function drawArena(ctx, energy) {
            // Background
            var bgCol = keyChangeBlend > 0.1 ? KEY_CHANGE_GROUND : BG_COLOR;
            ctx.fillStyle = bgCol;
            ctx.fillRect(0, 0, W, H);

            // Screen pulse (breakdown heartbeat)
            if (screenPulse > 0.01) {
                ctx.save();
                ctx.globalAlpha = screenPulse * 0.08;
                ctx.fillStyle = '#cc2222';
                ctx.fillRect(0, 0, W, H);
                ctx.restore();
            }

            // Crowd silhouettes along top
            ctx.save();
            ctx.fillStyle = CROWD_COLOR;
            for (var i = 0; i < crowdBumps.length; i++) {
                var b = crowdBumps[i];
                var bounceOff = beatPulse * 3 * (i % 2 === 0 ? 1 : -1);
                ctx.beginPath();
                ctx.ellipse(b.x, b.y + bounceOff, b.w, b.h, 0, Math.PI, 0);
                ctx.fill();
            }
            ctx.restore();

            // Spotlights
            if (spotlightAlpha > 0.01) {
                var spotColor = keyChangeBlend > 0.5 ? KEY_CHANGE_SPOTLIGHT : SPOTLIGHT_COLOR;
                // Center spotlight on hero
                var heroX = hero ? hero.x : W * 0.5;
                ctx.save();
                var grad = ctx.createRadialGradient(heroX, 0, 10, heroX, groundY, W * 0.25);
                grad.addColorStop(0, spotColor + (spotlightAlpha * 0.3) + ')');
                grad.addColorStop(0.6, spotColor + (spotlightAlpha * 0.08) + ')');
                grad.addColorStop(1, spotColor + '0)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.moveTo(heroX - W * 0.2, 0);
                ctx.lineTo(heroX - W * 0.35, groundY);
                ctx.lineTo(heroX + W * 0.35, groundY);
                ctx.lineTo(heroX + W * 0.2, 0);
                ctx.fill();
                ctx.restore();

                // Side spotlights during combat
                if (section !== 'intro' && section !== 'outro') {
                    ctx.save();
                    var sideAlpha = spotlightAlpha * 0.15;
                    ctx.fillStyle = 'rgba(200,80,40,' + sideAlpha + ')';
                    var grad2 = ctx.createRadialGradient(W * 0.1, 0, 5, W * 0.1, groundY, W * 0.15);
                    grad2.addColorStop(0, 'rgba(200,80,40,' + sideAlpha + ')');
                    grad2.addColorStop(1, 'rgba(200,80,40,0)');
                    ctx.fillStyle = grad2;
                    ctx.fillRect(0, 0, W * 0.3, groundY);

                    var grad3 = ctx.createRadialGradient(W * 0.9, 0, 5, W * 0.9, groundY, W * 0.15);
                    grad3.addColorStop(0, 'rgba(200,80,40,' + sideAlpha + ')');
                    grad3.addColorStop(1, 'rgba(200,80,40,0)');
                    ctx.fillStyle = grad3;
                    ctx.fillRect(W * 0.7, 0, W * 0.3, groundY);
                    ctx.restore();
                }
            }

            // Ground
            ctx.fillStyle = GROUND_COLOR;
            ctx.fillRect(0, groundY, W, H - groundY);

            // Ground line
            ctx.strokeStyle = GROUND_LINE_COLOR;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, groundY);
            ctx.lineTo(W, groundY);
            ctx.stroke();

            // Ground reflection shimmer
            var shimmer = 0.01 + energy * 0.03 + beatPulse * 0.02;
            var gGrad = ctx.createLinearGradient(0, groundY, 0, groundY + (H - groundY) * 0.3);
            gGrad.addColorStop(0, 'rgba(68,136,204,' + shimmer + ')');
            gGrad.addColorStop(1, 'rgba(68,136,204,0)');
            ctx.fillStyle = gGrad;
            ctx.fillRect(0, groundY, W, (H - groundY) * 0.3);

            // Arena cracks (verse2+)
            if (section === 'verse2' || section === 'chorus2' || section === 'breakdown' || section === 'final_chorus') {
                ctx.save();
                ctx.strokeStyle = 'rgba(80,30,30,0.3)';
                ctx.lineWidth = 1;
                var crackCount = section === 'breakdown' ? 8 : 4;
                for (var ci = 0; ci < crackCount; ci++) {
                    var cx = W * (0.1 + ci * 0.1);
                    ctx.beginPath();
                    ctx.moveTo(cx, groundY);
                    for (var cj = 0; cj < 5; cj++) {
                        cx += rand(-15, 15);
                        ctx.lineTo(cx, groundY + cj * 8);
                    }
                    ctx.stroke();
                }
                ctx.restore();
            }
        }

        // ── Hero glow effect (breakdown) ──
        function drawHeroGlow(ctx) {
            if (heroGlow < 0.05 || !hero || hero.mode === 'ragdoll') return;
            ctx.save();
            ctx.shadowColor = HERO_COLOR;
            ctx.shadowBlur = 20 + heroGlow * 40;
            ctx.globalAlpha = heroGlow * 0.4;
            ctx.strokeStyle = HERO_COLOR;
            ctx.lineWidth = 6;
            // Draw a glow outline around hero position
            var joints = StickFight.computeJoints(hero);
            ctx.beginPath();
            ctx.arc(hero.x + joints.head.x, hero.y + joints.head.y, joints.headR + 8, 0, Math.PI * 2);
            ctx.stroke();
            // Body glow line
            ctx.beginPath();
            ctx.moveTo(hero.x + joints.hip.x, hero.y + joints.hip.y);
            ctx.lineTo(hero.x + joints.neck.x, hero.y + joints.neck.y);
            ctx.stroke();
            ctx.restore();
        }

        // ── Title drawing ──
        function drawTitle(ctx) {
            if (titleAlpha < 0.01) return;
            ctx.save();
            ctx.globalAlpha = titleAlpha;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            var fontSize = Math.max(14, Math.min(W * 0.035, 42));
            ctx.font = '700 ' + fontSize + 'px "JetBrains Mono", monospace';
            ctx.shadowColor = HERO_COLOR;
            ctx.shadowBlur = 30;
            ctx.fillStyle = '#4488cc';
            ctx.fillText('SYSTEM INFECTION', W * 0.5, H * 0.1);

            ctx.font = '400 ' + (fontSize * 0.45) + 'px "JetBrains Mono", monospace';
            ctx.shadowBlur = 15;
            ctx.fillStyle = 'rgba(180,190,220,0.5)';
            ctx.fillText('ARENA BATTLE', W * 0.5, H * 0.1 + fontSize * 1.1);
            ctx.restore();
        }

        // ── Spawn enemies ──
        var _lastSpawnSide = 1;
        function spawnEnemy(hp, hasSword, figHMult, isBoss) {
            // Alternate sides so enemies don't cluster on one side
            _lastSpawnSide *= -1;
            var side = _lastSpawnSide;
            var figH = H * 0.28 * (figHMult || 1);
            if (isBoss) figH = H * 0.42;
            var spawnX = side < 0 ? arenaLeft - figH * 0.5 : arenaRight + figH * 0.5;

            var fig = StickFight.create({
                x: spawnX,
                y: groundY,
                figH: figH,
                facing: side < 0 ? 1 : -1,
                color: isBoss ? '#ff6622' : pickRandom(ENEMY_COLORS),
                poseSpeed: 8,
                hp: hp || 100
            });

            if (hasSword) {
                fig.params.swordLen = 0.3;
                fig.targets.swordLen = 0.3;
            }

            fig._walkTarget = hero ? hero.x + rand(-figH * 0.7, figH * 0.7) : W * 0.5;
            fig._isBoss = isBoss || false;

            StickFight.setPose(fig, 'guard');
            activeFigs.push(fig);
            enemyTimers.push({ cooldown: rand(0.5, 1.5), fig: fig });
            return fig;
        }

        // ── Start a wave of enemies ──
        function startWave(count, hp, swords, figHMult) {
            waveEnemies = count;
            waveSpawned = 0;
            spawnTimer = 0;
            spawnInterval = Math.max(0.3, 1.5 - count * 0.1);
            currentWaveHP = hp || 100;
            currentWaveSwords = swords || false;
            currentWaveFigHMult = figHMult || 1;
        }

        // ── Enemy AI ──
        // Enemies form a queue: only the 1-2 nearest engage in melee,
        // others hang back at staggered distances creating a crowd effect.
        function updateEnemyAI(dt) {
            if (!hero || hero.mode === 'ragdoll') return;

            // Manage active attacker rotation timer
            activeAttackerTimer -= dt;

            // Sort alive enemies by distance to hero for engagement priority
            var alive = [];
            for (var i = 0; i < activeFigs.length; i++) {
                var e = activeFigs[i];
                if (e.mode !== 'ragdoll' && e.hp > 0) {
                    e._dist = Math.abs(e.x - hero.x);
                    e._side = e.x < hero.x ? -1 : 1;
                    alive.push({ idx: i, fig: e });
                }
            }
            alive.sort(function(a, b) { return a.fig._dist - b.fig._dist; });

            // Only ONE enemy actively attacks at a time (boss always can)
            // Rotate which enemy is the active attacker
            if (activeAttackerTimer <= 0 && alive.length > 0) {
                // Pick the nearest non-retreating enemy
                var picked = -1;
                for (var pi = 0; pi < alive.length; pi++) {
                    if (!alive[pi].fig._retreating) {
                        picked = alive[pi].idx;
                        break;
                    }
                }
                if (picked < 0 && alive.length > 0) picked = alive[0].idx;
                activeAttackerIdx = picked;
                activeAttackerTimer = rand(1.0, 2.0);
            }

            // Allow up to 1 melee engager per side (2 during intense sections)
            var meleeSlots = { left: 0, right: 0 };
            var maxMeleePerSide = section === 'breakdown' || section === 'final_chorus' ? 2 : 1;

            for (var ai = 0; ai < alive.length; ai++) {
                var entry = alive[ai];
                var enemy = entry.fig;
                var idx = entry.idx;

                var distToHero = hero.x - enemy.x;
                var absDist = Math.abs(distToHero);
                var faceDir = distToHero > 0 ? 1 : -1;
                enemy.facing = faceDir;

                // Initialize retreat state if needed
                if (enemy._retreating === undefined) enemy._retreating = false;
                if (enemy._retreatTimer === undefined) enemy._retreatTimer = 0;

                var attackRange = enemy.figH * 0.22;
                if (enemy.params.swordLen > 0) attackRange = enemy.figH * 0.3;
                if (enemy._isBoss) attackRange = enemy.figH * 0.3;

                var sideKey = enemy._side < 0 ? 'left' : 'right';
                var canMelee = meleeSlots[sideKey] < maxMeleePerSide || enemy._isBoss;
                var isActiveAttacker = (idx === activeAttackerIdx) || enemy._isBoss;

                // Handle retreat after attacking
                if (enemy._retreating) {
                    enemy._retreatTimer -= dt;
                    var retreatDir = -faceDir; // step away from hero
                    enemy.x += retreatDir * enemy.figH * 1.4 * dt;
                    if (!enemy.attacking) {
                        StickFight.setPose(enemy, 'guard');
                        StickFight.setTarget(enemy, 'lean', -0.1);
                    }
                    if (enemy._retreatTimer <= 0) {
                        enemy._retreating = false;
                    }
                } else if (canMelee && absDist <= attackRange && isActiveAttacker) {
                    // Active attacker in melee range — attack then retreat
                    meleeSlots[sideKey]++;

                    var timer = enemyTimers[idx];
                    if (timer) {
                        timer.cooldown -= dt;
                        if (timer.cooldown <= 0 && !enemy.attacking) {
                            var moves = ['punch_r', 'punch_l', 'kick_high', 'haymaker', 'uppercut'];
                            if (enemy.params.swordLen > 0) {
                                moves.push('slash', 'lunge');
                            }
                            var moveName = pickRandom(moves);
                            StickFight.attack(enemy, moveName, hero);
                            timer.cooldown = rand(1.2, 2.5);
                            if (enemy._isBoss) timer.cooldown = rand(0.5, 1.2);

                            // After attacking, retreat to create space
                            if (!enemy._isBoss) {
                                enemy._retreating = true;
                                enemy._retreatTimer = rand(0.4, 0.8);
                            }
                        } else if (!enemy.attacking) {
                            StickFight.setPose(enemy, 'guard');
                            // Block occasionally when hero is attacking
                            if (hero.attacking && Math.random() < 0.3) {
                                StickFight.setPose(enemy, 'block');
                            }
                        }
                    }
                } else if (canMelee && absDist > attackRange && isActiveAttacker) {
                    // Active attacker approaching cautiously
                    meleeSlots[sideKey]++;
                    var walkSpeed = enemy._isBoss ? enemy.figH * 0.7 : enemy.figH * 0.6; // slow cautious approach
                    enemy.x += faceDir * walkSpeed * dt;
                    if (!enemy.attacking) {
                        StickFight.setPose(enemy, 'guard');
                        StickFight.setTarget(enemy, 'legSpread', 0.25 + Math.sin(performance.now() * 0.004 + idx) * 0.08);
                    }
                } else {
                    // Hanging back — threatening idle at staggered distances
                    var hangDist = attackRange + enemy.figH * 0.5 + ai * enemy.figH * 0.35;
                    var idealX = hero.x + enemy._side * hangDist;
                    var driftSpeed = enemy.figH * 0.4;
                    var dToIdeal = idealX - enemy.x;
                    if (Math.abs(dToIdeal) > enemy.figH * 0.12) {
                        enemy.x += (dToIdeal > 0 ? 1 : -1) * driftSpeed * dt;
                    }
                    if (!enemy.attacking) {
                        // Threatening idle — shift weight, adjust guard
                        var t = performance.now() * 0.001 + idx * 1.7;
                        StickFight.setPose(enemy, 'guard');
                        StickFight.setTarget(enemy, 'bounce', Math.sin(t * 2) * 0.04);
                        StickFight.setTarget(enemy, 'lean', 0.05 + Math.sin(t * 1.3) * 0.08);
                        StickFight.setTarget(enemy, 'legSpread', 0.25 + Math.sin(t * 0.9) * 0.05);
                        // Occasionally feint — briefly shift forward
                        if (Math.sin(t * 3.7) > 0.95) {
                            StickFight.setTarget(enemy, 'lean', 0.25);
                            StickFight.setTarget(enemy, 'armRAngle', -0.2);
                        }
                    }
                }

                // Separation push: don't overlap other enemies
                for (var oi = 0; oi < alive.length; oi++) {
                    if (oi === ai) continue;
                    var other = alive[oi].fig;
                    var sep = enemy.x - other.x;
                    var absSep = Math.abs(sep);
                    var minSep = enemy.figH * 0.3;
                    if (absSep < minSep && absSep > 0.1) {
                        var push = (minSep - absSep) * 0.4;
                        enemy.x += (sep > 0 ? push : -push);
                    }
                }

                // Clamp to arena
                if (enemy.x < arenaLeft) enemy.x = arenaLeft;
                if (enemy.x > arenaRight) enemy.x = arenaRight;
            }
        }

        // ── Find nearest alive enemy ──
        function findNearestEnemy() {
            var nearest = null;
            var nearDist = Infinity;
            for (var i = 0; i < activeFigs.length; i++) {
                var e = activeFigs[i];
                if (e.mode === 'ragdoll' || e.hp <= 0) continue;
                var d = Math.abs(e.x - hero.x);
                if (d < nearDist) {
                    nearDist = d;
                    nearest = e;
                }
            }
            return { fig: nearest, dist: nearDist };
        }

        // ── Hero attack on beat (flashier, higher damage feel) ──
        function heroAttackOnBeat(energy) {
            if (!hero || hero.mode === 'ragdoll') return;
            if (heroAttackCooldown > 0) return;
            if (heroState === 'post_kill' || heroState === 'dodging') return;

            var near = findNearestEnemy();
            if (!near.fig) return;

            hero.facing = near.fig.x > hero.x ? 1 : -1;

            // Match actual MOVES hitRange so attacks connect
            var attackRange = hero.figH * 0.22;
            if (hero.params.swordLen > 0) attackRange = hero.figH * 0.32;

            if (near.dist > attackRange) return;

            // On-beat: pick power moves — higher damage for decisive kills
            var moveName;
            if (energy > 0.7) {
                // Power attack — guaranteed flung death if it kills
                moveName = hero.params.swordLen > 0 ? 'lunge' :
                    pickRandom(['kick_high', 'uppercut', 'overhead']);
                // Boost damage for power attacks — ensure 1-hit kills on low HP enemies
                near.fig.hp = Math.min(near.fig.hp, 30);
            } else if (energy > 0.4) {
                moveName = hero.params.swordLen > 0 ?
                    pickRandom(['slash', 'lunge']) :
                    pickRandom(['punch_r', 'kick_high', 'haymaker', 'uppercut']);
            } else {
                moveName = pickRandom(['punch_r', 'punch_l', 'haymaker']);
            }

            StickFight.attack(hero, moveName, near.fig);
            heroAttackCooldown = 0.2;
            heroState = 'attacking';
            shakeIntensity = Math.max(shakeIntensity, 2 + energy * 3);

            // Check if this will kill — pre-trigger slow-mo on kill
            if (near.fig.hp <= 30 && energy > 0.5) {
                slowMoFactor = 0.3;
                slowMoTimer = 0.3;
            }
        }

        // ── Continuous hero combat (called every frame, not just on beat) ──
        // State machine: seeking -> engaging -> attacking -> post_kill -> seeking
        //                                     dodging (interrupt) ->
        function updateHeroCombat(dt) {
            if (!hero || hero.mode === 'ragdoll') return;
            heroAttackCooldown = Math.max(0, heroAttackCooldown - dt);
            heroStateTimer = Math.max(0, heroStateTimer - dt);

            // Count alive enemies for kill detection
            var aliveCount = 0;
            for (var ci = 0; ci < activeFigs.length; ci++) {
                if (activeFigs[ci].mode !== 'ragdoll' && activeFigs[ci].hp > 0) aliveCount++;
            }

            // Detect a kill just happened (alive count dropped)
            if (aliveCount < heroLastEnemyCount && aliveCount >= 0 && heroState !== 'post_kill') {
                heroState = 'post_kill';
                heroStateTimer = aliveCount === 0 ? 0.5 : 0.3; // longer pause if no enemies left
                lastKillTime = performance.now() / 1000;
            }
            heroLastEnemyCount = aliveCount;

            var near = findNearestEnemy();

            // Check if an enemy is mid-attack on the hero — dodge opportunity
            if (heroState !== 'dodging' && heroState !== 'post_kill' && near.fig) {
                var enemyAttacking = near.fig.attacking && !near.fig.attacking.hit;
                var closeEnough = near.dist < hero.figH * 0.6;
                if (enemyAttacking && closeEnough && Math.random() < 0.4 * dt * 60) {
                    heroState = 'dodging';
                    heroStateTimer = 0.25;
                }
            }

            // State machine
            if (heroState === 'post_kill') {
                // Victory stance — brief dramatic pause
                if (!hero.attacking) {
                    StickFight.setPose(hero, 'guard');
                    StickFight.setTarget(hero, 'lean', -0.1); // slight lean back
                    StickFight.setTarget(hero, 'bounce', -0.08);
                }
                // Face nearest remaining enemy if any
                if (near.fig) {
                    hero.facing = near.fig.x > hero.x ? 1 : -1;
                }
                if (heroStateTimer <= 0) {
                    heroState = near.fig ? 'seeking' : 'seeking';
                }
                return;
            }

            if (heroState === 'dodging') {
                // Step back and block pose
                if (near.fig) {
                    var dodgeDir = near.fig.x > hero.x ? -1 : 1;
                    hero.x += dodgeDir * hero.figH * 1.8 * dt;
                }
                if (!hero.attacking) {
                    StickFight.setPose(hero, 'block');
                    StickFight.setTarget(hero, 'lean', -0.2);
                }
                if (heroStateTimer <= 0) {
                    heroState = 'engaging';
                }
                return;
            }

            if (!near.fig) {
                // No enemies — idle guard
                heroState = 'seeking';
                if (!hero.attacking) {
                    StickFight.setPose(hero, 'guard');
                }
                return;
            }

            // Face nearest enemy
            hero.facing = near.fig.x > hero.x ? 1 : -1;

            // Match actual MOVES hitRange so attacks connect
            var attackRange = hero.figH * 0.22;
            if (hero.params.swordLen > 0) attackRange = hero.figH * 0.32;

            if (near.dist > attackRange) {
                // DASH to the next enemy aggressively
                heroState = 'seeking';
                var dashSpeed = near.dist > hero.figH * 1.5 ? hero.figH * 3.0 : hero.figH * 2.0; // faster dash for far enemies
                hero.x += hero.facing * dashSpeed * dt;
                if (!hero.attacking) {
                    StickFight.setPose(hero, 'guard');
                    StickFight.setTarget(hero, 'lean', 0.3); // lean into the dash
                    StickFight.setTarget(hero, 'legSpread', 0.35);
                }
            } else if (!hero.attacking && heroAttackCooldown <= 0) {
                // In range — attack decisively between beats
                heroState = 'attacking';
                var moveName = pickRandom(['punch_r', 'punch_l', 'haymaker', 'uppercut']);
                if (hero.params.swordLen > 0 && Math.random() < 0.4) {
                    moveName = 'slash';
                }
                StickFight.attack(hero, moveName, near.fig);
                heroAttackCooldown = 0.28;
            } else {
                heroState = 'engaging';
            }
        }

        // ── Signature combo: rapid punch_r, punch_l, kick_high ──
        function triggerSignatureCombo() {
            signatureComboQueue = ['punch_r', 'punch_l', 'kick_high'];
            signatureTimer = 0;
        }

        function updateSignatureCombo(dt) {
            if (signatureComboQueue.length === 0) return;
            signatureTimer -= dt;
            if (signatureTimer > 0) return;

            if (!hero || hero.mode === 'ragdoll') {
                signatureComboQueue = [];
                return;
            }

            // Find target
            var nearest = null;
            var nearDist = Infinity;
            for (var i = 0; i < activeFigs.length; i++) {
                var e = activeFigs[i];
                if (e.mode === 'ragdoll' || e.hp <= 0) continue;
                var d = Math.abs(e.x - hero.x);
                if (d < nearDist) { nearDist = d; nearest = e; }
            }

            if (!nearest) {
                signatureComboQueue = [];
                return;
            }

            hero.facing = nearest.x > hero.x ? 1 : -1;

            if (!hero.attacking) {
                var move = signatureComboQueue.shift();
                StickFight.attack(hero, move, nearest);
                signatureTimer = 0.18;
                heroAttackCooldown = 0.25;

                // Blood on combo hits
                StickFight.spawnBlood(nearest.x, nearest.y - nearest.figH * 0.4,
                    8, hero.facing * 150, -100);
                shakeIntensity = Math.max(shakeIntensity, 4);
            }
        }

        // ── Clean up dead enemies ──
        function cleanupDead() {
            // Move dead from active to dead
            for (var i = activeFigs.length - 1; i >= 0; i--) {
                var fig = activeFigs[i];
                if (fig.hp <= 0 && fig.mode === 'ragdoll') {
                    deadFigs.push(fig);
                    activeFigs.splice(i, 1);
                    enemyTimers.splice(i, 1);
                }
            }

            // Remove settled dead that are old
            for (var j = deadFigs.length - 1; j >= 0; j--) {
                if (deadFigs[j].ragdoll && deadFigs[j].ragdoll.settled) {
                    deadFigs[j]._settleAge = (deadFigs[j]._settleAge || 0) + 1 / 60;
                    if (deadFigs[j]._settleAge > 8) {
                        deadFigs.splice(j, 1);
                    }
                }
            }
        }

        // ── Wave spawning ──
        function updateSpawning(dt) {
            if (waveSpawned >= waveEnemies) return;

            spawnTimer += dt;
            if (spawnTimer >= spawnInterval) {
                spawnTimer = 0;
                spawnEnemy(currentWaveHP, currentWaveSwords, currentWaveFigHMult, false);
                waveSpawned++;
            }
        }

        // ── Section choreography ──
        function onSectionChange(newSection, seqIdx) {
            section = newSection;

            if (section === 'intro') {
                spotlightTarget = 0.5;
                titleTarget = 1;
                introDropDone = false;
                introDropY = -200;
            }

            if (section === 'verse1') {
                titleTarget = 0;
                spotlightTarget = 1;
                startWave(3, 35, false, 1);  // 1-2 hit kills
            }

            if (section === 'chorus1') {
                startWave(6, 45, true, 1);  // fast kills with sword
                // Give hero a sword
                hero.params.swordLen = 0.3;
                hero.targets.swordLen = 0.3;
            }

            if (section === 'bridge') {
                // Brief pause
                spotlightTarget = 0.7;
            }

            if (section === 'verse2') {
                startWave(4, 60, true, 1.15);  // slightly tougher
                spotlightTarget = 1;
            }

            if (section === 'chorus2') {
                startWave(8, 50, true, 1.1);
            }

            if (section === 'breakdown') {
                // Different handling per sub-pattern, done in beat logic
                spotlightTarget = 0.3;
                heroGlowTarget = 0;
            }

            if (section === 'final_chorus') {
                spotlightTarget = 1;
                keyChangeBlend = 0;
                finalChorusBeats = 0;
                // Spawn boss
                if (!boss || boss.hp <= 0) {
                    boss = spawnEnemy(150, true, 1.5, true);
                    bossDefeated = false;
                }
            }

            if (section === 'outro') {
                titleTarget = 0;
                outroStarted = true;
            }
        }

        // ── Per-beat choreography ──
        function onBeat(beat, energy, seqIdx) {
            beatPulse = 1;

            // Breakdown sub-patterns
            if (section === 'breakdown') {
                if (seqIdx === 19) {
                    // Stillness — idle breathing
                    StickFight.setPose(hero, 'idle');
                    heroGlowTarget = 0;
                    spotlightTarget = 0.3;
                } else if (seqIdx === 20) {
                    // New enemies slowly emerge
                    if (beat % 8 === 0 && activeFigs.length < 4) {
                        spawnEnemy(50, true, 1.1, false);
                    }
                    // Heartbeat pulse
                    if (beat % 4 === 0) {
                        screenPulse = 0.8;
                    }
                    heroGlowTarget = 0.3;
                } else if (seqIdx === 21) {
                    // Hero glows, screen rumbles
                    heroGlowTarget = 0.8 + Math.sin(beat * 0.5) * 0.2;
                    if (beat % 2 === 0) {
                        shakeIntensity = Math.max(shakeIntensity, 2 + energy * 3);
                    }
                    spotlightTarget = 0.6;
                } else if (seqIdx === 22) {
                    // ABSOLUTE CARNAGE
                    heroGlowTarget = 1;
                    spotlightTarget = 1;

                    // Spawn enemies constantly — instant kill fodder
                    if (activeFigs.length < 6) {
                        spawnEnemy(20, false, 1, false);
                    }

                    // Attack every beat — override any state pauses
                    heroAttackCooldown = 0;
                    heroState = 'attacking';
                    heroStateTimer = 0;
                    heroAttackOnBeat(1.0);

                    // Flung deaths
                    for (var i = activeFigs.length - 1; i >= 0; i--) {
                        var e = activeFigs[i];
                        if (e.hp <= 0 && e.mode !== 'ragdoll') {
                            StickFight.applyDeath(e, 'flung', groundY);
                            StickFight.spawnBlood(e.x, e.y - e.figH * 0.4,
                                20, hero.facing * 200, -200);
                            // Sometimes detach limbs
                            if (Math.random() < 0.5) {
                                var limbs = ['armR', 'armL', 'legR', 'legL', 'head'];
                                StickFight.detachLimb(e, pickRandom(limbs), groundY);
                            }
                        }
                    }

                    shakeIntensity = Math.max(shakeIntensity, 5 + energy * 5);
                }
                return;
            }

            // Normal sections — on-beat attacks override cooldown for punchy sync
            if (section === 'verse1' || section === 'verse2') {
                if (beat % 2 === 0) {
                    heroAttackCooldown = 0; // Force allow on-beat attack
                    heroAttackOnBeat(energy);
                }
            }

            if (section === 'chorus1' || section === 'chorus2') {
                // Every beat in choruses — decisive kills
                heroAttackCooldown = 0;
                heroState = 'attacking'; // override post_kill pause for relentless choruses
                heroAttackOnBeat(energy);
                // Signature combo more frequently
                if (beat % 12 === 0 && energy > 0.4) {
                    triggerSignatureCombo();
                }
            }

            if (section === 'final_chorus') {
                // Key change blend
                keyChangeBlend = lerpExp(keyChangeBlend, 1, 3, 1 / 60);

                // Track beats in final_chorus for failsafe
                finalChorusBeats++;

                // Every beat — all-out, override any pauses
                heroAttackCooldown = 0;
                heroState = 'attacking';
                heroAttackOnBeat(energy);

                // Signature combo
                if (beat % 12 === 0 && energy > 0.4) {
                    triggerSignatureCombo();
                }

                // Check boss defeat
                if (boss && boss.hp <= 0 && !bossDefeated) {
                    bossDefeated = true;
                    slowMoFactor = 0.2;
                    slowMoTimer = 1.5;
                    StickFight.applyDeath(boss, 'dramatic', groundY);
                    StickFight.spawnBlood(boss.x, boss.y - boss.figH * 0.4,
                        30, hero.facing * 300, -250);
                    shakeIntensity = 10;
                }

                // Failsafe: force-kill boss before outro if still alive
                // final_chorus spans seqIndex 23-24; kill near the end
                if (boss && boss.hp > 0 && !bossDefeated && seqIdx === 24 && finalChorusBeats >= 48) {
                    boss.hp = 0;
                    bossDefeated = true;
                    slowMoFactor = 0.15;
                    slowMoTimer = 1.8;
                    StickFight.applyDeath(boss, 'dramatic', groundY);
                    StickFight.spawnBlood(boss.x, boss.y - boss.figH * 0.4,
                        35, hero.facing * 350, -300);
                    StickFight.detachLimb(boss, 'armR', groundY);
                    shakeIntensity = 15;
                }
            }

            // Death handling — spectacular kills on any dead enemy
            if (section !== 'intro' && section !== 'outro' && section !== 'breakdown') {
                for (var k = 0; k < activeFigs.length; k++) {
                    var fig = activeFigs[k];
                    if (fig.hp <= 0 && fig.mode !== 'ragdoll') {
                        // Most kills are flung for stickdeath feel
                        if (energy > 0.4 || Math.random() < 0.6) {
                            StickFight.applyDeath(fig, 'flung', groundY);
                            // Occasional extra dismemberment
                            if (energy > 0.6 && Math.random() < 0.4) {
                                var limbs = ['armR', 'armL', 'legR', 'legL', 'head'];
                                StickFight.detachLimb(fig, pickRandom(limbs), groundY);
                            }
                        } else {
                            StickFight.applyDeath(fig, 'collapse', groundY);
                        }
                        StickFight.spawnBlood(fig.x, fig.y - fig.figH * 0.4,
                            15, hero.facing * 200, -150);
                        shakeIntensity = Math.max(shakeIntensity, 4 + energy * 5);

                        // Brief slow-mo on kills during high-energy sections
                        if (energy > 0.5 && slowMoTimer <= 0) {
                            slowMoFactor = 0.35;
                            slowMoTimer = 0.25;
                        }
                    }
                }
            }
        }

        // ── Init crowd bumps ──
        function initCrowd() {
            crowdBumps = [];
            var count = Math.floor(W / 20);
            for (var i = 0; i < count; i++) {
                crowdBumps.push({
                    x: i * 20 + rand(-5, 5),
                    y: rand(10, 35),
                    w: rand(8, 14),
                    h: rand(10, 20)
                });
            }
        }

        // ── Init ──
        function init(ctx, width, height, anal) {
            W = width; H = height;
            analysis = anal;
            groundY = H * GROUND_Y_RATIO;

            var figH = H * 0.3;
            var maxArenaHalf = figH * 6;
            var arenaCenter = W * 0.5;
            arenaLeft = Math.max(W * 0.05, arenaCenter - maxArenaHalf);
            arenaRight = Math.min(W * 0.95, arenaCenter + maxArenaHalf);
            hero = StickFight.create({
                x: W * 0.5,
                y: groundY,
                figH: figH,
                facing: 1,
                color: HERO_COLOR,
                poseSpeed: 12,
                hp: 99999
            });
            StickFight.setPose(hero, 'guard');

            activeFigs = [];
            deadFigs = [];
            enemyTimers = [];
            boss = null;
            bossDefeated = false;
            finalChorusBeats = 0;

            lastBeat = -1;
            beatPulse = 0;
            lastSeqIndex = -1;
            section = 'intro';
            shakeIntensity = 0;
            shakeX = 0; shakeY = 0;
            slowMoFactor = 1;
            slowMoTimer = 0;
            heroGlow = 0;
            heroGlowTarget = 0;
            spotlightAlpha = 0;
            spotlightTarget = 0.5;
            titleAlpha = 0;
            titleTarget = 1;
            screenPulse = 0;
            keyChangeBlend = 0;
            introDropDone = false;
            introDropY = -200;
            outroAlpha = 0;
            outroStarted = false;
            signatureComboQueue = [];
            signatureTimer = 0;
            heroAttackCooldown = 0;
            heroState = 'seeking';
            heroStateTimer = 0;
            lastKillTime = 0;
            heroLastEnemyCount = 0;
            activeAttackerIdx = -1;
            activeAttackerTimer = 0;
            waveEnemies = 0;
            waveSpawned = 0;

            initCrowd();
        }

        // ── Resize ──
        function resize(width, height) {
            W = width; H = height;
            groundY = H * GROUND_Y_RATIO;
            var figH = H * 0.3;
            var maxArenaHalf = figH * 6;
            var arenaCenter = W * 0.5;
            arenaLeft = Math.max(W * 0.05, arenaCenter - maxArenaHalf);
            arenaRight = Math.min(W * 0.95, arenaCenter + maxArenaHalf);
            if (hero) { hero.figH = figH; hero.y = groundY; }
            initCrowd();
        }

        // ── Main render ──
        function render(frameData) {
            var ctx = frameData.ctx;
            var dt = frameData.dt || 1 / 60;
            var cursor = frameData.cursor;

            // Apply slow-motion
            if (slowMoTimer > 0) {
                slowMoTimer -= dt;
                if (slowMoTimer <= 0) {
                    slowMoFactor = 1;
                } else {
                    slowMoFactor = lerpExp(slowMoFactor, 1, 0.5, dt);
                }
                dt *= slowMoFactor;
            }

            // Clear
            ctx.fillStyle = BG_COLOR;
            ctx.fillRect(0, 0, W, H);

            if (!cursor) {
                // Idle state
                drawArena(ctx, 0);
                if (hero) {
                    StickFight.updateAll([hero], dt);
                    StickFight.drawAll(ctx, [hero]);
                }
                return;
            }

            var beat = cursor.beat;
            var seqIdx = cursor.seqIndex;
            var energy = analysis ? (analysis.energy[cursor.timelineIndex] || 0) : 0;

            // ── Section transitions ──
            var newSection = mapSection(seqIdx);
            if (seqIdx !== lastSeqIndex) {
                if (newSection !== section) {
                    onSectionChange(newSection, seqIdx);
                }
                lastSeqIndex = seqIdx;
            }

            // ── Beat detection ──
            if (beat !== lastBeat) {
                onBeat(beat, energy, seqIdx);
            }
            lastBeat = beat;

            // ── Decay timers ──
            beatPulse *= Math.exp(-8 * dt);
            shakeIntensity *= Math.exp(-6 * dt);
            screenPulse *= Math.exp(-4 * dt);

            // Lerp targets
            spotlightAlpha = lerpExp(spotlightAlpha, spotlightTarget, 3, dt);
            titleAlpha = lerpExp(titleAlpha, titleTarget, 3, dt);
            heroGlow = lerpExp(heroGlow, heroGlowTarget, 4, dt);
            if (section === 'final_chorus') {
                keyChangeBlend = lerpExp(keyChangeBlend, 1, 2, dt);
            } else {
                keyChangeBlend = lerpExp(keyChangeBlend, 0, 3, dt);
            }

            // Screen shake
            if (shakeIntensity > 0.1) {
                shakeX = (Math.random() - 0.5) * shakeIntensity * 2;
                shakeY = (Math.random() - 0.5) * shakeIntensity * 2;
            } else {
                shakeX = 0; shakeY = 0;
            }

            // ── Intro drop animation ──
            if (section === 'intro' && !introDropDone) {
                var dropProgress = Math.min(1, (cursor.elapsed || 0) / 2);
                introDropY = lerp(-200, 0, dropProgress * dropProgress);
                hero.y = groundY + introDropY;
                if (dropProgress >= 1) {
                    introDropDone = true;
                    hero.y = groundY;
                    shakeIntensity = 5;
                }
            } else if (hero) {
                hero.y = groundY;
            }

            // ── Spawning ──
            updateSpawning(dt);

            // ── Enemy AI ──
            updateEnemyAI(dt);

            // ── Continuous hero combat (movement + between-beat attacks) ──
            if (section !== 'intro' && section !== 'outro') {
                updateHeroCombat(dt);
            } else {
                heroAttackCooldown = Math.max(0, heroAttackCooldown - dt);
            }

            // ── Signature combo ──
            updateSignatureCombo(dt);

            // ── Clamp hero to arena ──
            if (hero) {
                if (hero.x < arenaLeft + hero.figH * 0.3) hero.x = arenaLeft + hero.figH * 0.3;
                if (hero.x > arenaRight - hero.figH * 0.3) hero.x = arenaRight - hero.figH * 0.3;

                // Hero idle bounce when not attacking
                if (!hero.attacking && section !== 'breakdown') {
                    var idleBounce = Math.sin(cursor.elapsed * 3) * 0.03;
                    StickFight.setTarget(hero, 'bounce', idleBounce);
                }
            }

            // ── Update all figures ──
            allFigs = [hero];
            for (var ai = 0; ai < activeFigs.length; ai++) {
                allFigs.push(activeFigs[ai]);
            }
            StickFight.updateAll(allFigs, dt);
            StickFight.updateAll(deadFigs, dt);

            // Gore effects
            StickFight.updateEffects(dt, groundY);

            // Clean up
            cleanupDead();

            // ── Outro fade to black ──
            if (outroStarted) {
                outroAlpha = lerpExp(outroAlpha, 1, 1.5, dt);

                // Boss dramatic death — only if hero actually defeated it
                if (bossDefeated && boss && boss.mode !== 'ragdoll' && boss._dramaticTimer === undefined) {
                    StickFight.applyDeath(boss, 'dramatic', groundY);
                }
            }

            // ── Draw scene ──
            ctx.save();
            ctx.translate(shakeX, shakeY);

            // 1. Arena background
            drawArena(ctx, energy);

            // 2. Dead figures (underneath)
            StickFight.drawAll(ctx, deadFigs);

            // 3. Gore effects (blood, limbs)
            StickFight.drawEffects(ctx);

            // 4. Active enemies
            StickFight.drawAll(ctx, activeFigs);

            // 5. Hero
            StickFight.drawAll(ctx, [hero]);

            // 6. Hero glow overlay
            drawHeroGlow(ctx);

            // 7. Title
            drawTitle(ctx);

            ctx.restore();

            // 8. Outro blackout (outside shake transform)
            if (outroAlpha > 0.01) {
                ctx.save();
                ctx.globalAlpha = outroAlpha;
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, W, H);
                ctx.restore();
            }
        }

        return {
            name: 'System Infection',
            init: init,
            render: render,
            resize: resize
        };
    })();

    // ── Page bootstrap ──
    (function() {
        var canvas = document.getElementById('viz-canvas');
        var overlay = document.getElementById('play-overlay');

        Visualizer.init(canvas);
        Visualizer.setRenderer('system-infection-video');

        function loadAndPlay(json) {
            Visualizer.loadSong(json);
            Visualizer.play();
        }

        function fetchSong() {
            var url = '../audio-tracker/songs/system-infection.json';
            if (window.fetch && location.protocol !== 'file:') {
                return fetch(url).then(function(r) { return r.json(); });
            }
            return new Promise(function(resolve, reject) {
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.onload = function() {
                    if (xhr.status === 200 || xhr.status === 0) {
                        resolve(JSON.parse(xhr.responseText));
                    } else {
                        reject(new Error('XHR failed: ' + xhr.status));
                    }
                };
                xhr.onerror = function() { reject(new Error('XHR error')); };
                xhr.send();
            });
        }

        overlay.addEventListener('click', function() {
            overlay.classList.add('hidden');
            fetchSong().then(loadAndPlay).catch(function(err) {
                console.error('Failed to load song:', err);
                overlay.classList.remove('hidden');
            });
        });

        // Auto-play when embedded (e.g. jukebox iframe with ?autoplay=1)
        if (new URLSearchParams(window.location.search).get('autoplay') === '1') {
            overlay.click();
        }

        canvas.addEventListener('click', function() {
            if (overlay.classList.contains('hidden')) {
                if (Visualizer.isPlaying()) {
                    Visualizer.stop();
                } else {
                    Visualizer.play();
                }
            }
        });
    })();
    </script>
</body>
</html>
