<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rust — Tech Guide</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,500;0,600;0,700;1,400&family=Raleway:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        /* ============================================
           COPPER & VERDIGRIS — RUST TECH GUIDE
           ============================================
           Oxidized metal patina aesthetic adapted
           for a comprehensive Rust language reference.
           Dark bronze backgrounds, copper accents,
           verdigris-tinted code blocks, metallic
           gradients on section headers.
           ============================================ */

        :root {
            /* COPPER TONES */
            --copper-bright: #B87333;
            --copper-polished: #DA8A67;
            --copper-aged: #8B5A2B;
            --copper-burnished: #6D4423;
            --copper-dark: #4A2F1A;

            /* VERDIGRIS PATINA */
            --verdigris-light: #7EC8C8;
            --verdigris: #43B3AE;
            --verdigris-deep: #2D8A85;
            --patina-teal: #3D9A95;
            --patina-blue: #4A9B96;

            /* BRONZE & DARK METALS */
            --bronze-dark: #3D2B1F;
            --bronze-shadow: #2A1D14;
            --antique-bronze: #524336;
            --metal-black: #1C1410;

            /* HIGHLIGHT & ACCENT */
            --copper-highlight: #E6A86E;
            --patina-highlight: #8FD4D0;
            --cream-aged: #F5EDE3;
            --parchment: #FDF6EC;

            /* FONT FAMILIES */
            --font-display: 'Cormorant Garamond', serif;
            --font-body: 'Raleway', sans-serif;
            --font-mono: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', 'Droid Sans Mono', 'Source Code Pro', monospace;

            /* SPACING SCALE */
            --space-1: 4px;
            --space-2: 8px;
            --space-3: 12px;
            --space-4: 16px;
            --space-5: 24px;
            --space-6: 32px;
            --space-7: 48px;
            --space-8: 64px;
            --space-9: 96px;

            /* SEMANTIC COLORS */
            --text-primary: var(--cream-aged);
            --text-secondary: rgba(245, 237, 227, 0.7);
            --text-muted: rgba(245, 237, 227, 0.5);
            --bg-primary: var(--bronze-shadow);
            --bg-secondary: var(--bronze-dark);
            --accent-warm: var(--copper-bright);
            --accent-cool: var(--verdigris);

            /* EFFECTS */
            --shadow-copper: 0 4px 20px rgba(184, 115, 51, 0.3);
            --shadow-patina: 0 4px 20px rgba(67, 179, 174, 0.25);
            --shadow-deep: 0 8px 32px rgba(28, 20, 16, 0.6);
            --glow-copper: 0 0 30px rgba(184, 115, 51, 0.4);
            --glow-verdigris: 0 0 30px rgba(67, 179, 174, 0.3);

            /* METALLIC GRADIENTS */
            --gradient-copper: linear-gradient(135deg, var(--copper-aged), var(--copper-bright), var(--copper-polished), var(--copper-bright), var(--copper-aged));
            --gradient-verdigris: linear-gradient(135deg, var(--verdigris-deep), var(--verdigris), var(--verdigris-light), var(--verdigris), var(--verdigris-deep));
            --gradient-patina-blend: linear-gradient(180deg, var(--copper-aged) 0%, var(--copper-burnished) 30%, var(--verdigris-deep) 60%, var(--verdigris) 100%);
            --gradient-metal-sheen: linear-gradient(110deg, transparent 20%, rgba(255,255,255,0.1) 40%, rgba(255,255,255,0.2) 50%, rgba(255,255,255,0.1) 60%, transparent 80%);

            /* TRANSITIONS */
            --transition-base: 300ms ease;
        }

        /* ============================================
           RESET & BASE
           ============================================ */

        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            font-size: 16px;
            scroll-behavior: smooth;
            scroll-padding-top: 60px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        body {
            font-family: var(--font-body);
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.7;
            color: var(--text-primary);
            background: var(--bg-primary);
            min-height: 100vh;
        }

        /* ============================================
           OXIDATION PATTERN BACKGROUND
           ============================================ */

        .patina-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
            background:
                radial-gradient(ellipse at 10% 20%, rgba(67, 179, 174, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 90% 80%, rgba(67, 179, 174, 0.06) 0%, transparent 40%),
                radial-gradient(ellipse at 50% 50%, rgba(184, 115, 51, 0.05) 0%, transparent 60%),
                radial-gradient(ellipse at 30% 70%, rgba(45, 138, 133, 0.07) 0%, transparent 45%),
                radial-gradient(ellipse at 70% 30%, rgba(143, 212, 208, 0.04) 0%, transparent 35%);
        }

        /* Metal Texture Overlay */
        .metal-texture {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            opacity: 0.03;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
        }

        /* ============================================
           CONTAINER
           ============================================ */

        .container {
            position: relative;
            z-index: 2;
            max-width: 1100px;
            margin: 0 auto;
            padding: 0 var(--space-6);
        }

        /* ============================================
           BACK LINK
           ============================================ */

        .back-link {
            display: inline-block;
            position: relative;
            z-index: 2;
            font-family: var(--font-body);
            font-size: 0.8rem;
            font-weight: 500;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            color: var(--verdigris);
            text-decoration: none;
            padding: var(--space-4) var(--space-6);
            transition: color var(--transition-base);
        }

        .back-link:hover {
            color: var(--copper-polished);
        }

        .back-link::before {
            content: '\2190\00a0';
        }

        /* ============================================
           PAGE HEADER
           ============================================ */

        .page-header {
            position: relative;
            z-index: 2;
            text-align: center;
            padding: var(--space-7) var(--space-6) var(--space-8);
        }

        .page-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 3px;
            background: var(--gradient-patina-blend);
            border-radius: 2px;
        }

        .page-header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--verdigris), var(--copper-bright), var(--verdigris), transparent);
        }

        .header-ornament {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: var(--space-4);
            margin-bottom: var(--space-5);
        }

        .header-ornament .line {
            width: 60px;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--copper-bright));
        }

        .header-ornament .line:last-child {
            background: linear-gradient(90deg, var(--copper-bright), transparent);
        }

        .header-ornament .symbol {
            font-size: 1.5rem;
            background: var(--gradient-copper);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .page-title {
            font-family: var(--font-display);
            font-size: clamp(2.5rem, 7vw, 4.5rem);
            font-weight: 600;
            font-style: italic;
            letter-spacing: 0.05em;
            margin-bottom: var(--space-4);
            background: linear-gradient(135deg, var(--copper-polished), var(--copper-bright), var(--verdigris-light), var(--verdigris), var(--copper-bright));
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 8s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .page-subtitle {
            font-family: var(--font-body);
            font-size: 1.125rem;
            font-weight: 300;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            color: var(--text-secondary);
        }

        /* ============================================
           STICKY JUMP NAVIGATION
           ============================================ */

        .jump-nav {
            position: sticky;
            top: 0;
            z-index: 100;
            display: flex;
            gap: 0;
            padding: 0;
            background: var(--metal-black);
            border-bottom: 2px solid var(--copper-bright);
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            white-space: nowrap;
            box-shadow: 0 4px 20px rgba(28, 20, 16, 0.8);
        }

        .jump-nav a {
            display: inline-block;
            padding: 10px 16px;
            font-family: var(--font-body);
            font-size: 0.72rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
            text-decoration: none;
            transition: color 0.2s, background 0.2s;
            flex-shrink: 0;
            border-right: 1px solid rgba(184, 115, 51, 0.15);
        }

        .jump-nav a:last-child {
            border-right: none;
        }

        .jump-nav a:hover {
            color: var(--copper-highlight);
            background: rgba(184, 115, 51, 0.12);
        }

        /* ============================================
           SECTIONS
           ============================================ */

        .section {
            position: relative;
            z-index: 2;
            padding: var(--space-8) 0;
            border-bottom: 1px solid rgba(184, 115, 51, 0.15);
        }

        .section:last-of-type {
            border-bottom: none;
        }

        .section-header {
            text-align: center;
            margin-bottom: var(--space-7);
        }

        .section-number {
            font-family: var(--font-display);
            font-size: 3rem;
            font-weight: 400;
            background: var(--gradient-verdigris);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            opacity: 0.4;
            margin-bottom: var(--space-2);
        }

        .section-title {
            font-family: var(--font-display);
            font-size: 2.25rem;
            font-weight: 600;
            letter-spacing: 0.08em;
            background: var(--gradient-copper);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: var(--space-3);
        }

        .section-line {
            width: 120px;
            height: 2px;
            margin: 0 auto;
            background: linear-gradient(90deg, transparent, var(--verdigris), var(--copper-bright), var(--verdigris), transparent);
            position: relative;
        }

        .section-line::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            background: var(--copper-bright);
            border-radius: 50%;
            box-shadow: var(--glow-copper);
        }

        .section-description {
            font-size: 1rem;
            color: var(--text-secondary);
            text-align: center;
            max-width: 65ch;
            margin: var(--space-4) auto 0;
            line-height: 1.7;
        }

        /* ============================================
           SUBSECTIONS
           ============================================ */

        .subsection {
            margin-bottom: var(--space-7);
        }

        .subsection:last-child {
            margin-bottom: 0;
        }

        .subsection-title {
            font-family: var(--font-display);
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--copper-polished);
            letter-spacing: 0.04em;
            margin-bottom: var(--space-4);
            padding-bottom: var(--space-2);
            border-bottom: 1px solid rgba(184, 115, 51, 0.2);
        }

        .subsection-description {
            font-size: 0.9375rem;
            color: var(--text-secondary);
            margin-bottom: var(--space-4);
            line-height: 1.7;
            max-width: 70ch;
        }

        /* ============================================
           CODE BLOCKS
           ============================================ */

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
        }

        pre {
            background: var(--metal-black);
            border-left: 3px solid var(--verdigris-deep);
            border-radius: 0 6px 6px 0;
            padding: var(--space-5);
            margin: var(--space-4) 0;
            overflow-x: auto;
            position: relative;
        }

        pre::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, var(--verdigris-deep), var(--copper-aged), transparent);
            border-radius: 0 6px 0 0;
        }

        pre code {
            display: block;
            color: var(--patina-highlight);
            white-space: pre;
            line-height: 1.65;
            font-size: 0.85rem;
        }

        .inline-code, p code, li code, td code {
            background: rgba(28, 20, 16, 0.6);
            color: var(--verdigris-light);
            padding: 2px 7px;
            border-radius: 3px;
            font-size: 0.85em;
            border: 1px solid rgba(67, 179, 174, 0.15);
        }

        /* ============================================
           TABLES
           ============================================ */

        .table-container {
            margin: var(--space-5) 0;
            overflow-x: auto;
            border-radius: 6px;
            box-shadow: var(--shadow-deep);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.875rem;
        }

        thead {
            background: linear-gradient(135deg, var(--copper-dark), var(--copper-burnished));
        }

        thead th {
            font-family: var(--font-body);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            text-align: left;
            padding: var(--space-3) var(--space-4);
            font-size: 0.7rem;
            color: var(--cream-aged);
            border-bottom: 2px solid var(--copper-bright);
        }

        tbody {
            background: rgba(28, 20, 16, 0.4);
        }

        tbody tr {
            border-bottom: 1px solid rgba(184, 115, 51, 0.1);
            transition: background var(--transition-base);
        }

        tbody tr:last-child {
            border-bottom: 2px solid var(--copper-aged);
        }

        tbody tr:hover {
            background: rgba(184, 115, 51, 0.08);
        }

        tbody td {
            padding: var(--space-3) var(--space-4);
            vertical-align: top;
            color: var(--text-secondary);
        }

        tbody td:first-child {
            font-weight: 500;
            color: var(--text-primary);
        }

        /* ============================================
           COMMAND GRID
           ============================================ */

        .command-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: var(--space-4);
            margin: var(--space-5) 0;
        }

        .command-card {
            background: var(--bg-secondary);
            padding: var(--space-4);
            border-left: 3px solid var(--verdigris-deep);
            border-radius: 0 6px 6px 0;
            transition: all var(--transition-base);
            position: relative;
        }

        .command-card::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 1px;
            background: linear-gradient(180deg, var(--copper-aged), transparent);
        }

        .command-card:hover {
            border-left-color: var(--copper-bright);
            box-shadow: var(--shadow-copper);
            transform: translateY(-2px);
        }

        .command-card .command {
            font-family: var(--font-mono);
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--verdigris-light);
            margin-bottom: var(--space-2);
        }

        .command-card .description {
            font-size: 0.8125rem;
            color: var(--text-muted);
            line-height: 1.5;
        }

        /* ============================================
           ALERT BOXES
           ============================================ */

        .alert {
            padding: var(--space-5);
            margin: var(--space-5) 0;
            border-radius: 0 6px 6px 0;
            position: relative;
        }

        .alert::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            border-radius: 0 6px 0 0;
        }

        .alert h4 {
            font-family: var(--font-display);
            font-size: 1.125rem;
            font-weight: 600;
            margin-bottom: var(--space-2);
            letter-spacing: 0.04em;
        }

        .alert p {
            font-size: 0.9rem;
            line-height: 1.7;
        }

        .alert-info {
            background: rgba(67, 179, 174, 0.1);
            border-left: 3px solid var(--verdigris);
        }

        .alert-info::before {
            background: linear-gradient(90deg, var(--verdigris), transparent);
        }

        .alert-info h4 {
            color: var(--verdigris-light);
        }

        .alert-info p {
            color: var(--patina-highlight);
        }

        .alert-warning {
            background: rgba(184, 115, 51, 0.12);
            border-left: 3px solid var(--copper-bright);
        }

        .alert-warning::before {
            background: linear-gradient(90deg, var(--copper-bright), transparent);
        }

        .alert-warning h4 {
            color: var(--copper-highlight);
        }

        .alert-warning p {
            color: var(--copper-polished);
        }

        /* ============================================
           BADGES
           ============================================ */

        .badge {
            display: inline-block;
            font-family: var(--font-body);
            font-size: 0.6875rem;
            font-weight: 600;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            padding: var(--space-1) var(--space-3);
            border-radius: 3px;
            position: relative;
            overflow: hidden;
        }

        .badge::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--gradient-metal-sheen);
            pointer-events: none;
        }

        .badge-copper {
            background: var(--gradient-copper);
            color: var(--bronze-shadow);
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.2), inset 0 -1px 2px rgba(0,0,0,0.2);
        }

        .badge-verdigris {
            background: var(--gradient-verdigris);
            color: var(--bronze-shadow);
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.2), inset 0 -1px 2px rgba(0,0,0,0.2);
        }

        .badge-patina {
            background: var(--gradient-patina-blend);
            color: var(--cream-aged);
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.15), inset 0 -1px 2px rgba(0,0,0,0.2);
        }

        .badge-outline {
            background: transparent;
            color: var(--copper-bright);
            border: 1px solid var(--copper-bright);
            box-shadow: none;
        }

        .badge-outline::after {
            display: none;
        }

        /* ============================================
           CONTENT LISTS
           ============================================ */

        .content-list {
            list-style: none;
            margin: var(--space-4) 0;
        }

        .content-list li {
            padding-left: var(--space-5);
            margin-bottom: var(--space-2);
            position: relative;
            line-height: 1.7;
            color: var(--text-secondary);
        }

        .content-list li::before {
            content: '\2666';
            position: absolute;
            left: 0;
            color: var(--copper-bright);
            font-size: 0.7em;
            top: 0.35em;
        }

        /* ============================================
           COMPARISON BLOCKS
           ============================================ */

        .comparison {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: var(--space-5);
            margin: var(--space-5) 0;
        }

        .comparison-item {
            background: var(--bg-secondary);
            padding: var(--space-5);
            border-radius: 6px;
            border: 1px solid rgba(184, 115, 51, 0.15);
            position: relative;
        }

        .comparison-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--gradient-patina-blend);
            border-radius: 6px 6px 0 0;
        }

        .comparison-item h4 {
            font-family: var(--font-display);
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--copper-polished);
            margin-bottom: var(--space-3);
        }

        .comparison-item p {
            font-size: 0.875rem;
            color: var(--text-secondary);
            line-height: 1.7;
            margin-bottom: var(--space-3);
        }

        /* ============================================
           DIVIDER
           ============================================ */

        .divider {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-5);
            margin: var(--space-7) 0;
        }

        .divider::before,
        .divider::after {
            content: '';
            flex: 1;
            height: 1px;
            max-width: 200px;
        }

        .divider::before {
            background: linear-gradient(90deg, transparent, var(--copper-bright));
        }

        .divider::after {
            background: linear-gradient(90deg, var(--verdigris), transparent);
        }

        .divider-symbol {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--gradient-patina-blend);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow:
                inset 0 -2px 4px rgba(0,0,0,0.3),
                inset 0 2px 4px rgba(255,255,255,0.1),
                0 4px 12px rgba(0,0,0,0.3);
        }

        .divider-symbol span {
            font-size: 0.75rem;
            color: var(--cream-aged);
        }

        /* ============================================
           FOOTER
           ============================================ */

        .site-footer {
            position: relative;
            z-index: 2;
            text-align: center;
            padding: var(--space-7) var(--space-6);
            margin-top: var(--space-8);
        }

        .site-footer::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--copper-bright), var(--verdigris), var(--copper-bright), transparent);
        }

        .site-footer a {
            font-family: var(--font-body);
            font-size: 0.8rem;
            font-weight: 500;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            color: var(--verdigris);
            text-decoration: none;
            transition: color var(--transition-base);
        }

        .site-footer a:hover {
            color: var(--copper-polished);
        }

        .footer-logo {
            font-family: var(--font-display);
            font-size: 1.5rem;
            font-weight: 600;
            font-style: italic;
            margin-bottom: var(--space-4);
            background: linear-gradient(135deg, var(--copper-polished), var(--verdigris-light));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .footer-text {
            font-size: 0.9375rem;
            color: var(--text-secondary);
            margin-bottom: var(--space-3);
        }

        .footer-ornament {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: var(--space-3);
            margin-top: var(--space-5);
        }

        .footer-ornament .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        .footer-ornament .dot:nth-child(1) { background: var(--copper-aged); }
        .footer-ornament .dot:nth-child(2) { background: var(--copper-bright); }
        .footer-ornament .dot:nth-child(3) { background: var(--verdigris-deep); }
        .footer-ornament .dot:nth-child(4) { background: var(--verdigris); }
        .footer-ornament .dot:nth-child(5) { background: var(--verdigris-light); }

        /* ============================================
           RESPONSIVE
           ============================================ */

        @media (max-width: 768px) {
            .page-title {
                font-size: 2.5rem;
            }

            .section-title {
                font-size: 1.75rem;
            }

            .section-number {
                font-size: 2.25rem;
            }

            .subsection-title {
                font-size: 1.25rem;
            }

            .command-grid,
            .comparison {
                grid-template-columns: 1fr;
            }

            table {
                font-size: 0.75rem;
            }

            thead th,
            tbody td {
                padding: var(--space-2) var(--space-3);
            }

            .container {
                padding: 0 var(--space-4);
            }

            pre {
                padding: var(--space-4);
                font-size: 0.8rem;
            }

            .header-ornament .line {
                width: 30px;
            }
        }

        @media (max-width: 480px) {
            .page-title {
                font-size: 2rem;
            }

            .jump-nav a {
                padding: 8px 12px;
                font-size: 0.65rem;
            }
        }
    </style>
</head>
<body>
    <div class="patina-bg"></div>
    <div class="metal-texture"></div>

    <a href="index.html" class="back-link">Tech Guides</a>

    <header class="page-header">
        <div class="header-ornament">
            <span class="line"></span>
            <span class="symbol">&#9670;</span>
            <span class="line"></span>
        </div>
        <h1 class="page-title">Rust</h1>
        <p class="page-subtitle">Systems Programming with Safety Guarantees</p>
    </header>

    <!-- Sticky Jump Nav -->
    <nav class="jump-nav">
        <a href="#quick-ref">Quick Ref</a>
        <a href="#setup">Setup</a>
        <a href="#core-types">Core Types</a>
        <a href="#ownership">Ownership</a>
        <a href="#structs-enums">Structs &amp; Enums</a>
        <a href="#pattern-matching">Pattern Matching</a>
        <a href="#functions">Functions</a>
        <a href="#error-handling">Error Handling</a>
        <a href="#traits-generics">Traits &amp; Generics</a>
        <a href="#async">Async &amp; Concurrency</a>
        <a href="#ecosystem">Cargo &amp; Ecosystem</a>
        <a href="#tips">Tips &amp; Tricks</a>
    </nav>

    <main>

        <!-- ============================================
             SECTION 01: QUICK REFERENCE
             ============================================ -->
        <section id="quick-ref" class="section">
            <div class="container">
                <div class="section-header">
                    <div class="section-number">01</div>
                    <h2 class="section-title">Quick Reference</h2>
                    <div class="section-line"></div>
                    <p class="section-description">Essential Rust commands, syntax patterns, and common types at a glance.</p>
                </div>

                <!-- Common Cargo Commands -->
                <div class="subsection">
                    <h3 class="subsection-title">Common Cargo Commands</h3>

                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Command</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>cargo new project_name</code></td>
                                    <td>Create a new binary project with directory and Git init</td>
                                </tr>
                                <tr>
                                    <td><code>cargo build</code></td>
                                    <td>Compile the current project (debug mode)</td>
                                </tr>
                                <tr>
                                    <td><code>cargo run</code></td>
                                    <td>Build and execute the current project</td>
                                </tr>
                                <tr>
                                    <td><code>cargo test</code></td>
                                    <td>Run all tests (unit, integration, doc tests)</td>
                                </tr>
                                <tr>
                                    <td><code>cargo check</code></td>
                                    <td>Fast syntax and type check without producing a binary</td>
                                </tr>
                                <tr>
                                    <td><code>cargo clippy</code></td>
                                    <td>Run the linter for idiomatic Rust suggestions</td>
                                </tr>
                                <tr>
                                    <td><code>cargo fmt</code></td>
                                    <td>Auto-format code with rustfmt</td>
                                </tr>
                                <tr>
                                    <td><code>cargo doc --open</code></td>
                                    <td>Generate and open API documentation</td>
                                </tr>
                                <tr>
                                    <td><code>cargo add serde</code></td>
                                    <td>Add a crate dependency to Cargo.toml</td>
                                </tr>
                                <tr>
                                    <td><code>rustup update</code></td>
                                    <td>Update Rust toolchain to latest stable</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Quick Syntax Reference -->
                <div class="subsection">
                    <h3 class="subsection-title">Quick Syntax Reference</h3>

                    <pre><code>// Variables
let x = 5;                     // immutable binding
let mut y = 10;                // mutable binding
const MAX: u32 = 100_000;     // compile-time constant

// Functions
fn add(a: i32, b: i32) -> i32 {
    a + b                       // implicit return (no semicolon)
}

// If / Else (it's an expression!)
let status = if score > 90 { "excellent" } else { "good" };

// Loops
loop {                          // infinite loop
    break;                      // exit loop
}

while condition {               // conditional loop
    // ...
}

for item in collection {        // iterator loop
    println!("{item}");
}

for i in 0..10 {                // range loop (0 to 9)
    println!("{i}");
}

// Match (exhaustive pattern matching)
match value {
    1 => println!("one"),
    2 | 3 => println!("two or three"),
    4..=9 => println!("four through nine"),
    _ => println!("something else"),
}</code></pre>
                </div>

                <!-- Common Types Quick Reference -->
                <div class="subsection">
                    <h3 class="subsection-title">Common Types Quick Reference</h3>

                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Type</th>
                                    <th>Description</th>
                                    <th>Example</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>i32</code></td>
                                    <td>32-bit signed integer (default integer type)</td>
                                    <td><code>let x: i32 = -42;</code></td>
                                </tr>
                                <tr>
                                    <td><code>f64</code></td>
                                    <td>64-bit floating point (default float type)</td>
                                    <td><code>let pi: f64 = 3.14159;</code></td>
                                </tr>
                                <tr>
                                    <td><code>bool</code></td>
                                    <td>Boolean value</td>
                                    <td><code>let active: bool = true;</code></td>
                                </tr>
                                <tr>
                                    <td><code>char</code></td>
                                    <td>Unicode scalar value (4 bytes)</td>
                                    <td><code>let c: char = 'R';</code></td>
                                </tr>
                                <tr>
                                    <td><code>String</code></td>
                                    <td>Heap-allocated, growable UTF-8 string</td>
                                    <td><code>let s = String::from("hello");</code></td>
                                </tr>
                                <tr>
                                    <td><code>&amp;str</code></td>
                                    <td>String slice (borrowed reference to UTF-8 data)</td>
                                    <td><code>let s: &amp;str = "hello";</code></td>
                                </tr>
                                <tr>
                                    <td><code>Vec&lt;T&gt;</code></td>
                                    <td>Growable array (heap-allocated)</td>
                                    <td><code>let v: Vec&lt;i32&gt; = vec![1, 2, 3];</code></td>
                                </tr>
                                <tr>
                                    <td><code>Option&lt;T&gt;</code></td>
                                    <td>Optional value: <code>Some(T)</code> or <code>None</code></td>
                                    <td><code>let n: Option&lt;i32&gt; = Some(5);</code></td>
                                </tr>
                                <tr>
                                    <td><code>Result&lt;T, E&gt;</code></td>
                                    <td>Success or error: <code>Ok(T)</code> or <code>Err(E)</code></td>
                                    <td><code>let r: Result&lt;i32, String&gt; = Ok(42);</code></td>
                                </tr>
                                <tr>
                                    <td><code>HashMap&lt;K, V&gt;</code></td>
                                    <td>Hash map (requires <code>use std::collections::HashMap</code>)</td>
                                    <td><code>let mut m = HashMap::new();</code></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Ownership Quick Rules -->
                <div class="subsection">
                    <h3 class="subsection-title">Ownership Quick Rules</h3>

                    <pre><code>// Rule 1: Each value has exactly ONE owner
let s1 = String::from("hello");

// Rule 2: When the owner goes out of scope, the value is dropped
{
    let s = String::from("temporary");
}   // s is dropped here, memory freed

// Rule 3: Ownership can be transferred (moved), not duplicated
let s2 = s1;           // s1 is MOVED to s2
// println!("{s1}");   // ERROR: s1 is no longer valid
println!("{s2}");      // OK: s2 owns the data

// Borrowing lets you use a value without taking ownership
let s3 = String::from("borrowed");
let len = calculate_length(&amp;s3);  // &amp;s3 borrows, s3 still valid
println!("{s3} has length {len}");</code></pre>
                </div>

                <!-- Common Operations -->
                <div class="subsection">
                    <h3 class="subsection-title">Common Operations</h3>

                    <pre><code>// Printing
println!("Hello, world!");            // print with newline
println!("x = {}, y = {}", x, y);    // positional args
println!("x = {x}, y = {y}");        // inline variables (Rust 2021+)
println!("debug: {:?}", value);       // Debug format
println!("pretty: {:#?}", value);     // Pretty Debug format
eprintln!("error: {}", msg);          // print to stderr
let s = format!("name: {}", name);    // format to String

// Vector creation
let v1 = vec![1, 2, 3];              // vec! macro
let v2: Vec&lt;i32&gt; = Vec::new();       // empty vector
let v3 = vec![0; 10];                // 10 zeros

// Error handling shortcuts
let val = result.unwrap();            // panic on Err
let val = result.expect("failed");    // panic with message
let val = result?;                    // propagate error (returns early)
let val = option.unwrap_or(default);  // fallback value
let val = option.unwrap_or_default(); // use Default trait</code></pre>
                </div>

                <div class="alert alert-info">
                    <h4>Rust Edition Note</h4>
                    <p>This guide covers Rust 2021 edition and later. Most syntax is edition-independent, but certain features like <code>let-else</code> and async improvements require 2021+. The 2024 edition (Rust 1.85+) brings further refinements to <code>gen</code> blocks and <code>unsafe</code> ergonomics.</p>
                </div>
            </div>
        </section>

        <!-- ============================================
             SECTION 02: SETUP & INSTALLATION
             ============================================ -->
        <section id="setup" class="section">
            <div class="container">
                <div class="section-header">
                    <div class="section-number">02</div>
                    <h2 class="section-title">Setup &amp; Installation</h2>
                    <div class="section-line"></div>
                    <p class="section-description">Installing Rust via rustup, managing toolchains, configuring your editor, and creating your first project.</p>
                </div>

                <!-- Installing via rustup -->
                <div class="subsection">
                    <h3 class="subsection-title">Installing via Rustup</h3>
                    <p class="subsection-description">Rustup is the official Rust toolchain installer. It manages Rust versions, components, and cross-compilation targets. One command installs everything you need.</p>

                    <pre><code># Install Rust (Linux / macOS / WSL)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Follow the prompts, then reload your shell:
source "$HOME/.cargo/env"

# Verify installation
rustc --version          # e.g. rustc 1.85.0 (4d91de4e4 2025-02-17)
cargo --version          # e.g. cargo 1.85.0 (d73d2caf9 2024-12-31)
rustup --version         # e.g. rustup 1.27.1</code></pre>

                    <div class="alert alert-info">
                        <h4>What Gets Installed</h4>
                        <p><code>rustup</code> installs three key tools: <code>rustc</code> (the compiler), <code>cargo</code> (the build system and package manager), and <code>rustfmt</code> (the code formatter). Everything lives under <code>~/.cargo/</code> and <code>~/.rustup/</code>.</p>
                    </div>
                </div>

                <!-- Toolchain Management -->
                <div class="subsection">
                    <h3 class="subsection-title">Toolchain Management</h3>
                    <p class="subsection-description">Rustup lets you install and switch between stable, beta, and nightly toolchains, and add components like clippy, rust-analyzer, and cross-compilation targets.</p>

                    <div class="command-grid">
                        <div class="command-card">
                            <div class="command">rustup show</div>
                            <div class="description">Display installed toolchains, active toolchain, and host triple</div>
                        </div>
                        <div class="command-card">
                            <div class="command">rustup update</div>
                            <div class="description">Update all installed toolchains to their latest versions</div>
                        </div>
                        <div class="command-card">
                            <div class="command">rustup default nightly</div>
                            <div class="description">Switch default toolchain to nightly (use <code>stable</code> to switch back)</div>
                        </div>
                        <div class="command-card">
                            <div class="command">rustup component add clippy</div>
                            <div class="description">Add the Clippy linter component to your active toolchain</div>
                        </div>
                        <div class="command-card">
                            <div class="command">rustup component add rust-analyzer</div>
                            <div class="description">Add the rust-analyzer language server for IDE support</div>
                        </div>
                        <div class="command-card">
                            <div class="command">rustup target add wasm32-unknown-unknown</div>
                            <div class="description">Add a cross-compilation target (e.g., WebAssembly)</div>
                        </div>
                    </div>

                    <pre><code># Pin a project to a specific toolchain with a rust-toolchain.toml file:
# rust-toolchain.toml
[toolchain]
channel = "1.85.0"
components = ["rustfmt", "clippy", "rust-analyzer"]
targets = ["wasm32-unknown-unknown"]</code></pre>
                </div>

                <!-- Editor Setup -->
                <div class="subsection">
                    <h3 class="subsection-title">Editor Setup</h3>
                    <p class="subsection-description">rust-analyzer is the official language server for Rust. It provides code completion, inline type hints, go-to-definition, refactoring, and real-time error checking.</p>

                    <ul class="content-list">
                        <li><strong>VS Code:</strong> Install the "rust-analyzer" extension (not the deprecated "Rust" extension). It uses the rust-analyzer binary from your toolchain.</li>
                        <li><strong>Neovim:</strong> Use <code>nvim-lspconfig</code> with <code>rust_analyzer</code>. Add <code>rustfmt</code> as the formatter via <code>conform.nvim</code> or <code>null-ls</code>.</li>
                        <li><strong>IntelliJ / CLion:</strong> Install the "Rust" plugin by JetBrains. It bundles its own analysis engine alongside rust-analyzer support.</li>
                        <li><strong>Helix / Zed:</strong> Both have built-in rust-analyzer support out of the box.</li>
                    </ul>

                    <div class="alert alert-warning">
                        <h4>Performance Tip</h4>
                        <p>For large projects, set <code>"rust-analyzer.check.command": "clippy"</code> in your editor settings. This runs clippy instead of <code>cargo check</code> on save, catching more issues. If builds feel slow, add <code>"rust-analyzer.cargo.buildScripts.enable": false</code> temporarily.</p>
                    </div>
                </div>

                <!-- Creating Your First Project -->
                <div class="subsection">
                    <h3 class="subsection-title">Creating Your First Project</h3>

                    <pre><code># Create a new binary project
cargo new my_app            # Creates my_app/ with src/main.rs
cd my_app
cargo run                   # Compiles and runs: "Hello, world!"

# Create a new library project
cargo new my_lib --lib      # Creates my_lib/ with src/lib.rs

# Initialize in an existing directory
mkdir my_project && cd my_project
cargo init                  # Creates Cargo.toml and src/main.rs
cargo init --lib            # Or initialize as a library</code></pre>

                    <p class="subsection-description">After <code>cargo new</code>, your project structure looks like this:</p>

                    <pre><code>my_app/
├── Cargo.toml              # Project manifest (name, version, dependencies)
├── Cargo.lock              # Exact dependency versions (auto-generated)
├── src/
│   └── main.rs             # Entry point: fn main() { }
├── tests/                  # Integration tests (optional)
├── benches/                # Benchmarks (optional)
├── examples/               # Example programs (optional)
└── .gitignore              # Pre-configured for Rust</code></pre>
                </div>

                <!-- Cargo.toml Structure -->
                <div class="subsection">
                    <h3 class="subsection-title">Cargo.toml Structure</h3>
                    <p class="subsection-description">The <code>Cargo.toml</code> manifest file defines your project metadata, dependencies, and build configuration. It uses TOML format.</p>

                    <pre><code>[package]
name = "my_app"
version = "0.1.0"
edition = "2021"             # Rust edition (2015, 2018, 2021, 2024)
authors = ["Your Name &lt;you@example.com&gt;"]
description = "A short description of the project"
license = "MIT OR Apache-2.0"
rust-version = "1.75"        # Minimum supported Rust version (MSRV)

[dependencies]
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1", features = ["full"] }
anyhow = "1.0"

[dev-dependencies]
criterion = { version = "0.5", features = ["html_reports"] }

[build-dependencies]
cc = "1.0"

[[bin]]
name = "my_app"
path = "src/main.rs"

[profile.release]
opt-level = 3                # Maximum optimization
lto = true                   # Link-time optimization
strip = true                 # Strip debug symbols</code></pre>
                </div>

                <!-- Edition Configuration -->
                <div class="subsection">
                    <h3 class="subsection-title">Edition Configuration</h3>
                    <p class="subsection-description">Rust editions let the language evolve without breaking existing code. Each edition is a checkpoint that enables new syntax and behaviors. Code from different editions can interoperate seamlessly.</p>

                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Edition</th>
                                    <th>Released</th>
                                    <th>Key Features</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>2015</code></td>
                                    <td>Rust 1.0</td>
                                    <td>Original edition, explicit <code>extern crate</code>, older module paths</td>
                                </tr>
                                <tr>
                                    <td><code>2018</code></td>
                                    <td>Rust 1.31</td>
                                    <td>Module system overhaul, <code>async</code>/<code>await</code> syntax, NLL borrow checker</td>
                                </tr>
                                <tr>
                                    <td><code>2021</code></td>
                                    <td>Rust 1.56</td>
                                    <td>Disjoint closure captures, <code>IntoIterator</code> for arrays, new prelude additions</td>
                                </tr>
                                <tr>
                                    <td><code>2024</code></td>
                                    <td>Rust 1.85</td>
                                    <td>Refined <code>unsafe</code> rules, <code>gen</code> blocks, <code>impl Trait</code> in <code>let</code>, lifetime capture rules</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <pre><code># Automatically migrate your code to a newer edition:
cargo fix --edition          # Apply automated fixes
# Then update edition = "2024" in Cargo.toml</code></pre>

                    <div class="alert alert-info">
                        <h4>Which Edition to Use</h4>
                        <p>New projects should use <code>edition = "2021"</code> for maximum ecosystem compatibility, or <code>edition = "2024"</code> if you are on Rust 1.85+ and want the latest features. Editions are backward-compatible: a 2024-edition crate can depend on 2015-edition crates with no issues.</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- ============================================
             SECTION 03: CORE TYPES & VARIABLES
             ============================================ -->
        <section id="core-types" class="section">
            <div class="container">
                <div class="section-header">
                    <div class="section-number">03</div>
                    <h2 class="section-title">Core Types &amp; Variables</h2>
                    <div class="section-line"></div>
                    <p class="section-description">Rust's type system is one of its greatest strengths. Every value has a type known at compile time, enabling fearless refactoring and zero-cost abstractions.</p>
                </div>

                <!-- Primitive Integer Types -->
                <div class="subsection">
                    <h3 class="subsection-title">Integer Types</h3>
                    <p class="subsection-description">Rust provides fixed-size signed and unsigned integers. The default integer type (when Rust must infer) is <code>i32</code>.</p>

                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Signed</th>
                                    <th>Unsigned</th>
                                    <th>Size</th>
                                    <th>Range (Signed)</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>i8</code></td>
                                    <td><code>u8</code></td>
                                    <td>1 byte</td>
                                    <td>-128 to 127</td>
                                </tr>
                                <tr>
                                    <td><code>i16</code></td>
                                    <td><code>u16</code></td>
                                    <td>2 bytes</td>
                                    <td>-32,768 to 32,767</td>
                                </tr>
                                <tr>
                                    <td><code>i32</code></td>
                                    <td><code>u32</code></td>
                                    <td>4 bytes</td>
                                    <td>-2.1 billion to 2.1 billion</td>
                                </tr>
                                <tr>
                                    <td><code>i64</code></td>
                                    <td><code>u64</code></td>
                                    <td>8 bytes</td>
                                    <td>-9.2 quintillion to 9.2 quintillion</td>
                                </tr>
                                <tr>
                                    <td><code>i128</code></td>
                                    <td><code>u128</code></td>
                                    <td>16 bytes</td>
                                    <td>-1.7&times;10<sup>38</sup> to 1.7&times;10<sup>38</sup></td>
                                </tr>
                                <tr>
                                    <td><code>isize</code></td>
                                    <td><code>usize</code></td>
                                    <td>pointer-sized</td>
                                    <td>Platform-dependent (32 or 64 bit)</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <pre><code>// Integer literals support various formats
let decimal = 98_222;           // underscores for readability
let hex = 0xff;                 // hexadecimal
let octal = 0o77;               // octal
let binary = 0b1111_0000;       // binary
let byte = b'A';                // byte literal (u8 only)

// Type suffixes
let x = 42u8;                   // explicit u8
let y = 1_000_000i64;           // explicit i64

// usize is used for indexing and collection sizes
let length: usize = vec.len();
let element = &amp;array[index];     // index must be usize</code></pre>

                    <div class="alert alert-warning">
                        <h4>Integer Overflow</h4>
                        <p>In debug mode, Rust panics on integer overflow. In release mode (<code>cargo build --release</code>), overflow wraps silently using two's complement. Use <code>checked_add()</code>, <code>wrapping_add()</code>, <code>saturating_add()</code>, or <code>overflowing_add()</code> for explicit control.</p>
                    </div>
                </div>

                <!-- Floating-Point Types -->
                <div class="subsection">
                    <h3 class="subsection-title">Floating-Point Types</h3>

                    <pre><code>let x = 2.0;                    // f64 (default)
let y: f32 = 3.0;              // f32 (explicit)

// Arithmetic
let sum = 5.0 + 10.0;          // f64
let quotient = 56.7 / 32.2;
let truncated = -5.0_f64 / 3.0; // -1.666...
let remainder = 43.0 % 5.0;    // 3.0

// f64: 64-bit double precision (IEEE 754)
// f32: 32-bit single precision (IEEE 754)
// f64 is default because on modern CPUs it's roughly the same speed as f32</code></pre>
                </div>

                <!-- Bool and Char -->
                <div class="subsection">
                    <h3 class="subsection-title">Bool &amp; Char</h3>

                    <pre><code>// Boolean: one byte, true or false
let t: bool = true;
let f = false;                  // type inferred as bool

// Char: 4 bytes, represents a Unicode Scalar Value
let c = 'z';
let heart = '&#x2764;';
let crab = '&#x1F980;';                  // Ferris!
let unicode = '\u{1F600}';      // Unicode escape

// char can represent any Unicode scalar value (U+0000 to U+D7FF, U+E000 to U+10FFFF)
// This is more than just ASCII — accented letters, CJK, emoji all work</code></pre>
                </div>

                <!-- Type Inference and Annotations -->
                <div class="subsection">
                    <h3 class="subsection-title">Type Inference &amp; Annotations</h3>
                    <p class="subsection-description">Rust has powerful type inference. In most cases you can omit type annotations and the compiler will figure it out from context. When it cannot (or for clarity), add explicit annotations.</p>

                    <pre><code>// Rust infers types from context
let x = 5;                     // inferred as i32
let y = 3.14;                  // inferred as f64
let name = "Ferris";           // inferred as &amp;str
let numbers = vec![1, 2, 3];   // inferred as Vec&lt;i32&gt;

// Sometimes inference needs help
let guess: u32 = "42".parse().expect("Not a number!");
// Without :u32 the compiler can't know which numeric type to parse into

// Turbofish syntax — specify type parameters inline
let parsed = "42".parse::&lt;u32&gt;().unwrap();
let collected: Vec&lt;i32&gt; = (0..10).collect();
// or equivalently:
let collected = (0..10).collect::&lt;Vec&lt;i32&gt;&gt;();</code></pre>
                </div>

                <!-- let, let mut, const, static -->
                <div class="subsection">
                    <h3 class="subsection-title">Bindings: let, let mut, const, static</h3>

                    <pre><code>// let — immutable by default
let x = 5;
// x = 6;                      // ERROR: cannot assign twice to immutable variable

// let mut — mutable binding
let mut y = 5;
y = 6;                          // OK

// const — compile-time constant, must have explicit type
const MAX_POINTS: u32 = 100_000;
const PI: f64 = 3.141_592_653_589_793;
// Constants are inlined at every usage site. No fixed memory address.
// They must be evaluable at compile time (const expressions only).

// static — global variable with a fixed memory address
static LANGUAGE: &amp;str = "Rust";
static mut COUNTER: u32 = 0;   // mutable statics require unsafe to access

// static vs const:
//   const: inlined, no memory address, can be used in patterns
//   static: fixed address, one instance, lives for entire program ('static lifetime)</code></pre>

                    <div class="alert alert-info">
                        <h4>Prefer const Over static</h4>
                        <p>Use <code>const</code> for values that are known at compile time and don't need a fixed address. Use <code>static</code> only when you need a global variable with a stable memory location (e.g., for FFI). Mutable statics (<code>static mut</code>) are unsafe and should be avoided in favor of <code>std::sync::Mutex</code> or atomic types.</p>
                    </div>
                </div>

                <!-- Shadowing -->
                <div class="subsection">
                    <h3 class="subsection-title">Shadowing</h3>
                    <p class="subsection-description">Rust lets you re-declare a variable with <code>let</code>, creating a new binding that shadows the previous one. Unlike mutation, shadowing can change the type.</p>

                    <pre><code>// Shadowing — creating a new binding with the same name
let x = 5;
let x = x + 1;                 // x is now 6 (new binding)
let x = x * 2;                 // x is now 12 (new binding)

// Shadowing can change types — mutation cannot
let spaces = "   ";             // &amp;str
let spaces = spaces.len();      // usize — different type, same name

// With mut, you CANNOT change types:
// let mut spaces = "   ";
// spaces = spaces.len();       // ERROR: expected &amp;str, found usize

// Shadowing is common in transformations:
let input = "42";
let input: u32 = input.parse().unwrap();
// Reusing the name makes it clear this is the "same concept" in a new form

// Shadowing in inner scopes
let x = 5;
{
    let x = x * 2;             // inner x = 10
    println!("{x}");            // prints 10
}
println!("{x}");                // prints 5 (outer x unchanged)</code></pre>
                </div>

                <!-- String vs &str -->
                <div class="subsection">
                    <h3 class="subsection-title">String vs &amp;str</h3>
                    <p class="subsection-description">This distinction is fundamental to Rust. Understanding when to use each is key to productive Rust programming.</p>

                    <div class="comparison">
                        <div class="comparison-item">
                            <h4>String (Owned)</h4>
                            <p>Heap-allocated, growable, owned UTF-8 string. You use this when you need to own or modify string data.</p>
                            <pre><code>let mut s = String::new();
s.push_str("hello");
s.push(' ');
s += "world";

let s = String::from("hello");
let s = "hello".to_string();
let s = format!("{} {}", "hello", "world");</code></pre>
                        </div>
                        <div class="comparison-item">
                            <h4>&amp;str (Borrowed Slice)</h4>
                            <p>An immutable reference to a UTF-8 string. String literals are <code>&amp;str</code>. Use this for read-only access and function parameters.</p>
                            <pre><code>let s: &amp;str = "hello world";
let first_word: &amp;str = &amp;s[0..5];

// Function parameters should prefer &amp;str:
fn greet(name: &amp;str) {
    println!("Hello, {name}!");
}
greet("world");                // &amp;str works
greet(&amp;my_string);             // &amp;String coerces to &amp;str</code></pre>
                        </div>
                    </div>

                    <pre><code>// Conversions between String and &amp;str
let owned: String = "hello".to_string();    // &amp;str -> String
let owned: String = String::from("hello");  // &amp;str -> String
let borrowed: &amp;str = &amp;owned;                 // String -> &amp;str (deref coercion)
let borrowed: &amp;str = owned.as_str();        // String -> &amp;str (explicit)

// Common pattern: accept &amp;str, return String
fn capitalize(s: &amp;str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        None => String::new(),
        Some(c) => c.to_uppercase().to_string() + chars.as_str(),
    }
}</code></pre>

                    <div class="alert alert-info">
                        <h4>Rule of Thumb</h4>
                        <p>Use <code>&amp;str</code> for function parameters (accept the broadest input). Use <code>String</code> when you need ownership, such as storing in a struct, returning from a function, or building strings dynamically. Rust's deref coercion means a <code>&amp;String</code> can be passed anywhere a <code>&amp;str</code> is expected.</p>
                    </div>
                </div>

                <!-- Tuples and Arrays -->
                <div class="subsection">
                    <h3 class="subsection-title">Tuples &amp; Arrays</h3>

                    <pre><code>// Tuples — fixed-size, mixed-type compound values
let tup: (i32, f64, &amp;str) = (500, 6.4, "hello");
let (x, y, z) = tup;           // destructuring
let first = tup.0;             // index access
let second = tup.1;

// Unit tuple — the "void" type in Rust
let unit: () = ();             // functions without a return type return ()

// Arrays — fixed-size, same-type, stack-allocated
let arr = [1, 2, 3, 4, 5];           // [i32; 5]
let arr: [i32; 5] = [1, 2, 3, 4, 5]; // explicit type
let zeros = [0; 10];                  // [0, 0, 0, ...] (10 zeros)

let first = arr[0];            // index access
let len = arr.len();           // 5

// Arrays are fixed-size (known at compile time)
// For dynamic-size collections, use Vec&lt;T&gt;

// Slices — references to a contiguous portion of an array or Vec
let slice: &amp;[i32] = &amp;arr[1..3];  // [2, 3]
let full_slice: &amp;[i32] = &amp;arr;    // entire array as slice

// Slices are very common in function signatures:
fn sum(numbers: &amp;[i32]) -> i32 {
    numbers.iter().sum()
}
sum(&amp;arr);                      // pass array as slice
sum(&amp;vec![1, 2, 3]);           // pass Vec as slice</code></pre>
                </div>

                <!-- Type Casting -->
                <div class="subsection">
                    <h3 class="subsection-title">Type Casting with <code>as</code></h3>
                    <p class="subsection-description">Rust does not implicitly convert between numeric types. Use <code>as</code> for explicit casts, and be aware of potential data loss.</p>

                    <pre><code>// Numeric casts
let x: i32 = 42;
let y: f64 = x as f64;         // i32 -> f64 (safe, no loss)
let z: i64 = x as i64;         // i32 -> i64 (safe, widening)

let a: f64 = 3.99;
let b: i32 = a as i32;         // f64 -> i32 = 3 (truncates, no rounding!)

let big: i32 = 300;
let small: u8 = big as u8;     // 300 overflows u8 -> wraps to 44

let c: u8 = 65;
let ch: char = c as char;      // u8 -> char = 'A'

// For safe conversions, prefer From/Into traits:
let x: i64 = i64::from(42i32);     // guaranteed safe
let x: i64 = 42i32.into();         // same thing via Into

// TryFrom/TryInto for fallible conversions:
use std::convert::TryFrom;
let big: i64 = 1_000_000;
let small: Result&lt;i32, _&gt; = i32::try_from(big);  // Ok(1000000)
let too_big: i64 = 10_000_000_000;
let fail: Result&lt;i32, _&gt; = i32::try_from(too_big); // Err(...)</code></pre>

                    <div class="alert alert-warning">
                        <h4>Beware of as Casts</h4>
                        <p>The <code>as</code> keyword performs C-style casts and can silently truncate or wrap values. Prefer <code>From</code>/<code>Into</code> for safe widening conversions and <code>TryFrom</code>/<code>TryInto</code> for narrowing conversions that might fail. The <code>clippy::cast_possible_truncation</code> lint can help catch risky casts.</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- ============================================
             SECTION 04: OWNERSHIP & BORROWING
             ============================================ -->
        <section id="ownership" class="section">
            <div class="container">
                <div class="section-header">
                    <div class="section-number">04</div>
                    <h2 class="section-title">Ownership &amp; Borrowing</h2>
                    <div class="section-line"></div>
                    <p class="section-description">Rust's ownership system is the foundation of its memory safety guarantees. No garbage collector, no manual free &mdash; the compiler enforces safe memory management at compile time.</p>
                </div>

                <!-- The Three Ownership Rules -->
                <div class="subsection">
                    <h3 class="subsection-title">The Three Ownership Rules</h3>
                    <p class="subsection-description">Every piece of data in Rust has exactly one owner. These three rules govern how memory is managed without a garbage collector.</p>

                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Rule</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Rule 1</strong></td>
                                    <td>Each value in Rust has exactly <strong>one owner</strong> at a time</td>
                                </tr>
                                <tr>
                                    <td><strong>Rule 2</strong></td>
                                    <td>When the owner goes out of scope, the value is <strong>dropped</strong> (memory freed)</td>
                                </tr>
                                <tr>
                                    <td><strong>Rule 3</strong></td>
                                    <td>Ownership can be <strong>transferred</strong> (moved) to another variable or function</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <pre><code>// Rule 1: Each value has one owner
let s1 = String::from("hello");    // s1 owns this String

// Rule 2: Value is dropped when owner goes out of scope
{
    let s = String::from("temporary");
    println!("{s}");
}   // s goes out of scope here, String is dropped, memory freed

// Rule 3: Ownership can be transferred (moved)
let s1 = String::from("hello");
let s2 = s1;                       // ownership MOVES from s1 to s2
// println!("{s1}");               // ERROR: value borrowed after move
println!("{s2}");                   // OK: s2 is the new owner</code></pre>
                </div>

                <!-- Move Semantics -->
                <div class="subsection">
                    <h3 class="subsection-title">Move Semantics</h3>
                    <p class="subsection-description">When you assign a heap-allocated value to another variable or pass it to a function, ownership <strong>moves</strong>. The original variable becomes invalid. This prevents double-free bugs at compile time.</p>

                    <pre><code>// String is heap-allocated, so assignment MOVES
let s1 = String::from("hello");
let s2 = s1;                       // s1's data is moved to s2
// s1 is now invalid — the compiler prevents use-after-move
// println!("{s1}");               // ERROR: borrow of moved value: `s1`

// Moving also happens when passing to functions
fn take_ownership(s: String) {
    println!("I own: {s}");
}   // s is dropped here

let name = String::from("Ferris");
take_ownership(name);
// println!("{name}");             // ERROR: name was moved into the function

// Vec, HashMap, Box, and other heap types also move
let v1 = vec![1, 2, 3];
let v2 = v1;                       // v1 is moved
// println!("{:?}", v1);           // ERROR: value used after move</code></pre>

                    <div class="alert alert-info">
                        <h4>Why i32 Does Not Move</h4>
                        <p>Simple scalar types like <code>i32</code>, <code>f64</code>, <code>bool</code>, and <code>char</code> implement the <code>Copy</code> trait. When you assign a <code>Copy</code> type, the value is duplicated on the stack (a cheap bitwise copy), so the original remains valid. Only heap-allocated types (like <code>String</code>, <code>Vec</code>, <code>Box</code>) actually move.</p>
                    </div>

                    <pre><code>// i32 implements Copy, so assignment copies (not moves)
let x = 42;
let y = x;                         // x is COPIED, not moved
println!("x = {x}, y = {y}");      // both valid!

// bool, char, f64 — all Copy types
let a = true;
let b = a;                         // copy
println!("{a} and {b}");            // both valid

// References (&amp;T) are also Copy — copying a reference is cheap
let s = String::from("hello");
let r1 = &amp;s;
let r2 = r1;                       // copies the reference, not the data
println!("{r1} and {r2}");          // both valid</code></pre>
                </div>

                <!-- Clone vs Copy -->
                <div class="subsection">
                    <h3 class="subsection-title">Clone vs Copy</h3>
                    <p class="subsection-description"><code>Copy</code> is an implicit, cheap bitwise duplication. <code>Clone</code> is an explicit, potentially expensive deep duplication. They serve different purposes.</p>

                    <div class="comparison">
                        <div class="comparison-item">
                            <h4>Copy (Implicit)</h4>
                            <p>Bitwise duplication on the stack. Happens automatically on assignment. Must be cheap and trivial. The type cannot also implement <code>Drop</code>.</p>
                            <pre><code>// Types that implement Copy:
// i8, i16, i32, i64, i128, isize
// u8, u16, u32, u64, u128, usize
// f32, f64
// bool, char
// &amp;T (shared references)
// (A, B) if A and B are Copy
// [T; N] if T is Copy

let x: i32 = 42;
let y = x;     // implicit copy
// both x and y are valid</code></pre>
                        </div>
                        <div class="comparison-item">
                            <h4>Clone (Explicit)</h4>
                            <p>Deep duplication that may allocate memory. Must be called explicitly with <code>.clone()</code>. Can be expensive for large data structures.</p>
                            <pre><code>// Clone when you need a duplicate
// of a non-Copy type
let s1 = String::from("hello");
let s2 = s1.clone();  // explicit deep copy
println!("{s1} and {s2}"); // both valid

let v1 = vec![1, 2, 3];
let v2 = v1.clone();  // clones all elements
println!("{v1:?} and {v2:?}");

// Clone copies the heap data too
// (not just the stack pointer)</code></pre>
                        </div>
                    </div>

                    <pre><code>// Deriving Copy and Clone for your own types
#[derive(Debug, Copy, Clone)]
struct Point {
    x: f64,
    y: f64,
}

let p1 = Point { x: 1.0, y: 2.0 };
let p2 = p1;                       // implicit copy because Point is Copy
println!("{:?} and {:?}", p1, p2);  // both valid

// You can only derive Copy if ALL fields are Copy
// This will NOT compile:
// #[derive(Copy, Clone)]
// struct Name {
//     value: String,   // String is not Copy!
// }

// But you can always derive Clone alone
#[derive(Debug, Clone)]
struct Person {
    name: String,       // String is Clone but not Copy
    age: u32,
}

let p1 = Person { name: "Alice".into(), age: 30 };
let p2 = p1.clone();               // explicit clone required
println!("{:?}", p2);</code></pre>
                </div>

                <!-- Shared References: &T -->
                <div class="subsection">
                    <h3 class="subsection-title">References: &amp;T (Shared / Immutable)</h3>
                    <p class="subsection-description">A shared reference <code>&amp;T</code> lets you read data without taking ownership. Multiple shared references can coexist simultaneously. The data cannot be modified through a shared reference.</p>

                    <pre><code>// Borrow with &amp; to read without taking ownership
let s = String::from("hello");
let len = calculate_length(&amp;s);     // borrow s
println!("{s} has length {len}");    // s is still valid!

fn calculate_length(s: &amp;String) -> usize {
    s.len()
}   // s goes out of scope, but it doesn't own the data, so nothing is dropped

// Multiple shared references are allowed simultaneously
let s = String::from("hello");
let r1 = &amp;s;
let r2 = &amp;s;
let r3 = &amp;s;
println!("{r1}, {r2}, {r3}");       // all valid at the same time

// Shared references are immutable — you cannot modify through them
let s = String::from("hello");
let r = &amp;s;
// r.push_str(" world");           // ERROR: cannot borrow as mutable

// Functions should prefer &amp;str over &amp;String (more general)
fn print_greeting(name: &amp;str) {     // accepts &amp;str and &amp;String
    println!("Hello, {name}!");
}
let owned = String::from("world");
print_greeting(&amp;owned);             // &amp;String coerces to &amp;str
print_greeting("world");            // &amp;str directly</code></pre>
                </div>

                <!-- Mutable References: &mut T -->
                <div class="subsection">
                    <h3 class="subsection-title">References: &amp;mut T (Exclusive / Mutable)</h3>
                    <p class="subsection-description">A mutable reference <code>&amp;mut T</code> lets you modify borrowed data. Only <strong>one</strong> mutable reference to a particular piece of data can exist at a time, preventing data races at compile time.</p>

                    <pre><code>// Mutable borrow with &amp;mut
let mut s = String::from("hello");
change(&amp;mut s);
println!("{s}");                    // prints "hello, world"

fn change(s: &amp;mut String) {
    s.push_str(", world");
}

// Only ONE mutable reference at a time
let mut s = String::from("hello");
let r1 = &amp;mut s;
// let r2 = &amp;mut s;               // ERROR: cannot borrow `s` as mutable more than once
r1.push_str(" world");
println!("{r1}");

// Mutable references in different scopes are fine
let mut s = String::from("hello");
{
    let r1 = &amp;mut s;
    r1.push_str(" world");
}   // r1 goes out of scope here
let r2 = &amp;mut s;                   // OK: r1 is no longer active
r2.push_str("!");
println!("{s}");                    // "hello world!"</code></pre>
                </div>

                <!-- Borrowing Rules -->
                <div class="subsection">
                    <h3 class="subsection-title">Borrowing Rules</h3>
                    <p class="subsection-description">The borrow checker enforces two critical rules that prevent data races at compile time. These rules apply within the <strong>non-lexical lifetime</strong> (NLL) of each reference.</p>

                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Situation</th>
                                    <th>Allowed?</th>
                                    <th>Reason</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Multiple <code>&amp;T</code> at once</td>
                                    <td><span class="badge badge-verdigris">Yes</span></td>
                                    <td>Read-only access is safe to share</td>
                                </tr>
                                <tr>
                                    <td>Single <code>&amp;mut T</code> alone</td>
                                    <td><span class="badge badge-verdigris">Yes</span></td>
                                    <td>Exclusive write access is safe</td>
                                </tr>
                                <tr>
                                    <td><code>&amp;T</code> and <code>&amp;mut T</code> at once</td>
                                    <td><span class="badge badge-copper">No</span></td>
                                    <td>Readers would see inconsistent data</td>
                                </tr>
                                <tr>
                                    <td>Multiple <code>&amp;mut T</code> at once</td>
                                    <td><span class="badge badge-copper">No</span></td>
                                    <td>Concurrent writes cause data races</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <pre><code>// EITHER multiple shared references OR one mutable reference, never both
let mut s = String::from("hello");

// This is fine: multiple shared references
let r1 = &amp;s;
let r2 = &amp;s;
println!("{r1} and {r2}");

// This is fine: one mutable reference (after shared refs are done)
let r3 = &amp;mut s;                   // OK: r1 and r2 are no longer used
r3.push_str(" world");

// NLL (Non-Lexical Lifetimes): references end at their last USE, not scope end
let mut data = vec![1, 2, 3];
let first = &amp;data[0];              // shared borrow starts
println!("first = {first}");        // last use of `first`
// shared borrow ends here (NLL)
data.push(4);                       // mutable borrow is OK now
println!("{data:?}");

// This would NOT compile — shared and mutable borrows overlap
// let mut data = vec![1, 2, 3];
// let first = &amp;data[0];
// data.push(4);                    // ERROR: cannot borrow as mutable
// println!("{first}");             // shared borrow still alive here</code></pre>

                    <div class="alert alert-warning">
                        <h4>The Borrow Checker is Your Friend</h4>
                        <p>When the borrow checker rejects your code, it is preventing a real category of bugs: dangling pointers, data races, and use-after-free. Rather than fighting it, restructure your code: clone to break sharing, use scoped borrows, or refactor to reduce overlapping lifetimes. Over time, you will learn to write code that flows naturally within these rules.</p>
                    </div>
                </div>

                <!-- Dangling References -->
                <div class="subsection">
                    <h3 class="subsection-title">Dangling References</h3>
                    <p class="subsection-description">Rust prevents dangling references at compile time. You can never have a reference that outlives the data it points to.</p>

                    <pre><code>// The compiler prevents dangling references
// This will NOT compile:
// fn dangle() -> &amp;String {
//     let s = String::from("hello");
//     &amp;s                             // ERROR: returns a reference to dropped data
// }   // s is dropped here, reference would be dangling

// Solution: return the owned value instead
fn no_dangle() -> String {
    let s = String::from("hello");
    s                                // ownership is moved out, no dangling reference
}

// Another example of what the compiler catches:
// let reference;
// {
//     let value = 42;
//     reference = &amp;value;           // ERROR: `value` does not live long enough
// }   // value is dropped
// println!("{reference}");          // would be a dangling reference

// The fix: ensure the data lives long enough
let value = 42;
let reference = &amp;value;
println!("{reference}");             // OK: value is still in scope</code></pre>
                </div>

                <!-- Real-World Ownership Patterns -->
                <div class="subsection">
                    <h3 class="subsection-title">Real-World Ownership Patterns</h3>
                    <p class="subsection-description">These common patterns show how ownership works in practice with function parameters, return values, and struct fields.</p>

                    <pre><code>// Pattern 1: Borrow for read-only access (most common)
fn count_words(text: &amp;str) -> usize {
    text.split_whitespace().count()
}
let article = String::from("Rust is great");
let count = count_words(&amp;article);   // borrow — article still valid
println!("{article} has {count} words");

// Pattern 2: Take ownership when you need to store or consume
fn into_uppercase(s: String) -> String {
    s.to_uppercase()                   // consumes s, returns new String
}
let name = String::from("ferris");
let upper = into_uppercase(name);     // name is moved
// println!("{name}");                // ERROR: name was moved
println!("{upper}");                   // "FERRIS"

// Pattern 3: Mutable borrow to modify in place
fn add_greeting(buffer: &amp;mut String, name: &amp;str) {
    buffer.push_str("Hello, ");
    buffer.push_str(name);
    buffer.push('!');
}
let mut msg = String::new();
add_greeting(&amp;mut msg, "Ferris");
println!("{msg}");                     // "Hello, Ferris!"

// Pattern 4: Return a newly created value (caller gets ownership)
fn create_user(name: &amp;str, age: u32) -> String {
    format!("{name} (age {age})")
}
let user = create_user("Alice", 30);  // caller owns the String
println!("{user}");

// Pattern 5: Multiple return values with tuple
fn first_and_last(s: &amp;str) -> (char, char) {
    let first = s.chars().next().unwrap();
    let last = s.chars().last().unwrap();
    (first, last)
}
let (f, l) = first_and_last("Rust");
println!("First: {f}, Last: {l}");</code></pre>

                    <div class="alert alert-info">
                        <h4>Choosing the Right Parameter Type</h4>
                        <p>Use <code>&amp;T</code> when you only need to read. Use <code>&amp;mut T</code> when you need to modify. Take <code>T</code> (owned) when the function needs to store the data or the caller is done with it. For strings specifically, prefer <code>&amp;str</code> over <code>&amp;String</code> as the parameter type because it accepts both <code>&amp;String</code> and <code>&amp;str</code> thanks to deref coercion.</p>
                    </div>
                </div>

                <!-- Lifetimes -->
                <div class="subsection">
                    <h3 class="subsection-title">Lifetimes</h3>
                    <p class="subsection-description">Lifetimes are Rust's way of tracking how long references are valid. Most of the time the compiler infers them automatically, but sometimes you need explicit annotations to tell the compiler how reference lifetimes relate to each other.</p>

                    <pre><code>// Basic lifetime annotation syntax: 'a (tick + name)
// Lifetimes go in angle brackets after the function name

// This function returns a reference — but to which input?
// The lifetime annotation 'a tells the compiler:
// "the returned reference lives as long as both inputs"
fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -> &amp;'a str {
    if x.len() > y.len() { x } else { y }
}

let result;
let string1 = String::from("long string");
{
    let string2 = String::from("xyz");
    result = longest(string1.as_str(), string2.as_str());
    println!("{result}");         // OK: both strings alive here
}
// println!("{result}");          // ERROR if string2 is used as result:
                                  // string2 doesn't live long enough</code></pre>

                    <pre><code>// Lifetime elision rules — when the compiler infers lifetimes for you
//
// Rule 1: Each reference parameter gets its own lifetime
//   fn foo(x: &amp;str, y: &amp;str)  =>  fn foo&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str)
//
// Rule 2: If there's exactly one input lifetime, it's assigned to all outputs
//   fn foo(x: &amp;str) -> &amp;str   =>  fn foo&lt;'a&gt;(x: &amp;'a str) -> &amp;'a str
//
// Rule 3: If one parameter is &amp;self or &amp;mut self, its lifetime is
//         assigned to all output lifetimes
//   fn method(&amp;self, x: &amp;str) -> &amp;str  =>  output gets self's lifetime
//
// If these rules don't fully determine output lifetimes, you must annotate.

// Examples where elision works (no annotations needed):
fn first_word(s: &amp;str) -> &amp;str {                // Rule 1 + Rule 2
    s.split_whitespace().next().unwrap_or("")
}

impl MyStruct {
    fn name(&amp;self) -> &amp;str {                     // Rule 3
        &amp;self.name
    }
}</code></pre>

                    <pre><code>// The 'static lifetime — lives for the entire program duration
let s: &amp;'static str = "I live forever";  // string literals are 'static

// 'static is also used in trait bounds:
// T: 'static means T contains no non-static references
// (it either owns all its data or only has 'static references)
fn print_static(s: &amp;'static str) {
    println!("{s}");
}

// Common misconception: 'static does NOT mean "allocated forever"
// It means "CAN live forever" — the data won't become invalid
// String literals are embedded in the binary, so they're always valid</code></pre>
                </div>

                <!-- Lifetime Annotations in Structs -->
                <div class="subsection">
                    <h3 class="subsection-title">Lifetime Annotations in Structs</h3>
                    <p class="subsection-description">When a struct holds a reference, it needs a lifetime annotation. This tells the compiler that the struct cannot outlive the data it references.</p>

                    <pre><code>// A struct that borrows data — must declare a lifetime
struct Excerpt&lt;'a&gt; {
    text: &amp;'a str,             // borrowed reference to a string slice
}

// The struct cannot outlive the data it references
let novel = String::from("Call me Ishmael. Some years ago...");
let first_sentence;
{
    let excerpt = Excerpt {
        text: novel.split('.').next().unwrap(),
    };
    first_sentence = excerpt.text;  // OK: novel still alive
}
println!("{first_sentence}");       // OK: novel outlives this scope

// impl blocks for structs with lifetimes
impl&lt;'a&gt; Excerpt&lt;'a&gt; {
    // Lifetime elision Rule 3 applies: output gets &amp;self's lifetime
    fn announce(&amp;self, announcement: &amp;str) -> &amp;str {
        println!("Attention: {announcement}");
        self.text
    }
}

// Multiple lifetimes in a struct
struct Split&lt;'a, 'b&gt; {
    left: &amp;'a str,
    right: &amp;'b str,
}

// Common pattern: struct with lifetime + owned data
struct Config&lt;'a&gt; {
    name: String,              // owned — no lifetime needed
    description: &amp;'a str,     // borrowed — needs lifetime
}</code></pre>
                </div>

                <!-- Common Lifetime Patterns -->
                <div class="subsection">
                    <h3 class="subsection-title">Common Lifetime Patterns</h3>

                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Pattern</th>
                                    <th>Signature</th>
                                    <th>Compiler Infers?</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Single input ref, output ref</td>
                                    <td><code>fn f(x: &amp;str) -> &amp;str</code></td>
                                    <td>Yes (Rule 2)</td>
                                </tr>
                                <tr>
                                    <td>Method returning ref to self</td>
                                    <td><code>fn f(&amp;self) -> &amp;Type</code></td>
                                    <td>Yes (Rule 3)</td>
                                </tr>
                                <tr>
                                    <td>Two inputs, one output</td>
                                    <td><code>fn f&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -> &amp;'a str</code></td>
                                    <td>No &mdash; must annotate</td>
                                </tr>
                                <tr>
                                    <td>Struct holding a reference</td>
                                    <td><code>struct S&lt;'a&gt; { field: &amp;'a str }</code></td>
                                    <td>No &mdash; must annotate</td>
                                </tr>
                                <tr>
                                    <td>No references in output</td>
                                    <td><code>fn f(x: &amp;str, y: &amp;str) -> String</code></td>
                                    <td>N/A &mdash; no output lifetime needed</td>
                                </tr>
                                <tr>
                                    <td>Static string return</td>
                                    <td><code>fn f() -> &amp;'static str</code></td>
                                    <td>No &mdash; must write <code>'static</code> explicitly</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <pre><code>// Tip: when you're unsure about lifetimes, try removing the annotations
// and let the compiler tell you if they're needed. If it compiles
// without them, elision is handling it.

// Tip: if lifetime annotations get complex, consider whether you
// should own the data instead of borrowing it:
//   &amp;str -> String
//   &amp;[T] -> Vec&lt;T&gt;
//   &amp;T   -> T or Box&lt;T&gt;
// Owned data has no lifetime constraints.</code></pre>
                </div>

                <!-- Common Borrow Checker Errors -->
                <div class="subsection">
                    <h3 class="subsection-title">Common Borrow Checker Errors</h3>

                    <div class="alert alert-warning">
                        <h4>Borrow Checker Survival Guide</h4>
                        <p>The borrow checker is your ally, not your enemy. Here are the most common errors and how to resolve them:</p>
                    </div>

                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Error</th>
                                    <th>Cause</th>
                                    <th>Fix</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>use of moved value</code></td>
                                    <td>Value was moved to another variable or function</td>
                                    <td>Use <code>.clone()</code>, pass a reference (<code>&amp;val</code>), or restructure to avoid the move</td>
                                </tr>
                                <tr>
                                    <td><code>cannot borrow as mutable</code></td>
                                    <td>Trying to mutate while an immutable reference exists</td>
                                    <td>Ensure immutable borrows are used (and dropped) before mutating; narrow borrow scopes</td>
                                </tr>
                                <tr>
                                    <td><code>cannot borrow as mutable more than once</code></td>
                                    <td>Two <code>&amp;mut</code> references to the same data</td>
                                    <td>Use one <code>&amp;mut</code> at a time; split data into separate fields; use <code>Cell</code>/<code>RefCell</code> for interior mutability</td>
                                </tr>
                                <tr>
                                    <td><code>does not live long enough</code></td>
                                    <td>A reference outlives the data it points to</td>
                                    <td>Extend the data's lifetime (move binding to outer scope) or return an owned value instead</td>
                                </tr>
                                <tr>
                                    <td><code>cannot return reference to local variable</code></td>
                                    <td>Returning <code>&amp;T</code> where <code>T</code> is created inside the function</td>
                                    <td>Return the owned value (<code>T</code> or <code>String</code> instead of <code>&amp;str</code>)</td>
                                </tr>
                                <tr>
                                    <td><code>cannot move out of borrowed content</code></td>
                                    <td>Trying to take ownership of data behind a reference</td>
                                    <td>Use <code>.clone()</code>, <code>.to_owned()</code>, or work with the reference instead</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <pre><code>// Example: iterating and mutating a collection
let mut scores = vec![1, 2, 3, 4, 5];

// WRONG: cannot borrow as mutable while iterating
// for score in &amp;scores {
//     if *score > 3 {
//         scores.push(*score * 2);   // ERROR: mutable borrow during iteration
//     }
// }

// FIX: collect changes first, then apply
let additions: Vec&lt;i32&gt; = scores.iter()
    .filter(|&amp;&amp;s| s > 3)
    .map(|&amp;s| s * 2)
    .collect();
scores.extend(additions);

// Or use retain/drain/indices to modify in place:
scores.retain(|&amp;x| x &lt;= 3);   // remove elements matching predicate</code></pre>
                </div>
            </div>
        </section>

        <!-- ============================================
             SECTION 05: STRUCTS & ENUMS
             ============================================ -->
        <section id="structs-enums" class="section">
            <div class="container">
                <div class="section-header">
                    <div class="section-number">05</div>
                    <h2 class="section-title">Structs &amp; Enums</h2>
                    <div class="section-line"></div>
                    <p class="section-description">Custom data types are the building blocks of Rust programs. Structs group related fields together; enums model values that can be one of several variants.</p>
                </div>

                <!-- Named Structs -->
                <div class="subsection">
                    <h3 class="subsection-title">Named Structs</h3>
                    <p class="subsection-description">A struct groups related data under a single type name. Each field has a name and a type. Struct instances are created by specifying values for every field.</p>

                    <pre><code>// Defining a struct
struct User {
    username: String,
    email: String,
    age: u32,
    active: bool,
}

// Creating an instance — all fields must be specified
let user = User {
    username: String::from("ferris"),
    email: String::from("ferris@rust-lang.org"),
    age: 10,
    active: true,
};

// Accessing fields with dot notation
println!("Name: {}", user.username);
println!("Active: {}", user.active);

// Mutable struct — all fields become mutable (Rust has no per-field mutability)
let mut user = User {
    username: String::from("ferris"),
    email: String::from("ferris@rust-lang.org"),
    age: 10,
    active: true,
};
user.email = String::from("new@example.com");
user.age += 1;</code></pre>

                    <pre><code>// Field init shorthand — when variable names match field names
fn build_user(username: String, email: String) -> User {
    User {
        username,                   // shorthand for username: username
        email,                      // shorthand for email: email
        age: 0,
        active: true,
    }
}

// Struct update syntax — create from another instance
let user2 = User {
    email: String::from("other@example.com"),
    ..user                          // remaining fields from `user`
};
// WARNING: String fields are moved from `user`, so user.username is invalid
// but user.age and user.active are still valid (they implement Copy)</code></pre>
                </div>

                <!-- Tuple Structs and Unit Structs -->
                <div class="subsection">
                    <h3 class="subsection-title">Tuple Structs &amp; Unit Structs</h3>
                    <p class="subsection-description">Tuple structs have unnamed fields accessed by index. Unit structs have no fields at all. Both are useful for creating distinct types.</p>

                    <pre><code>// Tuple structs — named tuples for type distinction
struct Color(u8, u8, u8);
struct Point3D(f64, f64, f64);

let red = Color(255, 0, 0);
let origin = Point3D(0.0, 0.0, 0.0);

// Access by index
println!("R: {}, G: {}, B: {}", red.0, red.1, red.2);
println!("x: {}", origin.0);

// Destructuring
let Color(r, g, b) = red;
println!("Red channel: {r}");

// Newtype pattern — single-field tuple struct for type safety
struct Meters(f64);
struct Seconds(f64);

fn speed(distance: Meters, time: Seconds) -> f64 {
    distance.0 / time.0
}
// speed(Seconds(5.0), Meters(100.0));  // ERROR: wrong argument order!
let s = speed(Meters(100.0), Seconds(5.0));  // correct

// Unit structs — no fields, zero size
struct Marker;
struct AlwaysEqual;

let _m = Marker;
let _e = AlwaysEqual;
// Useful for implementing traits on types that don't hold data</code></pre>
                </div>

                <!-- impl Blocks -->
                <div class="subsection">
                    <h3 class="subsection-title">impl Blocks: Methods &amp; Associated Functions</h3>
                    <p class="subsection-description">Use <code>impl</code> blocks to define methods (called on instances) and associated functions (called on the type itself). The first parameter of a method determines how it accesses the instance.</p>

                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>First Parameter</th>
                                    <th>Access Level</th>
                                    <th>Call Syntax</th>
                                    <th>Use When</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>&amp;self</code></td>
                                    <td>Immutable borrow</td>
                                    <td><code>instance.method()</code></td>
                                    <td>Reading fields, computing values</td>
                                </tr>
                                <tr>
                                    <td><code>&amp;mut self</code></td>
                                    <td>Mutable borrow</td>
                                    <td><code>instance.method()</code></td>
                                    <td>Modifying the instance</td>
                                </tr>
                                <tr>
                                    <td><code>self</code></td>
                                    <td>Takes ownership</td>
                                    <td><code>instance.method()</code></td>
                                    <td>Consuming / transforming the instance</td>
                                </tr>
                                <tr>
                                    <td><em>no self</em></td>
                                    <td>Associated function</td>
                                    <td><code>Type::function()</code></td>
                                    <td>Constructors, utility functions</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <pre><code>struct Rectangle {
    width: f64,
    height: f64,
}

impl Rectangle {
    // Associated function (constructor) — no self parameter
    fn new(width: f64, height: f64) -> Self {
        Self { width, height }       // Self refers to the impl type (Rectangle)
    }

    fn square(size: f64) -> Self {
        Self { width: size, height: size }
    }

    // Method with &amp;self — immutable borrow (read-only)
    fn area(&amp;self) -> f64 {
        self.width * self.height
    }

    fn perimeter(&amp;self) -> f64 {
        2.0 * (self.width + self.height)
    }

    fn is_square(&amp;self) -> bool {
        (self.width - self.height).abs() &lt; f64::EPSILON
    }

    // Method with &amp;mut self — mutable borrow (modifies in place)
    fn scale(&amp;mut self, factor: f64) {
        self.width *= factor;
        self.height *= factor;
    }

    // Method with self — takes ownership (consumes the instance)
    fn into_square(self) -> Rectangle {
        let side = self.width.max(self.height);
        Rectangle { width: side, height: side }
    }
}

// Usage
let r = Rectangle::new(10.0, 5.0);   // associated function with ::
println!("Area: {}", r.area());        // method with .
println!("Square? {}", r.is_square());

let mut r = Rectangle::new(3.0, 4.0);
r.scale(2.0);                          // mutates r
println!("Scaled area: {}", r.area()); // 48.0

let sq = r.into_square();              // consumes r
// println!("{}", r.area());           // ERROR: r was moved
println!("Square area: {}", sq.area());</code></pre>
                </div>

                <!-- Deriving Traits -->
                <div class="subsection">
                    <h3 class="subsection-title">Deriving Traits</h3>
                    <p class="subsection-description">The <code>#[derive]</code> attribute auto-generates trait implementations. This is the idiomatic way to add common functionality to your types.</p>

                    <pre><code>// Common derivable traits
#[derive(Debug, Clone, PartialEq)]
struct Product {
    name: String,
    price: f64,
    in_stock: bool,
}

let p1 = Product {
    name: "Widget".into(),
    price: 9.99,
    in_stock: true,
};

// Debug — enables {:?} formatting
println!("{:?}", p1);
// Product { name: "Widget", price: 9.99, in_stock: true }

println!("{:#?}", p1);               // pretty-printed Debug output

// Clone — explicit deep copy
let p2 = p1.clone();

// PartialEq — enables == and != comparisons
assert_eq!(p1, p2);                   // true — same values</code></pre>

                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Derive</th>
                                    <th>Provides</th>
                                    <th>Requirement</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>Debug</code></td>
                                    <td><code>{:?}</code> formatting</td>
                                    <td>All fields implement <code>Debug</code></td>
                                </tr>
                                <tr>
                                    <td><code>Clone</code></td>
                                    <td><code>.clone()</code> method</td>
                                    <td>All fields implement <code>Clone</code></td>
                                </tr>
                                <tr>
                                    <td><code>Copy</code></td>
                                    <td>Implicit bitwise copy</td>
                                    <td>All fields implement <code>Copy</code> + <code>Clone</code></td>
                                </tr>
                                <tr>
                                    <td><code>PartialEq</code></td>
                                    <td><code>==</code> and <code>!=</code></td>
                                    <td>All fields implement <code>PartialEq</code></td>
                                </tr>
                                <tr>
                                    <td><code>Eq</code></td>
                                    <td>Full equality (reflexive)</td>
                                    <td>Requires <code>PartialEq</code>, no <code>f32</code>/<code>f64</code> fields</td>
                                </tr>
                                <tr>
                                    <td><code>PartialOrd</code></td>
                                    <td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td>
                                    <td>All fields implement <code>PartialOrd</code></td>
                                </tr>
                                <tr>
                                    <td><code>Ord</code></td>
                                    <td>Total ordering</td>
                                    <td>Requires <code>Eq</code> + <code>PartialOrd</code></td>
                                </tr>
                                <tr>
                                    <td><code>Hash</code></td>
                                    <td>Hashing for <code>HashMap</code> keys</td>
                                    <td>All fields implement <code>Hash</code></td>
                                </tr>
                                <tr>
                                    <td><code>Default</code></td>
                                    <td><code>Type::default()</code></td>
                                    <td>All fields implement <code>Default</code></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <pre><code>// Multiple derives on one type
#[derive(Debug, Clone, PartialEq, Eq, Hash, Default)]
struct Config {
    name: String,
    retries: u32,
    verbose: bool,
}

let default_config = Config::default();
// Config { name: "", retries: 0, verbose: false }

// Derive Copy for stack-only types
#[derive(Debug, Copy, Clone, PartialEq)]
struct Vector2D {
    x: f64,
    y: f64,
}

let v1 = Vector2D { x: 1.0, y: 2.0 };
let v2 = v1;                         // implicit copy, v1 still valid
println!("{:?} and {:?}", v1, v2);</code></pre>
                </div>

                <!-- Enums with Data -->
                <div class="subsection">
                    <h3 class="subsection-title">Enums with Data</h3>
                    <p class="subsection-description">Rust enums are far more powerful than C-style enums. Each variant can hold different types and amounts of data, making them ideal for modeling states and alternatives.</p>

                    <pre><code>// Basic enum (C-style, no data)
enum Direction {
    North,
    South,
    East,
    West,
}

let heading = Direction::North;

// Enum variants can hold data of different types
enum Message {
    Quit,                              // no data (unit variant)
    Echo(String),                      // single value (tuple variant)
    Move { x: i32, y: i32 },          // named fields (struct variant)
    Color(u8, u8, u8),                 // multiple values (tuple variant)
}

let msg1 = Message::Quit;
let msg2 = Message::Echo(String::from("hello"));
let msg3 = Message::Move { x: 10, y: 20 };
let msg4 = Message::Color(255, 128, 0);

// Enums can have methods too
impl Message {
    fn is_quit(&amp;self) -> bool {
        matches!(self, Message::Quit)
    }

    fn process(&amp;self) {
        match self {
            Message::Quit => println!("Quitting"),
            Message::Echo(text) => println!("Echo: {text}"),
            Message::Move { x, y } => println!("Moving to ({x}, {y})"),
            Message::Color(r, g, b) => println!("Color: rgb({r}, {g}, {b})"),
        }
    }
}

msg3.process();                        // "Moving to (10, 20)"</code></pre>

                    <pre><code>// Real-world enum: modeling API responses
#[derive(Debug)]
enum ApiResponse {
    Success { data: String, status: u16 },
    Error { message: String, code: u16 },
    Loading,
    NotFound,
}

// Real-world enum: representing different shapes
#[derive(Debug)]
enum Shape {
    Circle(f64),                       // radius
    Rectangle(f64, f64),               // width, height
    Triangle { base: f64, height: f64 },
}

impl Shape {
    fn area(&amp;self) -> f64 {
        match self {
            Shape::Circle(r) => std::f64::consts::PI * r * r,
            Shape::Rectangle(w, h) => w * h,
            Shape::Triangle { base, height } => 0.5 * base * height,
        }
    }
}

let shapes = vec![
    Shape::Circle(5.0),
    Shape::Rectangle(4.0, 6.0),
    Shape::Triangle { base: 3.0, height: 8.0 },
];

for shape in &amp;shapes {
    println!("{:?} has area {:.2}", shape, shape.area());
}</code></pre>
                </div>

                <!-- Option<T> in Depth -->
                <div class="subsection">
                    <h3 class="subsection-title">Option&lt;T&gt; in Depth</h3>
                    <p class="subsection-description"><code>Option&lt;T&gt;</code> replaces null in Rust. A value is either <code>Some(T)</code> (present) or <code>None</code> (absent). The compiler forces you to handle both cases, eliminating null pointer exceptions.</p>

                    <pre><code>// Option is defined as:
// enum Option&lt;T&gt; {
//     Some(T),
//     None,
// }

// Creating Options
let some_number: Option&lt;i32&gt; = Some(42);
let no_number: Option&lt;i32&gt; = None;

// From a function that might not find a result
fn find_user(id: u32) -> Option&lt;String&gt; {
    if id == 1 {
        Some(String::from("Alice"))
    } else {
        None
    }
}

let user = find_user(1);              // Some("Alice")
let missing = find_user(99);          // None</code></pre>

                    <pre><code>// Common Option methods

let x: Option&lt;i32&gt; = Some(42);
let y: Option&lt;i32&gt; = None;

// unwrap — get the value or panic
let val = x.unwrap();                 // 42
// y.unwrap();                        // PANIC: called unwrap on None

// expect — unwrap with a custom panic message
let val = x.expect("should have a value");

// unwrap_or — provide a default
let val = y.unwrap_or(0);             // 0

// unwrap_or_else — compute default lazily
let val = y.unwrap_or_else(|| compute_default());

// unwrap_or_default — use the Default trait
let val: i32 = y.unwrap_or_default(); // 0 (i32's default)

// is_some / is_none — check without consuming
if x.is_some() {
    println!("x has a value");
}

// map — transform the inner value
let doubled = x.map(|v| v * 2);       // Some(84)
let doubled = y.map(|v| v * 2);       // None (no-op)

// and_then (flatmap) — chain operations that return Option
fn parse_and_double(s: &amp;str) -> Option&lt;i32&gt; {
    s.parse::&lt;i32&gt;().ok()              // Result -> Option
        .and_then(|n| n.checked_mul(2)) // returns Option
}
let result = parse_and_double("21");   // Some(42)
let result = parse_and_double("abc");  // None

// filter — keep Some only if predicate matches
let even = Some(4).filter(|x| x % 2 == 0);  // Some(4)
let odd = Some(3).filter(|x| x % 2 == 0);   // None

// zip — combine two Options
let name = Some("Alice");
let age = Some(30);
let pair = name.zip(age);             // Some(("Alice", 30))</code></pre>

                    <div class="alert alert-warning">
                        <h4>Avoid Excessive unwrap()</h4>
                        <p>Using <code>unwrap()</code> in production code is a code smell because it panics on <code>None</code>. Prefer <code>match</code>, <code>if let</code>, <code>unwrap_or()</code>, or the <code>?</code> operator. Reserve <code>unwrap()</code> for tests, examples, and cases where you can prove the value is always <code>Some</code>.</p>
                    </div>
                </div>

                <!-- Result<T, E> in Depth -->
                <div class="subsection">
                    <h3 class="subsection-title">Result&lt;T, E&gt; in Depth</h3>
                    <p class="subsection-description"><code>Result&lt;T, E&gt;</code> is Rust's primary error-handling type. Operations that can fail return <code>Ok(T)</code> on success or <code>Err(E)</code> on failure. The compiler ensures you handle both cases.</p>

                    <pre><code>// Result is defined as:
// enum Result&lt;T, E&gt; {
//     Ok(T),
//     Err(E),
// }

// Functions that can fail return Result
use std::fs;
use std::num::ParseIntError;

fn parse_number(s: &amp;str) -> Result&lt;i32, ParseIntError&gt; {
    s.parse::&lt;i32&gt;()
}

let good = parse_number("42");        // Ok(42)
let bad = parse_number("abc");        // Err(ParseIntError { ... })</code></pre>

                    <pre><code>// Common Result methods

let ok: Result&lt;i32, String&gt; = Ok(42);
let err: Result&lt;i32, String&gt; = Err("oops".into());

// unwrap / expect — get value or panic on Err
let val = ok.unwrap();                 // 42
let val = ok.expect("parsing failed"); // 42
// err.unwrap();                       // PANIC with error message

// unwrap_or / unwrap_or_else / unwrap_or_default
let val = err.unwrap_or(0);            // 0
let val = err.unwrap_or_else(|e| {
    eprintln!("Error: {e}");
    -1
});

// is_ok / is_err
if ok.is_ok() {
    println!("Success!");
}

// map — transform the success value
let doubled = ok.map(|v| v * 2);       // Ok(84)

// map_err — transform the error value
let mapped = err.map_err(|e| format!("Error: {e}"));

// and_then — chain fallible operations
fn double_parse(s: &amp;str) -> Result&lt;i32, ParseIntError&gt; {
    s.parse::&lt;i32&gt;()
        .and_then(|n| Ok(n * 2))
}

// ok() — convert Result to Option (discards error)
let opt: Option&lt;i32&gt; = ok.ok();        // Some(42)

// The ? operator — propagate errors (most idiomatic)
fn read_and_parse(path: &amp;str) -> Result&lt;i32, Box&lt;dyn std::error::Error&gt;&gt; {
    let contents = fs::read_to_string(path)?;  // returns Err early if fails
    let number = contents.trim().parse::&lt;i32&gt;()?; // same here
    Ok(number * 2)
}
// The ? operator:
//   1. If Ok(v), unwraps v and continues
//   2. If Err(e), converts e (via From) and returns early</code></pre>

                    <div class="alert alert-info">
                        <h4>Result vs Option</h4>
                        <p><code>Option&lt;T&gt;</code> means "value or nothing" &mdash; use it when absence is not an error (e.g., finding an element). <code>Result&lt;T, E&gt;</code> means "value or error" &mdash; use it when failure needs an explanation (e.g., file I/O, parsing). Convert between them with <code>.ok()</code> (Result to Option) and <code>.ok_or(err)</code> (Option to Result).</p>
                    </div>
                </div>

                <!-- When to Use Struct vs Enum -->
                <div class="subsection">
                    <h3 class="subsection-title">When to Use Struct vs Enum</h3>

                    <div class="comparison">
                        <div class="comparison-item">
                            <h4>Use a Struct When</h4>
                            <p>You have a single concept with multiple attributes that are ALL present at once.</p>
                            <pre><code>// All users have all fields
struct User {
    name: String,
    email: String,
    age: u32,
}

// A point always has x and y
struct Point {
    x: f64,
    y: f64,
}

// Configuration with many settings
struct Config {
    host: String,
    port: u16,
    debug: bool,
}</code></pre>
                        </div>
                        <div class="comparison-item">
                            <h4>Use an Enum When</h4>
                            <p>A value can be ONE of several alternatives, each potentially with different data.</p>
                            <pre><code>// A shape is one specific kind
enum Shape {
    Circle(f64),
    Rectangle(f64, f64),
}

// A message is one specific type
enum Command {
    Start,
    Stop,
    Resize { w: u32, h: u32 },
}

// State machines
enum ConnectionState {
    Disconnected,
    Connecting(String),
    Connected { addr: String },
}</code></pre>
                        </div>
                    </div>

                    <pre><code>// Often you combine both: structs inside enums
#[derive(Debug)]
struct Credentials {
    username: String,
    token: String,
}

#[derive(Debug)]
enum AuthState {
    Anonymous,
    Authenticated(Credentials),       // enum variant holds a struct
    Banned { reason: String, until: String },
}

let state = AuthState::Authenticated(Credentials {
    username: "ferris".into(),
    token: "abc123".into(),
});
println!("{state:?}");</code></pre>
                </div>

                <!-- When to Use Option vs Result -->
                <div class="subsection">
                    <h3 class="subsection-title">When to Use Option vs Result</h3>

                    <div class="comparison">
                        <div class="comparison-item">
                            <h4>Use Option&lt;T&gt; When</h4>
                            <p>A value might or might not exist, and the absence is <em>not</em> an error. The caller does not need to know <em>why</em> the value is missing.</p>
                            <pre><code>// Finding an element
fn find_user(id: u64) -> Option&lt;User&gt;

// Getting the first element
vec.first()  // -> Option&lt;&amp;T&gt;

// Parsing optional fields
struct Config {
    name: String,
    description: Option&lt;String&gt;,
    max_retries: Option&lt;u32&gt;,
}

// HashMap lookup
map.get(&amp;key)  // -> Option&lt;&amp;V&gt;</code></pre>
                        </div>
                        <div class="comparison-item">
                            <h4>Use Result&lt;T, E&gt; When</h4>
                            <p>An operation can fail, and the caller needs to know <em>what went wrong</em>. The error carries diagnostic information.</p>
                            <pre><code>// File operations
fn read_file(p: &amp;str) -> Result&lt;String, io::Error&gt;

// Parsing with error info
fn parse_config(s: &amp;str) -> Result&lt;Config, ParseError&gt;

// Network requests
fn fetch(url: &amp;str) -> Result&lt;Response, HttpError&gt;

// Validation
fn validate(input: &amp;str) -> Result&lt;(), ValidationError&gt;

// Database queries
fn query(sql: &amp;str) -> Result&lt;Rows, DbError&gt;</code></pre>
                        </div>
                    </div>

                    <div class="alert alert-info">
                        <h4>Rule of Thumb</h4>
                        <p>If "nothing found" is a normal, expected outcome, use <code>Option</code>. If "nothing found" means something went wrong and the caller might need to react differently based on the cause, use <code>Result</code>. When in doubt, prefer <code>Result</code> &mdash; you can always convert it to an <code>Option</code> with <code>.ok()</code>, but going the other way loses error information.</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- ============================================
             SECTION 06: PATTERN MATCHING
             ============================================ -->
        <section id="pattern-matching" class="section">
            <div class="container">
                <div class="section-header">
                    <div class="section-number">06</div>
                    <h2 class="section-title">Pattern Matching</h2>
                    <div class="section-line"></div>
                    <p class="section-description">Pattern matching is one of Rust's most expressive features. The <code>match</code> expression, <code>if let</code>, <code>while let</code>, and destructuring let you elegantly handle complex data shapes.</p>
                </div>

                <!-- match Expressions -->
                <div class="subsection">
                    <h3 class="subsection-title">match Expressions</h3>
                    <p class="subsection-description">A <code>match</code> expression compares a value against a series of patterns and executes the code for the first matching pattern. Matching is <strong>exhaustive</strong> &mdash; the compiler ensures every possible value is covered.</p>

                    <pre><code>// Basic match — must cover ALL possible values
let number = 3;
let text = match number {
    1 => "one",
    2 => "two",
    3 => "three",
    _ => "other",                     // _ is the catch-all (wildcard) pattern
};
println!("{text}");                    // "three"

// match is an expression — it returns a value
let x = 42;
let description = match x {
    0 => "zero",
    1..=9 => "single digit",          // inclusive range pattern
    10..=99 => "double digit",
    100..=999 => "triple digit",
    _ => "big number",
};

// Multiple patterns with |  (or-pattern)
let c = 'y';
let is_yes = match c {
    'y' | 'Y' => true,
    'n' | 'N' => false,
    _ => {
        println!("Unknown response");
        false
    }
};

// match with blocks (use {} for multi-line arms)
let temp = 35;
match temp {
    t if t &lt; 0 => {
        println!("Freezing: {t}C");
        println!("Stay inside!");
    }
    0..=15 => println!("Cold"),
    16..=25 => println!("Comfortable"),
    26..=35 => println!("Warm"),
    _ => println!("Hot!"),
}</code></pre>

                    <div class="alert alert-info">
                        <h4>Exhaustive Matching</h4>
                        <p>The Rust compiler requires that <code>match</code> handles every possible value. For integers and strings, use <code>_</code> as a catch-all. For enums, you must match every variant (or use <code>_</code>). This prevents bugs from unhandled cases and ensures your code adapts when new variants are added.</p>
                    </div>
                </div>

                <!-- Matching on Enums -->
                <div class="subsection">
                    <h3 class="subsection-title">Matching on Enums</h3>
                    <p class="subsection-description">Pattern matching truly shines with enums, especially <code>Option</code> and <code>Result</code>. You can destructure variant data directly in the match arms.</p>

                    <pre><code>// Matching Option&lt;T&gt;
fn describe_number(n: Option&lt;i32&gt;) -> String {
    match n {
        Some(0) => "zero".to_string(),
        Some(x) if x &gt; 0 => format!("positive: {x}"),
        Some(x) => format!("negative: {x}"),
        None => "no number".to_string(),
    }
}

println!("{}", describe_number(Some(42)));   // "positive: 42"
println!("{}", describe_number(None));        // "no number"

// Matching Result&lt;T, E&gt;
use std::num::ParseIntError;

fn try_parse(input: &amp;str) -> String {
    let result: Result&lt;i32, ParseIntError&gt; = input.parse();
    match result {
        Ok(n) if n &gt;= 0 => format!("Got positive number: {n}"),
        Ok(n) => format!("Got negative number: {n}"),
        Err(e) => format!("Parse error: {e}"),
    }
}

// Matching custom enums
#[derive(Debug)]
enum Command {
    Quit,
    Echo(String),
    Move { x: i32, y: i32 },
    Color(u8, u8, u8),
}

fn execute(cmd: &amp;Command) {
    match cmd {
        Command::Quit => {
            println!("Exiting");
            std::process::exit(0);
        }
        Command::Echo(msg) => println!("{msg}"),
        Command::Move { x, y } => println!("Moving to ({x}, {y})"),
        Command::Color(r, g, b) => println!("Setting color #{r:02x}{g:02x}{b:02x}"),
    }
}

let cmd = Command::Color(255, 128, 0);
execute(&amp;cmd);                         // "Setting color #ff8000"</code></pre>
                </div>

                <!-- Destructuring in match -->
                <div class="subsection">
                    <h3 class="subsection-title">Destructuring Structs &amp; Tuples in match</h3>
                    <p class="subsection-description">Patterns can destructure structs, tuples, and nested types, letting you extract exactly the data you need.</p>

                    <pre><code>// Destructuring tuples
let point = (3, -5);
match point {
    (0, 0) => println!("Origin"),
    (x, 0) => println!("On x-axis at {x}"),
    (0, y) => println!("On y-axis at {y}"),
    (x, y) if x &gt; 0 &amp;&amp; y &gt; 0 => println!("Quadrant I: ({x}, {y})"),
    (x, y) => println!("Somewhere else: ({x}, {y})"),
}

// Destructuring structs
struct Point {
    x: i32,
    y: i32,
}

let p = Point { x: 0, y: 7 };
match p {
    Point { x: 0, y } => println!("On y-axis at y={y}"),
    Point { x, y: 0 } => println!("On x-axis at x={x}"),
    Point { x, y } => println!("Point at ({x}, {y})"),
}

// Ignoring fields with ..
struct Config {
    host: String,
    port: u16,
    debug: bool,
    retries: u32,
}

let cfg = Config {
    host: "localhost".into(),
    port: 8080,
    debug: true,
    retries: 3,
};

match &amp;cfg {
    Config { debug: true, .. } => println!("Debug mode enabled"),
    Config { port: 443, .. } => println!("HTTPS detected"),
    _ => println!("Standard config"),
}

// Nested destructuring
enum Wrapper {
    Pair(Point, Point),
    Single(Point),
    Empty,
}

let w = Wrapper::Pair(
    Point { x: 1, y: 2 },
    Point { x: 3, y: 4 },
);

match w {
    Wrapper::Pair(Point { x: x1, y: y1 }, Point { x: x2, y: y2 }) => {
        println!("Pair: ({x1},{y1}) to ({x2},{y2})");
    }
    Wrapper::Single(Point { x, y }) => println!("Single: ({x},{y})"),
    Wrapper::Empty => println!("Empty"),
}</code></pre>
                </div>

                <!-- if let -->
                <div class="subsection">
                    <h3 class="subsection-title">if let</h3>
                    <p class="subsection-description">When you only care about <strong>one</strong> pattern and want to ignore the rest, <code>if let</code> is a concise alternative to a full <code>match</code> with a wildcard arm.</p>

                    <pre><code>// Instead of this verbose match:
let config_max: Option&lt;u32&gt; = Some(3);
match config_max {
    Some(max) => println!("Max is {max}"),
    _ => (),                          // do nothing for None
}

// Use if let:
if let Some(max) = config_max {
    println!("Max is {max}");
}

// if let with else
let value: Option&lt;i32&gt; = None;
if let Some(v) = value {
    println!("Found: {v}");
} else {
    println!("Nothing found");
}

// if let with enum variants
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(String),                   // state name
}

let coin = Coin::Quarter("Alaska".to_string());
if let Coin::Quarter(state) = &amp;coin {
    println!("State quarter from {state}");
}

// Chaining if let for multiple checks
fn process_input(input: &amp;str) {
    if let Ok(number) = input.parse::&lt;i32&gt;() {
        println!("Got number: {number}");
    } else if let Ok(float) = input.parse::&lt;f64&gt;() {
        println!("Got float: {float}");
    } else {
        println!("Got text: {input}");
    }
}

process_input("42");                   // "Got number: 42"
process_input("3.14");                 // "Got float: 3.14"
process_input("hello");               // "Got text: hello"</code></pre>
                </div>

                <!-- while let -->
                <div class="subsection">
                    <h3 class="subsection-title">while let</h3>
                    <p class="subsection-description"><code>while let</code> loops as long as a pattern matches. It is commonly used to consume iterators or drain collections that return <code>Option</code>.</p>

                    <pre><code>// Pop elements from a vector until empty
let mut stack = vec![1, 2, 3, 4, 5];

while let Some(top) = stack.pop() {
    println!("Popped: {top}");
}
// Output: 5, 4, 3, 2, 1 (pop removes from the end)
println!("Stack is now empty: {:?}", stack);

// Iterating over an iterator
let names = vec!["Alice", "Bob", "Charlie"];
let mut iter = names.iter();

while let Some(name) = iter.next() {
    println!("Hello, {name}!");
}
// Note: a `for` loop is usually preferred for iterators,
// but while let is useful when you need custom control flow

// Processing a channel receiver
// use std::sync::mpsc;
// let (tx, rx) = mpsc::channel();
// while let Ok(message) = rx.recv() {
//     println!("Got: {message}");
// }

// Parsing optional nested structures
fn next_token(input: &amp;mut &amp;str) -> Option&lt;char&gt; {
    let ch = input.chars().next()?;
    *input = &amp;input[ch.len_utf8()..];
    Some(ch)
}

let mut text = "Rust";
while let Some(ch) = next_token(&amp;mut text) {
    print!("{ch} ");
}
// Output: R u s t</code></pre>
                </div>

                <!-- let-else -->
                <div class="subsection">
                    <h3 class="subsection-title">let-else (Early Returns)</h3>
                    <p class="subsection-description">The <code>let-else</code> syntax (stabilized in Rust 1.65) lets you bind a pattern or diverge (return, break, continue, panic). It is the idiomatic way to do "unwrap or return early."</p>

                    <pre><code>// let-else: bind the pattern or execute the else block (which must diverge)
fn get_username(id: Option&lt;u32&gt;) -> String {
    let Some(id) = id else {
        return "anonymous".to_string();  // must return, break, continue, or panic
    };
    format!("user_{id}")
}

println!("{}", get_username(Some(42)));    // "user_42"
println!("{}", get_username(None));         // "anonymous"

// let-else with Result
fn parse_port(s: &amp;str) -> Result&lt;u16, String&gt; {
    let Ok(port) = s.parse::&lt;u16&gt;() else {
        return Err(format!("Invalid port: {s}"));
    };

    if port == 0 {
        return Err("Port 0 is reserved".into());
    }

    Ok(port)
}

// let-else is great for reducing nesting
// Before (nested):
fn process_v1(input: &amp;str) -> Option&lt;i32&gt; {
    if let Ok(n) = input.parse::&lt;i32&gt;() {
        if n &gt; 0 {
            Some(n * 2)
        } else {
            None
        }
    } else {
        None
    }
}

// After (flat with let-else):
fn process_v2(input: &amp;str) -> Option&lt;i32&gt; {
    let Ok(n) = input.parse::&lt;i32&gt;() else {
        return None;
    };
    if n &lt;= 0 {
        return None;
    }
    Some(n * 2)
}

// let-else with complex patterns
struct Request {
    method: String,
    path: String,
    body: Option&lt;String&gt;,
}

fn handle_post(req: &amp;Request) -> Result&lt;String, String&gt; {
    let Some(body) = &amp;req.body else {
        return Err("POST requires a body".into());
    };
    Ok(format!("Processing: {body}"))
}</code></pre>

                    <div class="alert alert-info">
                        <h4>let-else vs if let</h4>
                        <p><code>if let</code> is for "do something when a pattern matches." <code>let-else</code> is for "bind the pattern or bail out." Use <code>let-else</code> when the non-matching case should exit the function, continue a loop, or otherwise diverge. It keeps the "happy path" un-nested and easy to follow.</p>
                    </div>
                </div>

                <!-- Match Guards -->
                <div class="subsection">
                    <h3 class="subsection-title">Match Guards</h3>
                    <p class="subsection-description">A match guard is an additional <code>if</code> condition on a match arm. It refines the pattern with arbitrary boolean expressions.</p>

                    <pre><code>// Match guard with if
let num = Some(4);
match num {
    Some(x) if x &lt; 0 => println!("Negative: {x}"),
    Some(x) if x == 0 => println!("Zero"),
    Some(x) if x % 2 == 0 => println!("Positive even: {x}"),
    Some(x) => println!("Positive odd: {x}"),
    None => println!("Nothing"),
}
// Output: "Positive even: 4"

// Guards can reference outer variables
let target = 5;
let numbers = [1, 5, 10, 15, 5, 20];

for &amp;n in &amp;numbers {
    match n {
        x if x == target => println!("Found target: {x}"),
        x if x &gt; target => println!("{x} is above target"),
        x => println!("{x} is below target"),
    }
}

// Guards with or-patterns — the guard applies to ALL alternatives
let x = 4;
let y = false;
match x {
    4 | 5 | 6 if y => println!("4, 5, or 6 and y is true"),
    4 | 5 | 6 => println!("4, 5, or 6 (y is false)"),
    _ => println!("something else"),
}
// Output: "4, 5, or 6 (y is false)"
// Note: the guard `if y` applies to ALL of 4 | 5 | 6, not just 6

// Guards in real-world code
enum Temperature {
    Celsius(f64),
    Fahrenheit(f64),
}

fn describe_temp(temp: &amp;Temperature) -> &amp;str {
    match temp {
        Temperature::Celsius(c) if *c &lt; 0.0 => "freezing",
        Temperature::Celsius(c) if *c &gt; 35.0 => "hot",
        Temperature::Celsius(_) => "moderate",
        Temperature::Fahrenheit(f) if *f &lt; 32.0 => "freezing",
        Temperature::Fahrenheit(f) if *f &gt; 95.0 => "hot",
        Temperature::Fahrenheit(_) => "moderate",
    }
}</code></pre>
                </div>

                <!-- @ Bindings -->
                <div class="subsection">
                    <h3 class="subsection-title">@ Bindings</h3>
                    <p class="subsection-description">The <code>@</code> operator lets you bind a value to a name <strong>while simultaneously</strong> testing it against a pattern. This is useful when you need both the whole value and a pattern constraint.</p>

                    <pre><code>// Bind a name to a matched range value
let age = 25;
match age {
    child @ 0..=12 => println!("Child, age {child}"),
    teen @ 13..=17 => println!("Teenager, age {teen}"),
    adult @ 18..=64 => println!("Adult, age {adult}"),
    senior @ 65.. => println!("Senior, age {senior}"),
    // Note: patterns starting from a value use 65.. (no end bound)
}
// Output: "Adult, age 25"

// @ with enum variants
enum Message {
    Hello { id: i32 },
    Goodbye,
}

let msg = Message::Hello { id: 5 };
match msg {
    Message::Hello { id: id_val @ 3..=7 } => {
        println!("Found id in range 3-7: {id_val}");
    }
    Message::Hello { id } => {
        println!("Other id: {id}");
    }
    Message::Goodbye => println!("Goodbye"),
}
// Output: "Found id in range 3-7: 5"

// @ with Option to capture the whole Some value
let numbers = vec![Some(3), None, Some(7), Some(1), None];

for num in &amp;numbers {
    match num {
        some_val @ Some(x) if *x &gt; 5 => {
            println!("Large value: {some_val:?} contains {x}");
        }
        Some(x) => println!("Small value: {x}"),
        None => println!("Missing"),
    }
}

// @ in nested patterns
struct Point { x: i32, y: i32 }

let p = Point { x: 5, y: 10 };
match p {
    Point { x: x_val @ 0..=10, y: y_val @ 0..=10 } => {
        println!("In bounds: ({x_val}, {y_val})");
    }
    Point { x, y } => println!("Out of bounds: ({x}, {y})"),
}</code></pre>
                </div>

                <!-- Nested Patterns and Or-Patterns -->
                <div class="subsection">
                    <h3 class="subsection-title">Nested Patterns &amp; Or-Patterns</h3>
                    <p class="subsection-description">Patterns can be nested to match complex data structures, and or-patterns (<code>|</code>) let you match multiple alternatives in a single arm.</p>

                    <pre><code>// Or-patterns with | — match any of several values
let status_code = 404;
let category = match status_code {
    200 | 201 | 202 => "Success",
    301 | 302 => "Redirect",
    400 | 401 | 403 => "Client Error",
    404 => "Not Found",
    500 | 502 | 503 => "Server Error",
    _ => "Unknown",
};

// Or-patterns with enum variants
#[derive(Debug)]
enum Animal {
    Dog(String),
    Cat(String),
    Fish,
    Bird(String),
}

let pet = Animal::Cat("Whiskers".to_string());
match &amp;pet {
    Animal::Dog(name) | Animal::Cat(name) => {
        println!("Furry pet named {name}");
    }
    Animal::Bird(name) => println!("Feathered friend: {name}"),
    Animal::Fish => println!("Swimming silently"),
}

// Nested patterns — matching deep structures
#[derive(Debug)]
enum Expr {
    Num(f64),
    Add(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Mul(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Neg(Box&lt;Expr&gt;),
}

fn simplify(expr: &amp;Expr) -> String {
    match expr {
        Expr::Num(n) => format!("{n}"),
        Expr::Add(box Expr::Num(0.0), b) |
        Expr::Add(b, box Expr::Num(0.0)) => {
            // Note: box patterns are nightly-only as of early 2025
            // In stable Rust, use nested match or if let instead
            simplify(b)
        }
        Expr::Add(a, b) => format!("({} + {})", simplify(a), simplify(b)),
        Expr::Mul(a, b) => format!("({} * {})", simplify(a), simplify(b)),
        Expr::Neg(inner) => format!("-{}", simplify(inner)),
    }
}

// Stable alternative for nested matching — multi-level match
fn eval(expr: &amp;Expr) -> f64 {
    match expr {
        Expr::Num(n) => *n,
        Expr::Add(a, b) => eval(a) + eval(b),
        Expr::Mul(a, b) => eval(a) * eval(b),
        Expr::Neg(inner) => -eval(inner),
    }
}</code></pre>

                    <pre><code>// Complex real-world pattern matching example
#[derive(Debug)]
struct HttpRequest {
    method: String,
    path: String,
    auth: Option&lt;String&gt;,
}

fn route(req: &amp;HttpRequest) -> String {
    match (req.method.as_str(), req.path.as_str(), &amp;req.auth) {
        ("GET", "/", _) => "Home page".into(),
        ("GET", "/api/users", Some(_)) => "User list (authenticated)".into(),
        ("GET", "/api/users", None) => "401 Unauthorized".into(),
        ("POST", "/api/users", Some(token)) => {
            format!("Creating user with token: {token}")
        }
        ("DELETE", path, Some(_)) if path.starts_with("/api/") => {
            format!("Deleting resource: {path}")
        }
        (method, path, _) => format!("404: {method} {path} not found"),
    }
}

let req = HttpRequest {
    method: "GET".into(),
    path: "/api/users".into(),
    auth: Some("bearer_token_123".into()),
};
println!("{}", route(&amp;req));
// "User list (authenticated)"</code></pre>

                    <div class="alert alert-warning">
                        <h4>Pattern Matching Best Practices</h4>
                        <p>Prefer <code>match</code> when you have 3+ cases or need exhaustive coverage. Use <code>if let</code> for single-pattern checks. Use <code>let-else</code> for "unwrap or bail." Use <code>matches!(value, pattern)</code> when you only need a boolean. Avoid deeply nested patterns &mdash; extract helper functions for readability.</p>
                    </div>
                </div>

                <!-- Pattern Matching in Function Parameters -->
                <div class="subsection">
                    <h3 class="subsection-title">Patterns in Function Parameters</h3>
                    <p class="subsection-description">Function parameters are patterns too. You can destructure tuples, structs, and other types directly in the function signature and in closures.</p>

                    <pre><code>// Destructure a tuple in parameters
fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!("({x}, {y})");
}

let point = (3, 5);
print_coordinates(&amp;point);

// Destructure a struct in parameters
fn distance_from_origin(&amp;Point { x, y }: &amp;Point) -> f64 {
    ((x * x + y * y) as f64).sqrt()
}

// Destructure in closures
let points = vec![(1, 2), (3, 4), (5, 6)];
let sum: i32 = points.iter()
    .map(|(x, y)| x + y)       // destructure tuple in closure parameter
    .sum();
println!("Sum: {sum}");

// Ignoring values with _
fn log_result(result: Result&lt;i32, String&gt;) {
    match result {
        Ok(_) => println!("success (value ignored)"),
        Err(_) => println!("failure (error ignored)"),
    }
}

// Ignoring parts of a struct with ..
let Point { x, .. } = Point { x: 10, y: 20 };

// Ignoring remaining tuple elements
let (first, ..) = (1, 2, 3, 4, 5);
let (.., last) = (1, 2, 3, 4, 5);
let (first, .., last) = (1, 2, 3, 4, 5);
println!("{first} ... {last}");         // 1 ... 5</code></pre>
                </div>

                <!-- Matching on References -->
                <div class="subsection">
                    <h3 class="subsection-title">Matching on References</h3>
                    <p class="subsection-description">When matching on references, you need to understand how patterns interact with <code>&amp;</code> and the <code>ref</code> keyword to control whether you dereference or borrow.</p>

                    <pre><code>// Matching a reference — use &amp; in the pattern to "look through" it
let reference = &amp;4;

match reference {
    &amp;val => println!("Got a value: {val}"),   // val is i32, not &amp;i32
}

// Equivalent using dereferencing
match *reference {
    val => println!("Got a value: {val}"),
}

// The ref keyword — create a reference in a pattern binding
let value = 5;

match value {
    ref r => println!("Got a reference: {r}"),  // r is &amp;i32
}
// ref is rarely needed in modern Rust because match ergonomics handle it

// Match ergonomics (Rust 2018+) — auto-referencing in patterns
let opt: &amp;Option&lt;String&gt; = &amp;Some(String::from("hello"));

// Before match ergonomics, you had to write:
// match opt { &amp;Some(ref s) => ..., &amp;None => ... }

// Now you can write (compiler auto-inserts &amp; and ref):
match opt {
    Some(s) => println!("{s}"),              // s is &amp;String (auto-borrowed)
    None => println!("nothing"),
}

// Matching in for loops (iterating over references)
let names = vec!["Alice", "Bob", "Charlie"];

for name in &amp;names {
    // name is &amp;&amp;str here; patterns handle it naturally
    match name {
        &amp;"Alice" => println!("Found Alice!"),
        other => println!("Hello, {other}"),
    }
}

// Common pattern: matching Option&lt;&amp;T&gt; vs &amp;Option&lt;T&gt;
let v = vec![1, 2, 3];
match v.first() {                            // returns Option&lt;&amp;i32&gt;
    Some(&amp;1) => println!("starts with one"),
    Some(n) => println!("starts with {n}"),  // n is &amp;i32
    None => println!("empty"),
}</code></pre>

                    <div class="alert alert-info">
                        <h4>Pattern Matching Cheat Sheet</h4>
                        <p>Use <code>match</code> when you need exhaustive handling of all cases. Use <code>if let</code> when you care about one case. Use <code>let-else</code> when you want to early-return on a mismatch. Use <code>while let</code> to loop until a pattern stops matching. In modern Rust, match ergonomics handle most reference situations automatically &mdash; start simple and only add <code>&amp;</code> or <code>ref</code> if the compiler asks for it.</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- ============================================
             SECTION 07: FUNCTIONS & CLOSURES
             ============================================ -->
        <section id="functions" class="section">
            <div class="container">
                <div class="section-header">
                    <div class="section-number">07</div>
                    <h2 class="section-title">Functions &amp; Closures</h2>
                    <div class="section-line"></div>
                    <p class="section-description">Functions are the primary unit of code reuse in Rust. Closures add anonymous, environment-capturing function expressions. Together with iterators, they form the backbone of idiomatic Rust.</p>
                </div>

                <!-- Function Syntax -->
                <div class="subsection">
                    <h3 class="subsection-title">Function Syntax</h3>
                    <p class="subsection-description">Functions are declared with <code>fn</code>. Every parameter must have an explicit type annotation. The return type follows <code>-&gt;</code>. Rust is expression-based: the last expression in a function body (without a trailing semicolon) is the return value.</p>

                    <pre><code>// Basic function with parameters and return type
fn add(a: i32, b: i32) -&gt; i32 {
    a + b                              // last expression = implicit return (no semicolon)
}

// No return value (returns unit type `()`)
fn greet(name: &amp;str) {
    println!("Hello, {name}!");
}

// Explicit early return with `return` keyword
fn first_positive(numbers: &amp;[i32]) -&gt; Option&lt;i32&gt; {
    for &amp;n in numbers {
        if n &gt; 0 {
            return Some(n);            // early return
        }
    }
    None                               // implicit return
}

// Multiple return values via tuples
fn min_max(values: &amp;[i32]) -&gt; (i32, i32) {
    let mut min = values[0];
    let mut max = values[0];
    for &amp;v in &amp;values[1..] {
        if v &lt; min { min = v; }
        if v &gt; max { max = v; }
    }
    (min, max)
}

let (lo, hi) = min_max(&amp;[3, 1, 4, 1, 5, 9]);
println!("min={lo}, max={hi}");        // min=1, max=9

// Expression-based returns in blocks
let result = {
    let x = 10;
    let y = 20;
    x + y                              // block evaluates to 30
};
println!("{result}");                  // 30

// if/else as expressions
fn abs(n: i32) -&gt; i32 {
    if n &lt; 0 { -n } else { n }
}

// Never type (!) for functions that never return
fn forever() -&gt; ! {
    loop {
        // runs indefinitely
    }
}</code></pre>
                </div>

                <!-- Generic Functions -->
                <div class="subsection">
                    <h3 class="subsection-title">Generic Functions &amp; Where Clauses</h3>
                    <p class="subsection-description">Generics let you write functions that work across multiple types. Type parameters go in angle brackets after the function name. Trait bounds constrain what the type must support. For complex bounds, use <code>where</code> clauses for readability.</p>

                    <pre><code>// Generic function with a trait bound
fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T {
    let mut max = &amp;list[0];
    for item in &amp;list[1..] {
        if item &gt; max {
            max = item;
        }
    }
    max
}

println!("{}", largest(&amp;[34, 50, 25, 100, 65]));   // 100
println!("{}", largest(&amp;["apple", "banana", "cherry"])); // cherry

// Multiple trait bounds with +
fn print_and_clone&lt;T: std::fmt::Display + Clone&gt;(item: &amp;T) -&gt; T {
    println!("Value: {item}");
    item.clone()
}

// Where clause for complex bounds (preferred for readability)
fn process&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; String
where
    T: std::fmt::Display + Clone,
    U: std::fmt::Debug + PartialEq,
{
    format!("t={t}, u={u:?}")
}

// Const generics (arrays of specific sizes)
fn first_n&lt;const N: usize&gt;(slice: &amp;[i32]) -&gt; [i32; N] {
    let mut arr = [0i32; N];
    arr.copy_from_slice(&amp;slice[..N]);
    arr
}

let first_three: [i32; 3] = first_n(&amp;[10, 20, 30, 40, 50]);
println!("{:?}", first_three);         // [10, 20, 30]

// Returning impl Trait (hide concrete type)
fn make_greeting(name: &amp;str) -&gt; impl std::fmt::Display {
    format!("Hello, {name}!")
}</code></pre>
                </div>

                <!-- Closures -->
                <div class="subsection">
                    <h3 class="subsection-title">Closures</h3>
                    <p class="subsection-description">Closures are anonymous functions that can capture variables from their enclosing scope. The syntax uses <code>|args|</code> for parameters. Rust infers parameter and return types for closures (though you can annotate them explicitly). How the closure captures its environment determines which <code>Fn</code> trait it implements.</p>

                    <pre><code>// Basic closure syntax
let add = |a, b| a + b;
println!("{}", add(3, 4));             // 7

// Closure with type annotations (optional)
let multiply: fn(i32, i32) -&gt; i32 = |a: i32, b: i32| -&gt; i32 { a * b };

// Multi-line closure with braces
let process = |name: &amp;str| {
    let greeting = format!("Hello, {name}!");
    println!("{greeting}");
    greeting.len()
};

// Capturing variables from the environment
let base = 10;
let add_base = |x| x + base;          // captures `base` by reference (&amp;)
println!("{}", add_base(5));           // 15

// Mutable capture (&amp;mut)
let mut count = 0;
let mut increment = || {
    count += 1;                        // captures `count` by &amp;mut
    count
};
println!("{}", increment());           // 1
println!("{}", increment());           // 2

// Move capture (takes ownership)
let name = String::from("Rust");
let greet = move || {
    println!("Hello from {name}!");    // `name` is moved into the closure
};
greet();
// println!("{name}");                 // ERROR: name was moved</code></pre>

                    <div class="alert alert-info">
                        <h4>Capture Modes</h4>
                        <p>Rust automatically picks the least restrictive capture mode: <code>&amp;</code> (shared reference) if possible, then <code>&amp;mut</code> (mutable reference), then move (ownership). Use the <code>move</code> keyword before the closure to force all captures to take ownership &mdash; essential when sending closures to other threads or returning them from functions.</p>
                    </div>
                </div>

                <!-- Fn Traits -->
                <div class="subsection">
                    <h3 class="subsection-title">Fn, FnMut, and FnOnce Traits</h3>
                    <p class="subsection-description">Every closure implements one or more of the three <code>Fn</code> traits. The trait determines how the closure can be called and constrains where you can use it.</p>

                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Trait</th>
                                    <th>Capture</th>
                                    <th>Can Call</th>
                                    <th>Use Case</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>Fn(&amp;self)</code></td>
                                    <td>Borrows by shared reference <code>&amp;</code></td>
                                    <td>Multiple times</td>
                                    <td>Read-only access to captured variables; most closures</td>
                                </tr>
                                <tr>
                                    <td><code>FnMut(&amp;mut self)</code></td>
                                    <td>Borrows by mutable reference <code>&amp;mut</code></td>
                                    <td>Multiple times</td>
                                    <td>Mutates captured variables (e.g., counters, accumulators)</td>
                                </tr>
                                <tr>
                                    <td><code>FnOnce(self)</code></td>
                                    <td>Takes ownership (moves captures)</td>
                                    <td>Exactly once</td>
                                    <td>Consumes captured values (e.g., returning an owned value)</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <pre><code>// Fn: borrows immutably, can be called many times
fn apply_twice&lt;F: Fn(i32) -&gt; i32&gt;(f: F, x: i32) -&gt; i32 {
    f(f(x))
}
let double = |x| x * 2;
println!("{}", apply_twice(double, 3));  // 12

// FnMut: borrows mutably
fn call_n_times&lt;F: FnMut()&gt;(mut f: F, n: usize) {
    for _ in 0..n {
        f();
    }
}
let mut total = 0;
call_n_times(|| total += 1, 5);
println!("{total}");                   // 5

// FnOnce: consumes captured values, callable only once
fn consume&lt;F: FnOnce() -&gt; String&gt;(f: F) -&gt; String {
    f()
}
let name = String::from("Rust");
let greeting = consume(move || format!("Hello, {name}!"));
println!("{greeting}");                // Hello, Rust!

// Returning closures (must use impl Fn or Box&lt;dyn Fn&gt;)
fn make_adder(base: i32) -&gt; impl Fn(i32) -&gt; i32 {
    move |x| x + base
}
let add_ten = make_adder(10);
println!("{}", add_ten(5));            // 15

// Box&lt;dyn Fn&gt; when returning different closures conditionally
fn choose_op(add: bool) -&gt; Box&lt;dyn Fn(i32, i32) -&gt; i32&gt; {
    if add {
        Box::new(|a, b| a + b)
    } else {
        Box::new(|a, b| a * b)
    }
}
let op = choose_op(true);
println!("{}", op(3, 4));              // 7</code></pre>
                </div>

                <!-- Iterator Methods with Closures -->
                <div class="subsection">
                    <h3 class="subsection-title">Iterator Methods with Closures</h3>
                    <p class="subsection-description">Rust's iterator trait provides a rich set of combinators that accept closures. These are zero-cost abstractions &mdash; the compiler optimizes them into tight loops equivalent to hand-written code.</p>

                    <pre><code>let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// map: transform each element
let doubled: Vec&lt;i32&gt; = numbers.iter().map(|&amp;x| x * 2).collect();
// [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]

// filter: keep elements matching a predicate
let evens: Vec&lt;&amp;i32&gt; = numbers.iter().filter(|&amp;&amp;x| x % 2 == 0).collect();
// [2, 4, 6, 8, 10]

// fold: reduce to a single value (like reduce in other languages)
let sum = numbers.iter().fold(0, |acc, &amp;x| acc + x);
// 55

// for_each: side effects for each element (no collecting)
numbers.iter().for_each(|x| print!("{x} "));
// 1 2 3 4 5 6 7 8 9 10

// find: first element matching a predicate (returns Option)
let first_big = numbers.iter().find(|&amp;&amp;x| x &gt; 7);
// Some(8)

// any: does any element match?
let has_negative = numbers.iter().any(|&amp;x| x &lt; 0);
// false

// all: do all elements match?
let all_positive = numbers.iter().all(|&amp;x| x &gt; 0);
// true

// collect into different types
let as_strings: Vec&lt;String&gt; = numbers.iter().map(|x| x.to_string()).collect();
let as_set: std::collections::HashSet&lt;&amp;i32&gt; = numbers.iter().collect();

// Chaining: filter, transform, and collect in one pipeline
let result: Vec&lt;String&gt; = numbers.iter()
    .filter(|&amp;&amp;x| x % 2 == 0)
    .map(|x| format!("{x} is even"))
    .collect();
// ["2 is even", "4 is even", "6 is even", "8 is even", "10 is even"]</code></pre>
                </div>

                <!-- Iterator Adaptors -->
                <div class="subsection">
                    <h3 class="subsection-title">Iterator Adaptors</h3>
                    <p class="subsection-description">Beyond <code>map</code> and <code>filter</code>, the standard library provides powerful adaptors for composing complex iteration pipelines.</p>

                    <pre><code>let a = vec![1, 2, 3];
let b = vec![4, 5, 6];

// chain: concatenate two iterators
let chained: Vec&lt;i32&gt; = a.iter().chain(b.iter()).copied().collect();
// [1, 2, 3, 4, 5, 6]

// zip: pair up elements from two iterators
let zipped: Vec&lt;(&amp;i32, &amp;i32)&gt; = a.iter().zip(b.iter()).collect();
// [(1,4), (2,5), (3,6)]

// enumerate: add index to each element
for (i, val) in a.iter().enumerate() {
    println!("index {i}: {val}");
}
// index 0: 1,  index 1: 2,  index 2: 3

// take: first N elements
let first_two: Vec&lt;&amp;i32&gt; = a.iter().take(2).collect();
// [1, 2]

// skip: skip first N elements
let after_first: Vec&lt;&amp;i32&gt; = a.iter().skip(1).collect();
// [2, 3]

// flatten: collapse nested iterators
let nested = vec![vec![1, 2], vec![3, 4], vec![5]];
let flat: Vec&lt;&amp;i32&gt; = nested.iter().flatten().collect();
// [1, 2, 3, 4, 5]

// flat_map: map then flatten (very common)
let words: Vec&lt;&amp;str&gt; = vec!["hello world", "foo bar"]
    .iter()
    .flat_map(|s| s.split_whitespace())
    .collect();
// ["hello", "world", "foo", "bar"]

// peekable: look ahead without consuming
let mut iter = [1, 2, 3].iter().peekable();
assert_eq!(iter.peek(), Some(&amp;&amp;1));   // peek without advancing
assert_eq!(iter.next(), Some(&amp;1));     // now consume it

// windows and chunks (on slices, not iterators)
let data = [1, 2, 3, 4, 5];
for window in data.windows(3) {
    println!("{window:?}");            // [1,2,3], [2,3,4], [3,4,5]
}
for chunk in data.chunks(2) {
    println!("{chunk:?}");             // [1,2], [3,4], [5]
}</code></pre>
                </div>

                <!-- into_iter vs iter vs iter_mut -->
                <div class="subsection">
                    <h3 class="subsection-title">into_iter() vs iter() vs iter_mut()</h3>
                    <p class="subsection-description">The three iteration methods determine ownership semantics: whether you borrow, mutably borrow, or consume the collection.</p>

                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Method</th>
                                    <th>Yields</th>
                                    <th>Collection After</th>
                                    <th>Use When</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>.iter()</code></td>
                                    <td><code>&amp;T</code></td>
                                    <td>Unchanged (borrowed)</td>
                                    <td>You need to read elements without consuming</td>
                                </tr>
                                <tr>
                                    <td><code>.iter_mut()</code></td>
                                    <td><code>&amp;mut T</code></td>
                                    <td>Unchanged (mutably borrowed)</td>
                                    <td>You need to modify elements in place</td>
                                </tr>
                                <tr>
                                    <td><code>.into_iter()</code></td>
                                    <td><code>T</code></td>
                                    <td>Consumed (moved)</td>
                                    <td>You want to take ownership of elements</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <pre><code>let mut names = vec!["Alice".to_string(), "Bob".to_string(), "Charlie".to_string()];

// iter(): borrows each element as &amp;String
for name in names.iter() {
    println!("Hello, {name}!");        // name is &amp;String
}
// `names` is still usable here

// iter_mut(): mutably borrows each element as &amp;mut String
for name in names.iter_mut() {
    name.push_str("!");                // modify in place
}
println!("{:?}", names);              // ["Alice!", "Bob!", "Charlie!"]

// into_iter(): takes ownership, consumes the collection
let owned: Vec&lt;String&gt; = names.into_iter()
    .map(|mut name| { name.push_str("?"); name })
    .collect();
// `names` is no longer valid here — it was consumed
println!("{:?}", owned);              // ["Alice!?", "Bob!?", "Charlie!?"]

// for loops use into_iter() implicitly
let items = vec![1, 2, 3];
for item in items {                    // same as items.into_iter()
    println!("{item}");
}
// `items` has been consumed

// for loops on references use iter() implicitly
let items = vec![1, 2, 3];
for item in &amp;items {                   // same as items.iter()
    println!("{item}");
}
// `items` is still available</code></pre>
                </div>

                <!-- Custom Iterators -->
                <div class="subsection">
                    <h3 class="subsection-title">Custom Iterators</h3>
                    <p class="subsection-description">Implement the <code>Iterator</code> trait on your own types by defining a <code>next()</code> method. This unlocks the entire iterator combinator toolkit for your custom data structures.</p>

                    <pre><code>// A counter that yields values from 1 up to a maximum
struct Counter {
    current: u32,
    max: u32,
}

impl Counter {
    fn new(max: u32) -&gt; Self {
        Counter { current: 0, max }
    }
}

impl Iterator for Counter {
    type Item = u32;                   // associated type: what we yield

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.current &lt; self.max {
            self.current += 1;
            Some(self.current)
        } else {
            None                       // signals end of iteration
        }
    }
}

// Now Counter gets ALL iterator methods for free
let counter = Counter::new(5);
let sum: u32 = counter.sum();
println!("Sum 1..5 = {sum}");         // 15

let evens: Vec&lt;u32&gt; = Counter::new(10)
    .filter(|x| x % 2 == 0)
    .collect();
println!("{:?}", evens);              // [2, 4, 6, 8, 10]

// Zipping two custom iterators
let pairs: Vec&lt;(u32, u32)&gt; = Counter::new(3)
    .zip(Counter::new(3).map(|x| x * 10))
    .collect();
println!("{:?}", pairs);              // [(1, 10), (2, 20), (3, 30)]

// Fibonacci iterator
struct Fibonacci {
    a: u64,
    b: u64,
}

impl Fibonacci {
    fn new() -&gt; Self {
        Fibonacci { a: 0, b: 1 }
    }
}

impl Iterator for Fibonacci {
    type Item = u64;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let result = self.a;
        self.a = self.b;
        self.b = result + self.b;
        Some(result)                   // infinite iterator — always returns Some
    }
}

let fibs: Vec&lt;u64&gt; = Fibonacci::new().take(10).collect();
println!("{:?}", fibs);
// [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</code></pre>
                </div>
            </div>
        </section>

        <!-- ============================================
             SECTION 08: ERROR HANDLING
             ============================================ -->
        <section id="error-handling" class="section">
            <div class="container">
                <div class="section-header">
                    <div class="section-number">08</div>
                    <h2 class="section-title">Error Handling</h2>
                    <div class="section-line"></div>
                    <p class="section-description">Rust distinguishes between unrecoverable errors (<code>panic!</code>) and recoverable errors (<code>Result&lt;T, E&gt;</code>). The type system forces you to handle errors explicitly &mdash; no unchecked exceptions.</p>
                </div>

                <!-- panic! vs Result -->
                <div class="subsection">
                    <h3 class="subsection-title">panic! vs Recoverable Errors</h3>
                    <p class="subsection-description"><code>panic!</code> unwinds the stack and terminates the thread (or the program). Use it only for truly unrecoverable situations &mdash; bugs, violated invariants, or corrupted state. For everything else, use <code>Result</code>.</p>

                    <pre><code>// panic! — unrecoverable error, aborts the thread
panic!("Something went terribly wrong");

// Common implicit panics
let v = vec![1, 2, 3];
// v[99];                              // panics: index out of bounds
// "hello".parse::&lt;i32&gt;().unwrap();   // panics: parse error

// Result&lt;T, E&gt; — recoverable error
use std::fs;
use std::io;

fn read_config() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string("config.toml")  // returns Result&lt;String, io::Error&gt;
}

// Handle the Result explicitly
match read_config() {
    Ok(contents) =&gt; println!("Config: {contents}"),
    Err(e) =&gt; eprintln!("Failed to read config: {e}"),
}

// When to use panic! vs Result:
// panic!  → programmer bugs, impossible states, tests/prototyping
// Result  → expected failures (IO, network, user input, parsing)</code></pre>
                </div>

                <!-- The ? Operator -->
                <div class="subsection">
                    <h3 class="subsection-title">The ? Operator &amp; Result Chaining</h3>
                    <p class="subsection-description">The <code>?</code> operator is Rust's primary tool for propagating errors. It unwraps an <code>Ok</code> value or returns the <code>Err</code> early from the enclosing function. It also works with <code>Option</code> (returning <code>None</code> on failure).</p>

                    <pre><code>use std::fs;
use std::io;

// Without ? — verbose match chains
fn read_username_verbose() -&gt; Result&lt;String, io::Error&gt; {
    let contents = match fs::read_to_string("username.txt") {
        Ok(s) =&gt; s,
        Err(e) =&gt; return Err(e),
    };
    Ok(contents.trim().to_string())
}

// With ? — clean and concise
fn read_username() -&gt; Result&lt;String, io::Error&gt; {
    let contents = fs::read_to_string("username.txt")?;  // ? propagates Err
    Ok(contents.trim().to_string())
}

// Chaining multiple ? calls
fn get_user_email() -&gt; Result&lt;String, io::Error&gt; {
    let username = fs::read_to_string("username.txt")?.trim().to_string();
    let email = fs::read_to_string(format!("emails/{username}.txt"))?;
    Ok(email.trim().to_string())
}

// ? with Option (in functions returning Option)
fn first_even(numbers: &amp;[i32]) -&gt; Option&lt;i32&gt; {
    let first = numbers.first()?;      // returns None if empty
    if first % 2 == 0 {
        Some(*first)
    } else {
        None
    }
}

// ? in main (requires main to return Result)
fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let config = fs::read_to_string("app.toml")?;
    let port: u16 = config.trim().parse()?;
    println!("Running on port {port}");
    Ok(())
}</code></pre>
                </div>

                <!-- Multiple Error Types -->
                <div class="subsection">
                    <h3 class="subsection-title">Multiple Error Types</h3>
                    <p class="subsection-description">When a function can produce different error types, you need a unified error type. The simplest approach is <code>Box&lt;dyn Error&gt;</code>. For libraries, define custom error enums.</p>

                    <pre><code>use std::error::Error;
use std::fs;
use std::num::ParseIntError;
use std::io;

// Box&lt;dyn Error&gt; — the quick-and-easy approach
fn parse_config() -&gt; Result&lt;u16, Box&lt;dyn Error&gt;&gt; {
    let text = fs::read_to_string("port.txt")?;   // io::Error
    let port = text.trim().parse::&lt;u16&gt;()?;        // ParseIntError
    Ok(port)
    // Both error types are automatically converted to Box&lt;dyn Error&gt;
}

// Custom error enum — full control (best for libraries)
#[derive(Debug)]
enum ConfigError {
    Io(io::Error),
    Parse(ParseIntError),
    Validation(String),
}

impl std::fmt::Display for ConfigError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        match self {
            ConfigError::Io(e) =&gt; write!(f, "IO error: {e}"),
            ConfigError::Parse(e) =&gt; write!(f, "Parse error: {e}"),
            ConfigError::Validation(msg) =&gt; write!(f, "Validation: {msg}"),
        }
    }
}

impl Error for ConfigError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; {
        match self {
            ConfigError::Io(e) =&gt; Some(e),
            ConfigError::Parse(e) =&gt; Some(e),
            ConfigError::Validation(_) =&gt; None,
        }
    }
}

// Implement From to enable ? conversion
impl From&lt;io::Error&gt; for ConfigError {
    fn from(e: io::Error) -&gt; Self {
        ConfigError::Io(e)
    }
}

impl From&lt;ParseIntError&gt; for ConfigError {
    fn from(e: ParseIntError) -&gt; Self {
        ConfigError::Parse(e)
    }
}

// Now ? works automatically
fn load_config() -&gt; Result&lt;u16, ConfigError&gt; {
    let text = fs::read_to_string("port.txt")?;   // auto-converted via From
    let port = text.trim().parse::&lt;u16&gt;()?;        // auto-converted via From
    if port == 0 {
        return Err(ConfigError::Validation("Port cannot be 0".into()));
    }
    Ok(port)
}</code></pre>
                </div>

                <!-- thiserror Crate -->
                <div class="subsection">
                    <h3 class="subsection-title">thiserror Crate</h3>
                    <p class="subsection-description">The <code>thiserror</code> crate eliminates the boilerplate of manually implementing <code>Display</code>, <code>Error</code>, and <code>From</code>. It is the standard choice for library error types.</p>

                    <pre><code>// Cargo.toml: thiserror = "2"
use thiserror::Error;

#[derive(Debug, Error)]
enum AppError {
    #[error("IO error: {0}")]                         // generates Display impl
    Io(#[from] std::io::Error),                       // generates From impl

    #[error("Parse error: {0}")]
    Parse(#[from] std::num::ParseIntError),

    #[error("Validation failed: {message}")]
    Validation { message: String },

    #[error("Not found: {name}")]
    NotFound { name: String, id: u64 },

    #[error("Internal error")]
    Internal(#[source] Box&lt;dyn std::error::Error + Send + Sync&gt;),
}

// Usage: ? automatically converts thanks to #[from]
fn process_file(path: &amp;str) -&gt; Result&lt;u64, AppError&gt; {
    let text = std::fs::read_to_string(path)?;        // io::Error -&gt; AppError::Io
    let value = text.trim().parse::&lt;u64&gt;()?;          // ParseIntError -&gt; AppError::Parse
    if value == 0 {
        return Err(AppError::Validation {
            message: "Value must be non-zero".into(),
        });
    }
    Ok(value)
}</code></pre>
                </div>

                <!-- anyhow Crate -->
                <div class="subsection">
                    <h3 class="subsection-title">anyhow Crate</h3>
                    <p class="subsection-description">The <code>anyhow</code> crate provides <code>anyhow::Result</code> and <code>anyhow::Error</code> for ergonomic error handling in <strong>application</strong> code. It wraps any error type and provides rich context.</p>

                    <pre><code>// Cargo.toml: anyhow = "1"
use anyhow::{Context, Result, bail, ensure};

// anyhow::Result&lt;T&gt; is an alias for Result&lt;T, anyhow::Error&gt;
fn load_config(path: &amp;str) -&gt; Result&lt;Config&gt; {
    let text = std::fs::read_to_string(path)
        .context("Failed to read config file")?;       // adds context message

    let config: Config = toml::from_str(&amp;text)
        .with_context(|| format!("Failed to parse {path}"))?;  // lazy context

    Ok(config)
}

// bail! — return an error immediately
fn validate_port(port: u16) -&gt; Result&lt;()&gt; {
    if port == 0 {
        bail!("Port cannot be zero");                  // returns Err(anyhow!(...))
    }
    Ok(())
}

// ensure! — assert-like macro that returns Err on failure
fn process(data: &amp;[u8]) -&gt; Result&lt;()&gt; {
    ensure!(!data.is_empty(), "Data must not be empty");
    ensure!(data.len() &lt; 1024, "Data too large: {} bytes", data.len());
    // process data...
    Ok(())
}

// .context() adds human-readable messages for error chains
fn main() -&gt; Result&lt;()&gt; {
    let config = load_config("app.toml")
        .context("Application startup failed")?;
    // Error output: "Application startup failed: Failed to read config file: ..."
    Ok(())
}

// Downcasting to the original error type
fn handle_error(err: &amp;anyhow::Error) {
    if let Some(io_err) = err.downcast_ref::&lt;std::io::Error&gt;() {
        eprintln!("IO error: {io_err}");
    } else {
        eprintln!("Other error: {err}");
    }
}</code></pre>
                </div>

                <!-- thiserror vs anyhow -->
                <div class="subsection">
                    <h3 class="subsection-title">thiserror vs anyhow</h3>
                    <p class="subsection-description">The two crates serve complementary purposes and are commonly used together in the same project.</p>

                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Aspect</th>
                                    <th>thiserror</th>
                                    <th>anyhow</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Best for</td>
                                    <td>Libraries</td>
                                    <td>Applications</td>
                                </tr>
                                <tr>
                                    <td>Error type</td>
                                    <td>Custom enum you define</td>
                                    <td><code>anyhow::Error</code> (opaque wrapper)</td>
                                </tr>
                                <tr>
                                    <td>Callers can match?</td>
                                    <td>Yes &mdash; match on variants</td>
                                    <td>Only via <code>downcast</code></td>
                                </tr>
                                <tr>
                                    <td>Context messages</td>
                                    <td>Manual (via Display)</td>
                                    <td><code>.context()</code> / <code>.with_context()</code></td>
                                </tr>
                                <tr>
                                    <td>Boilerplate</td>
                                    <td>Minimal (derive macro)</td>
                                    <td>Near zero</td>
                                </tr>
                                <tr>
                                    <td>When to choose</td>
                                    <td>When callers need to inspect error variants</td>
                                    <td>When you just need to propagate and report errors</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <div class="alert alert-warning">
                        <h4>Rule of Thumb</h4>
                        <p><strong>Library code:</strong> use <code>thiserror</code> &mdash; define explicit error types so your callers can match on them. <strong>Application code:</strong> use <code>anyhow</code> &mdash; you're the final consumer of errors, so ergonomics and context matter most. In a large project, libraries internal to the workspace use <code>thiserror</code>, and the top-level binary crate uses <code>anyhow</code>.</p>
                    </div>
                </div>

                <!-- Common Error Handling Patterns -->
                <div class="subsection">
                    <h3 class="subsection-title">Common Error Handling Patterns</h3>
                    <p class="subsection-description">Practical patterns for dealing with errors in real Rust code.</p>

                    <pre><code>// Pattern 1: Mapping errors with .map_err()
fn parse_port(s: &amp;str) -&gt; Result&lt;u16, String&gt; {
    s.parse::&lt;u16&gt;().map_err(|e| format!("Invalid port '{s}': {e}"))
}

// Pattern 2: Providing defaults with .unwrap_or() / .unwrap_or_else()
let port: u16 = std::env::var("PORT")
    .ok()                                   // Result -&gt; Option
    .and_then(|s| s.parse().ok())           // parse, ignoring errors
    .unwrap_or(8080);                       // default value

// Pattern 3: Collecting Results — fail on first error
let strings = vec!["1", "2", "three", "4"];
let numbers: Result&lt;Vec&lt;i32&gt;, _&gt; = strings.iter()
    .map(|s| s.parse::&lt;i32&gt;())
    .collect();                             // Err on "three"
println!("{numbers:?}");                    // Err(ParseIntError)

// Pattern 4: Collecting Results — keep only successes
let numbers: Vec&lt;i32&gt; = strings.iter()
    .filter_map(|s| s.parse::&lt;i32&gt;().ok())
    .collect();
println!("{numbers:?}");                    // [1, 2, 4]

// Pattern 5: Converting between error types with From
impl From&lt;serde_json::Error&gt; for MyError {
    fn from(e: serde_json::Error) -&gt; Self {
        MyError::Serialization(e.to_string())
    }
}

// Pattern 6: Using .ok() and .err() to convert between Result and Option
let result: Result&lt;i32, &amp;str&gt; = Ok(42);
let opt: Option&lt;i32&gt; = result.ok();       // Some(42)

let result: Result&lt;i32, &amp;str&gt; = Err("fail");
let opt: Option&lt;&amp;str&gt; = result.err();     // Some("fail")

// Pattern 7: The try block (nightly feature, but common pattern via closures)
let result: Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; = (|| {
    let text = std::fs::read_to_string("data.txt")?;
    let value: i32 = text.trim().parse()?;
    Ok(format!("Got: {value}"))
})();</code></pre>
                </div>
            </div>
        </section>

        <!-- ============================================
             SECTION 09: TRAITS & GENERICS
             ============================================ -->
        <section id="traits-generics" class="section">
            <div class="container">
                <div class="section-header">
                    <div class="section-number">09</div>
                    <h2 class="section-title">Traits &amp; Generics</h2>
                    <div class="section-line"></div>
                    <p class="section-description">Traits define shared behavior (like interfaces). Generics let you write code that works across types. Together they power Rust's zero-cost polymorphism and enable powerful abstraction without runtime overhead.</p>
                </div>

                <!-- Defining Traits -->
                <div class="subsection">
                    <h3 class="subsection-title">Defining &amp; Implementing Traits</h3>
                    <p class="subsection-description">A trait declares a set of methods a type must implement. Traits can provide default method bodies that implementors may override.</p>

                    <pre><code>// Define a trait
trait Summary {
    // Required method (no body — implementors must define it)
    fn summarize(&amp;self) -&gt; String;

    // Default method (implementors can override or use as-is)
    fn preview(&amp;self) -&gt; String {
        format!("Read more: {}...", &amp;self.summarize()[..20.min(self.summarize().len())])
    }
}

struct Article {
    title: String,
    author: String,
    content: String,
}

// Implement the trait for Article
impl Summary for Article {
    fn summarize(&amp;self) -&gt; String {
        format!("{}, by {}", self.title, self.author)
    }
    // preview() uses the default implementation
}

struct Tweet {
    username: String,
    text: String,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!("@{}: {}", self.username, self.text)
    }

    // Override the default
    fn preview(&amp;self) -&gt; String {
        format!("@{} tweeted", self.username)
    }
}

let article = Article {
    title: "Rust 2024".into(),
    author: "Ferris".into(),
    content: "Great year for Rust...".into(),
};
println!("{}", article.summarize());   // Rust 2024, by Ferris

// Traits with associated constants and multiple methods
trait Shape {
    const DIMENSIONS: u32;

    fn area(&amp;self) -&gt; f64;
    fn perimeter(&amp;self) -&gt; f64;
    fn description(&amp;self) -&gt; String {
        format!("A {}D shape with area {:.2}", Self::DIMENSIONS, self.area())
    }
}</code></pre>
                </div>

                <!-- Trait Bounds -->
                <div class="subsection">
                    <h3 class="subsection-title">Trait Bounds &amp; impl Trait</h3>
                    <p class="subsection-description">Trait bounds constrain generic types to only those implementing specific traits. The <code>impl Trait</code> syntax provides a concise shorthand in function signatures.</p>

                    <pre><code>// Trait bound syntax: T must implement Summary
fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!("Breaking: {}", item.summarize());
}

// impl Trait shorthand (equivalent to the above for simple cases)
fn notify_short(item: &amp;impl Summary) {
    println!("Breaking: {}", item.summarize());
}

// Multiple bounds with +
fn display_summary&lt;T: Summary + std::fmt::Display&gt;(item: &amp;T) {
    println!("Summary: {}", item.summarize());
    println!("Display: {item}");
}

// Where clause (cleaner for many bounds)
fn process&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; String
where
    T: Summary + Clone,
    U: std::fmt::Display + std::fmt::Debug,
{
    let copy = t.clone();
    format!("{} — {u}", copy.summarize())
}

// impl Trait in return position (return a type that implements Summary)
fn create_summary() -&gt; impl Summary {
    Article {
        title: "New Article".into(),
        author: "Author".into(),
        content: "Content...".into(),
    }
}
// Caller sees only `impl Summary`, not the concrete `Article` type
// Note: you can only return ONE concrete type per function with impl Trait</code></pre>
                </div>

                <!-- dyn Trait -->
                <div class="subsection">
                    <h3 class="subsection-title">dyn Trait (Trait Objects)</h3>
                    <p class="subsection-description">Trait objects (<code>dyn Trait</code>) enable dynamic dispatch &mdash; calling methods through a vtable at runtime. Use them when you need to store or return different types that implement the same trait.</p>

                    <pre><code>// Box&lt;dyn Trait&gt; — heap-allocated trait object
fn make_summary(is_tweet: bool) -&gt; Box&lt;dyn Summary&gt; {
    if is_tweet {
        Box::new(Tweet {
            username: "ferris".into(),
            text: "Hello, crabs!".into(),
        })
    } else {
        Box::new(Article {
            title: "News".into(),
            author: "Reporter".into(),
            content: "...".into(),
        })
    }
}

// Collections of different types via trait objects
let items: Vec&lt;Box&lt;dyn Summary&gt;&gt; = vec![
    Box::new(Article { title: "A".into(), author: "B".into(), content: "C".into() }),
    Box::new(Tweet { username: "user".into(), text: "hi".into() }),
];

for item in &amp;items {
    println!("{}", item.summarize());  // dynamic dispatch
}

// &amp;dyn Trait — borrowed trait object (no allocation)
fn print_summary(item: &amp;dyn Summary) {
    println!("{}", item.summarize());
}

let tweet = Tweet { username: "ferris".into(), text: "Hello!".into() };
print_summary(&amp;tweet);                // pass &amp;Tweet as &amp;dyn Summary</code></pre>

                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Aspect</th>
                                    <th><code>impl Trait</code> (Static Dispatch)</th>
                                    <th><code>dyn Trait</code> (Dynamic Dispatch)</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Dispatch</td>
                                    <td>Compile-time (monomorphization)</td>
                                    <td>Runtime (vtable lookup)</td>
                                </tr>
                                <tr>
                                    <td>Performance</td>
                                    <td>Faster (inlining possible)</td>
                                    <td>Small overhead per call</td>
                                </tr>
                                <tr>
                                    <td>Binary size</td>
                                    <td>Larger (one copy per concrete type)</td>
                                    <td>Smaller (shared code)</td>
                                </tr>
                                <tr>
                                    <td>Heterogeneous collections</td>
                                    <td>Not possible</td>
                                    <td>Yes &mdash; <code>Vec&lt;Box&lt;dyn Trait&gt;&gt;</code></td>
                                </tr>
                                <tr>
                                    <td>Return different types</td>
                                    <td>No (one concrete type per function)</td>
                                    <td>Yes &mdash; <code>Box&lt;dyn Trait&gt;</code></td>
                                </tr>
                                <tr>
                                    <td>Use when</td>
                                    <td>Type is known at compile time</td>
                                    <td>Type varies at runtime</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Associated Types -->
                <div class="subsection">
                    <h3 class="subsection-title">Associated Types</h3>
                    <p class="subsection-description">Associated types are type placeholders within a trait that implementors fill in. They simplify signatures compared to generic parameters on the trait itself.</p>

                    <pre><code>// Iterator uses an associated type rather than a generic parameter
// trait Iterator { type Item; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;; }

struct Doubles {
    current: u32,
    max: u32,
}

impl Iterator for Doubles {
    type Item = u32;                   // specify the associated type

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.current &lt;= self.max {
            let val = self.current * 2;
            self.current += 1;
            Some(val)
        } else {
            None
        }
    }
}

// Custom trait with associated type
trait Converter {
    type Input;
    type Output;
    type Error;

    fn convert(&amp;self, input: Self::Input) -&gt; Result&lt;Self::Output, Self::Error&gt;;
}

struct CelsiusToFahrenheit;

impl Converter for CelsiusToFahrenheit {
    type Input = f64;
    type Output = f64;
    type Error = String;

    fn convert(&amp;self, celsius: f64) -&gt; Result&lt;f64, String&gt; {
        if celsius &lt; -273.15 {
            Err("Below absolute zero".into())
        } else {
            Ok(celsius * 9.0 / 5.0 + 32.0)
        }
    }
}

// Why associated types vs generics on the trait?
// Associated type: one implementation per type (Iterator has ONE Item type)
// Generic param:   multiple implementations (From&lt;T&gt; can have many T values)</code></pre>
                </div>

                <!-- Generic Structs and Enums -->
                <div class="subsection">
                    <h3 class="subsection-title">Generic Structs, Enums &amp; Impl Blocks</h3>
                    <p class="subsection-description">Generics aren't just for functions &mdash; structs, enums, and their <code>impl</code> blocks can all be parameterized by types.</p>

                    <pre><code>// Generic struct
struct Point&lt;T&gt; {
    x: T,
    y: T,
}

let int_point = Point { x: 5, y: 10 };
let float_point = Point { x: 1.5, y: 3.7 };

// Generic struct with multiple type parameters
struct Pair&lt;A, B&gt; {
    first: A,
    second: B,
}

let pair = Pair { first: "hello", second: 42 };

// Generic impl block
impl&lt;T&gt; Point&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Point { x, y }
    }

    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

// Impl block with trait bounds (only for specific T)
impl&lt;T: std::fmt::Display + PartialOrd&gt; Point&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!("x ({}) is >= y ({})", self.x, self.y);
        } else {
            println!("y ({}) is > x ({})", self.y, self.x);
        }
    }
}

// Impl for a specific concrete type
impl Point&lt;f64&gt; {
    fn distance_from_origin(&amp;self) -&gt; f64 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}

// Generic enum (Option and Result are generic enums!)
enum Wrapper&lt;T&gt; {
    Some(T),
    Empty,
}

// Method on generic enum
impl&lt;T: std::fmt::Debug&gt; Wrapper&lt;T&gt; {
    fn inspect(&amp;self) {
        match self {
            Wrapper::Some(val) =&gt; println!("Contains: {val:?}"),
            Wrapper::Empty =&gt; println!("Empty"),
        }
    }
}</code></pre>
                </div>

                <!-- Supertraits -->
                <div class="subsection">
                    <h3 class="subsection-title">Supertraits</h3>
                    <p class="subsection-description">A supertrait is a trait that requires another trait. If <code>trait A: B</code>, then any type implementing <code>A</code> must also implement <code>B</code>. This lets <code>A</code>'s methods use <code>B</code>'s methods.</p>

                    <pre><code>use std::fmt;

// PrintableShape requires Display (supertrait)
trait PrintableShape: fmt::Display {
    fn area(&amp;self) -&gt; f64;

    fn print_info(&amp;self) {
        // Can use Display methods because of the supertrait bound
        println!("{self} — area: {:.2}", self.area());
    }
}

struct Circle {
    radius: f64,
}

// Must implement BOTH Display and PrintableShape
impl fmt::Display for Circle {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, "Circle(r={})", self.radius)
    }
}

impl PrintableShape for Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * self.radius * self.radius
    }
}

let c = Circle { radius: 5.0 };
c.print_info();                        // Circle(r=5) — area: 78.54

// Multiple supertraits
trait Serializable: fmt::Display + fmt::Debug + Clone {
    fn serialize(&amp;self) -&gt; String;
}

// Supertrait chains: A: B, B: C means A requires both B and C
trait Animal: fmt::Display {
    fn name(&amp;self) -&gt; &amp;str;
}

trait Pet: Animal {                     // Pet requires Animal requires Display
    fn cuddle(&amp;self) {
        println!("{} enjoys being cuddled!", self.name());
    }
}</code></pre>
                </div>

                <!-- Common Standard Library Traits -->
                <div class="subsection">
                    <h3 class="subsection-title">Common Standard Library Traits</h3>
                    <p class="subsection-description">Rust's standard library defines many foundational traits. Knowing these is essential for writing idiomatic Rust.</p>

                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Trait</th>
                                    <th>Purpose</th>
                                    <th>Derive?</th>
                                    <th>Notes</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>Display</code></td>
                                    <td>User-facing string formatting (<code>{}</code>)</td>
                                    <td>No</td>
                                    <td>Manual impl required; used by <code>println!</code>, <code>format!</code></td>
                                </tr>
                                <tr>
                                    <td><code>Debug</code></td>
                                    <td>Developer-facing formatting (<code>{:?}</code>)</td>
                                    <td>Yes</td>
                                    <td><code>#[derive(Debug)]</code> on nearly every type</td>
                                </tr>
                                <tr>
                                    <td><code>Clone</code></td>
                                    <td>Explicit deep copy via <code>.clone()</code></td>
                                    <td>Yes</td>
                                    <td>Can be expensive; heap allocation</td>
                                </tr>
                                <tr>
                                    <td><code>Copy</code></td>
                                    <td>Implicit bitwise copy (stack only)</td>
                                    <td>Yes</td>
                                    <td>Requires <code>Clone</code>; only for small stack types</td>
                                </tr>
                                <tr>
                                    <td><code>PartialEq</code></td>
                                    <td>Equality comparison (<code>==</code>, <code>!=</code>)</td>
                                    <td>Yes</td>
                                    <td>Partial: NaN != NaN for floats</td>
                                </tr>
                                <tr>
                                    <td><code>Eq</code></td>
                                    <td>Full equivalence (reflexive)</td>
                                    <td>Yes</td>
                                    <td>Marker trait; requires <code>PartialEq</code></td>
                                </tr>
                                <tr>
                                    <td><code>PartialOrd</code></td>
                                    <td>Ordering comparison (<code>&lt;</code>, <code>&gt;</code>, etc.)</td>
                                    <td>Yes</td>
                                    <td>Returns <code>Option&lt;Ordering&gt;</code>; partial for floats</td>
                                </tr>
                                <tr>
                                    <td><code>Ord</code></td>
                                    <td>Total ordering</td>
                                    <td>Yes</td>
                                    <td>Requires <code>Eq</code> + <code>PartialOrd</code>; needed for <code>BTreeMap</code> keys</td>
                                </tr>
                                <tr>
                                    <td><code>Hash</code></td>
                                    <td>Produce a hash value</td>
                                    <td>Yes</td>
                                    <td>Needed for <code>HashMap</code>/<code>HashSet</code> keys</td>
                                </tr>
                                <tr>
                                    <td><code>Default</code></td>
                                    <td>Provide a default value</td>
                                    <td>Yes</td>
                                    <td><code>Type::default()</code>; useful with struct update syntax</td>
                                </tr>
                                <tr>
                                    <td><code>From</code> / <code>Into</code></td>
                                    <td>Type conversion</td>
                                    <td>No</td>
                                    <td>Implement <code>From</code>; <code>Into</code> is auto-derived. Enables <code>?</code> for errors</td>
                                </tr>
                                <tr>
                                    <td><code>Deref</code></td>
                                    <td>Custom dereference (<code>*</code>)</td>
                                    <td>No</td>
                                    <td>Enables deref coercion (e.g., <code>&amp;String</code> &rarr; <code>&amp;str</code>)</td>
                                </tr>
                                <tr>
                                    <td><code>Drop</code></td>
                                    <td>Custom destructor logic</td>
                                    <td>No</td>
                                    <td>Called automatically when value goes out of scope</td>
                                </tr>
                                <tr>
                                    <td><code>Send</code></td>
                                    <td>Safe to transfer between threads</td>
                                    <td>Auto</td>
                                    <td>Auto-implemented; opt out with <code>!Send</code></td>
                                </tr>
                                <tr>
                                    <td><code>Sync</code></td>
                                    <td>Safe to share references between threads</td>
                                    <td>Auto</td>
                                    <td>Auto-implemented; <code>T: Sync</code> iff <code>&amp;T: Send</code></td>
                                </tr>
                                <tr>
                                    <td><code>Iterator</code></td>
                                    <td>Produce a sequence of values</td>
                                    <td>No</td>
                                    <td>Requires <code>type Item</code> and <code>fn next()</code></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Orphan Rule -->
                <div class="subsection">
                    <h3 class="subsection-title">The Orphan Rule</h3>
                    <p class="subsection-description">Rust's coherence rules prevent conflicting trait implementations. The orphan rule states: you can only implement a trait for a type if <strong>you own the trait or you own the type</strong> (at least one must be local to your crate).</p>

                    <pre><code>// ALLOWED: You own the type (MyStruct)
struct MyStruct(i32);

impl std::fmt::Display for MyStruct {   // Display is foreign, MyStruct is local — OK
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, "MyStruct({})", self.0)
    }
}

// ALLOWED: You own the trait (MyTrait)
trait MyTrait {
    fn describe(&amp;self) -&gt; String;
}

impl MyTrait for Vec&lt;i32&gt; {            // MyTrait is local, Vec is foreign — OK
    fn describe(&amp;self) -&gt; String {
        format!("Vec with {} elements", self.len())
    }
}

// NOT ALLOWED: Both trait and type are foreign
// impl Display for Vec&lt;i32&gt; { ... }   // ERROR: neither Display nor Vec is local

// Workaround: the newtype pattern
struct Wrapper(Vec&lt;String&gt;);           // Wrapper is local

impl std::fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

// Use Deref to make the wrapper transparent
impl std::ops::Deref for Wrapper {
    type Target = Vec&lt;String&gt;;
    fn deref(&amp;self) -&gt; &amp;Vec&lt;String&gt; {
        &amp;self.0
    }
}

let w = Wrapper(vec!["a".into(), "b".into(), "c".into()]);
println!("{w}");                       // [a, b, c]
println!("Length: {}", w.len());       // Deref lets us call Vec methods</code></pre>

                    <div class="alert alert-info">
                        <h4>Orphan Rule Summary</h4>
                        <p>You can implement <code>ForeignTrait for LocalType</code> or <code>LocalTrait for ForeignType</code>, but never <code>ForeignTrait for ForeignType</code>. When you need the latter, wrap the foreign type in a local newtype struct and optionally implement <code>Deref</code> so the wrapper is ergonomic to use.</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- ============================================
             SECTION 10: ASYNC & CONCURRENCY
             ============================================ -->
        <section id="async" class="section">
            <div class="container">
                <div class="section-header">
                    <div class="section-number">10</div>
                    <h2 class="section-title">Async &amp; Concurrency</h2>
                    <div class="section-line"></div>
                    <p class="section-description">Rust offers multiple concurrency models: OS threads for parallel CPU work, async/await for efficient I/O, and data parallelism via Rayon. The type system enforces thread safety at compile time through the <code>Send</code> and <code>Sync</code> traits.</p>
                </div>

                <!-- Threads -->
                <div class="subsection">
                    <h3 class="subsection-title">Threads: std::thread</h3>
                    <p class="subsection-description">Rust's standard library provides OS-level threads via <code>std::thread::spawn</code>. Each thread gets its own stack and runs independently. Use <code>move</code> closures to transfer ownership of captured variables into the thread.</p>

                    <pre><code>use std::thread;

// Spawn a thread &mdash; returns a JoinHandle
let handle = thread::spawn(|| {
    for i in 1..=5 {
        println!("spawned thread: {i}");
        thread::sleep(std::time::Duration::from_millis(10));
    }
    42 // threads can return values
});

// Do work on the main thread concurrently
for i in 1..=3 {
    println!("main thread: {i}");
    thread::sleep(std::time::Duration::from_millis(10));
}

// Wait for the spawned thread to finish and get its return value
let result = handle.join().unwrap(); // blocks until thread completes
println!("Thread returned: {result}"); // 42

// move closures transfer ownership into the thread
let data = vec![1, 2, 3];
let handle = thread::spawn(move || {
    // `data` is now owned by this thread
    println!("Vector: {data:?}");
    data.len()
});
// println!("{data:?}");  // ERROR: data was moved into the thread
let len = handle.join().unwrap();
println!("Length: {len}");

// Spawning multiple threads
let mut handles = vec![];
for i in 0..5 {
    handles.push(thread::spawn(move || {
        println!("Thread {i} running");
        i * 2
    }));
}
let results: Vec&lt;_&gt; = handles.into_iter()
    .map(|h| h.join().unwrap())
    .collect();
println!("Results: {results:?}"); // [0, 2, 4, 6, 8]</code></pre>
                </div>

                <!-- Shared State -->
                <div class="subsection">
                    <h3 class="subsection-title">Shared State: Arc, Mutex &amp; RwLock</h3>
                    <p class="subsection-description"><code>Arc&lt;T&gt;</code> (atomic reference counting) allows shared ownership across threads. Combine it with <code>Mutex&lt;T&gt;</code> for exclusive mutable access or <code>RwLock&lt;T&gt;</code> for multiple readers / single writer.</p>

                    <pre><code>use std::sync::{Arc, Mutex, RwLock};
use std::thread;

// Arc&lt;Mutex&lt;T&gt;&gt; &mdash; shared mutable state across threads
let counter = Arc::new(Mutex::new(0));
let mut handles = vec![];

for _ in 0..10 {
    let counter = Arc::clone(&amp;counter); // clone the Arc, not the data
    handles.push(thread::spawn(move || {
        let mut num = counter.lock().unwrap(); // acquire lock
        *num += 1;
        // lock is released when `num` goes out of scope (RAII)
    }));
}

for handle in handles {
    handle.join().unwrap();
}
println!("Final count: {}", *counter.lock().unwrap()); // 10

// Arc&lt;RwLock&lt;T&gt;&gt; &mdash; multiple readers OR one writer
let config = Arc::new(RwLock::new(String::from("initial")));

// Multiple readers can read simultaneously
let config_r1 = Arc::clone(&amp;config);
let config_r2 = Arc::clone(&amp;config);
let r1 = thread::spawn(move || {
    let val = config_r1.read().unwrap(); // shared read lock
    println!("Reader 1: {val}");
});
let r2 = thread::spawn(move || {
    let val = config_r2.read().unwrap(); // another read lock &mdash; OK
    println!("Reader 2: {val}");
});

// Writer needs exclusive access
let config_w = Arc::clone(&amp;config);
let w = thread::spawn(move || {
    let mut val = config_w.write().unwrap(); // exclusive write lock
    *val = String::from("updated");
});

r1.join().unwrap();
r2.join().unwrap();
w.join().unwrap();
println!("Config: {}", config.read().unwrap());</code></pre>
                </div>

                <!-- Message Passing -->
                <div class="subsection">
                    <h3 class="subsection-title">Message Passing: mpsc Channels</h3>
                    <p class="subsection-description">Channels provide a way to send data between threads without sharing memory. <code>mpsc</code> stands for multiple producer, single consumer. Clone the sender to create additional producers.</p>

                    <pre><code>use std::sync::mpsc;
use std::thread;

// Create a channel &mdash; returns (Sender, Receiver)
let (tx, rx) = mpsc::channel();

thread::spawn(move || {
    let messages = vec!["hello", "from", "the", "thread"];
    for msg in messages {
        tx.send(msg).unwrap();
        thread::sleep(std::time::Duration::from_millis(50));
    }
    // tx is dropped here, closing the channel
});

// Receive messages (blocks until data arrives or channel closes)
for received in rx {
    println!("Got: {received}");
}

// Multiple producers &mdash; clone the sender
let (tx, rx) = mpsc::channel();
let tx2 = tx.clone(); // second producer

thread::spawn(move || {
    tx.send("from thread 1").unwrap();
});
thread::spawn(move || {
    tx2.send("from thread 2").unwrap();
});

// Receive from both producers
for msg in rx {
    println!("{msg}");
}

// Bounded channel with sync_channel (backpressure)
let (tx, rx) = mpsc::sync_channel(3); // buffer size of 3
thread::spawn(move || {
    for i in 0..10 {
        tx.send(i).unwrap(); // blocks when buffer is full
        println!("Sent: {i}");
    }
});
for val in rx {
    println!("Received: {val}");
    thread::sleep(std::time::Duration::from_millis(100));
}</code></pre>
                </div>

                <!-- Send and Sync -->
                <div class="subsection">
                    <h3 class="subsection-title">Send and Sync Traits</h3>
                    <p class="subsection-description">These marker traits determine what can cross thread boundaries. The compiler enforces them automatically &mdash; you rarely implement them yourself, but understanding them explains many compiler errors.</p>

                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Trait</th>
                                    <th>Meaning</th>
                                    <th>Examples</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>Send</code></td>
                                    <td>Ownership can be transferred to another thread</td>
                                    <td>Most types are Send. <code>Rc&lt;T&gt;</code> is <strong>not</strong> Send</td>
                                </tr>
                                <tr>
                                    <td><code>Sync</code></td>
                                    <td><code>&amp;T</code> can be safely shared between threads</td>
                                    <td>Most types are Sync. <code>Cell&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code> are <strong>not</strong> Sync</td>
                                </tr>
                                <tr>
                                    <td><code>Send + Sync</code></td>
                                    <td>Can be both moved and shared across threads</td>
                                    <td><code>Arc&lt;Mutex&lt;T&gt;&gt;</code>, primitive types, <code>String</code></td>
                                </tr>
                                <tr>
                                    <td><code>!Send + !Sync</code></td>
                                    <td>Confined to a single thread</td>
                                    <td><code>Rc&lt;T&gt;</code>, raw pointers, <code>*const T</code></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <pre><code>use std::rc::Rc;
use std::sync::Arc;

// Rc is NOT Send &mdash; this won't compile:
// let rc = Rc::new(42);
// std::thread::spawn(move || {
//     println!("{rc}"); // ERROR: Rc&lt;i32&gt; cannot be sent between threads
// });

// Arc IS Send + Sync &mdash; use it for cross-thread sharing
let arc = Arc::new(42);
let arc_clone = Arc::clone(&amp;arc);
std::thread::spawn(move || {
    println!("{arc_clone}"); // OK: Arc is Send
}).join().unwrap();

// T: Send means we can move T into a thread
// T: Sync means &amp;T is Send (safe to share references)
// Rule: T is Sync if and only if &amp;T is Send</code></pre>
                </div>

                <!-- async/await -->
                <div class="subsection">
                    <h3 class="subsection-title">async/await &amp; the Future Trait</h3>
                    <p class="subsection-description"><code>async fn</code> returns a <code>Future</code> that does nothing until <code>.await</code>ed. Futures are lazy &mdash; they represent a value that will be available later. An async runtime (like Tokio) drives futures to completion by polling them.</p>

                    <pre><code>// async fn returns impl Future&lt;Output = T&gt;
async fn fetch_data(url: &amp;str) -&gt; Result&lt;String, reqwest::Error&gt; {
    let response = reqwest::get(url).await?;  // .await suspends until ready
    let body = response.text().await?;
    Ok(body)
}

// Futures are lazy &mdash; nothing happens until you .await
let future = fetch_data("https://example.com"); // no request yet!
let result = future.await;                       // NOW the request runs

// The Future trait (simplified)
// trait Future {
//     type Output;
//     fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context) -&gt; Poll&lt;Self::Output&gt;;
// }
// Poll is either Poll::Ready(value) or Poll::Pending

// async blocks &mdash; anonymous async expressions
let greeting = async {
    let name = get_name().await;
    format!("Hello, {name}!")
};
let message = greeting.await;

// You can use async with closures via async blocks
let tasks: Vec&lt;_&gt; = urls.iter().map(|url| {
    let url = url.to_string();
    async move {
        reqwest::get(&amp;url).await?.text().await
    }
}).collect();</code></pre>
                </div>

                <!-- Tokio Runtime -->
                <div class="subsection">
                    <h3 class="subsection-title">Tokio Runtime</h3>
                    <p class="subsection-description">Tokio is the most popular async runtime for Rust. It provides a multi-threaded scheduler, async I/O, timers, and utilities for building concurrent applications.</p>

                    <pre><code>// Cargo.toml:
// [dependencies]
// tokio = { version = "1", features = ["full"] }

// #[tokio::main] sets up the runtime and runs your async main
#[tokio::main]
async fn main() {
    println!("Running in Tokio!");

    // tokio::spawn &mdash; spawn a concurrent task (like a lightweight thread)
    let handle = tokio::spawn(async {
        // This runs concurrently on the Tokio runtime
        tokio::time::sleep(std::time::Duration::from_millis(100)).await;
        "task complete"
    });

    // JoinHandle &mdash; await to get the result
    let result = handle.await.unwrap(); // Returns Result for panic safety
    println!("{result}");

    // Spawn many tasks
    let mut handles = vec![];
    for i in 0..5 {
        handles.push(tokio::spawn(async move {
            tokio::time::sleep(std::time::Duration::from_millis(50)).await;
            i * 2
        }));
    }
    for handle in handles {
        let val = handle.await.unwrap();
        println!("Got: {val}");
    }
}</code></pre>

                    <pre><code>// tokio::select! &mdash; wait for the first of multiple futures
use tokio::time::{sleep, Duration};

async fn task_a() -&gt; &amp;'static str {
    sleep(Duration::from_millis(100)).await;
    "A finished first"
}

async fn task_b() -&gt; &amp;'static str {
    sleep(Duration::from_millis(200)).await;
    "B finished first"
}

#[tokio::main]
async fn main() {
    // select! races multiple futures, runs the first to complete
    tokio::select! {
        result = task_a() =&gt; println!("{result}"),
        result = task_b() =&gt; println!("{result}"),
    }
    // Prints: "A finished first" (task_b is cancelled)

    // tokio::join! &mdash; run multiple futures concurrently, wait for ALL
    let (a, b) = tokio::join!(task_a(), task_b());
    println!("{a}, {b}"); // waits for both to complete
}</code></pre>
                </div>

                <!-- Async Traits -->
                <div class="subsection">
                    <h3 class="subsection-title">Async Traits (Rust 1.75+)</h3>
                    <p class="subsection-description">Since Rust 1.75, you can use <code>async fn</code> directly in trait definitions without external crates like <code>async-trait</code>. This makes async interfaces first-class in the language.</p>

                    <pre><code>// Async fn in traits &mdash; stabilized in Rust 1.75
trait HttpClient {
    async fn get(&amp;self, url: &amp;str) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt;;
    async fn post(&amp;self, url: &amp;str, body: &amp;str) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt;;
}

struct MyClient;

impl HttpClient for MyClient {
    async fn get(&amp;self, url: &amp;str) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
        let resp = reqwest::get(url).await?;
        Ok(resp.text().await?)
    }

    async fn post(&amp;self, url: &amp;str, body: &amp;str) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
        let client = reqwest::Client::new();
        let resp = client.post(url).body(body.to_string()).send().await?;
        Ok(resp.text().await?)
    }
}

// Using the async trait
async fn fetch_page(client: &amp;impl HttpClient) {
    let html = client.get("https://example.com").await.unwrap();
    println!("Got {} bytes", html.len());
}

// Note: for dyn dispatch with async traits, you may still need
// the #[trait_variant::make(SendHttpClient: Send)] attribute
// or return Pin&lt;Box&lt;dyn Future&gt;&gt; manually.</code></pre>
                </div>

                <!-- Rayon -->
                <div class="subsection">
                    <h3 class="subsection-title">Rayon: Data Parallelism</h3>
                    <p class="subsection-description">Rayon makes data parallelism effortless. Replace <code>.iter()</code> with <code>.par_iter()</code> and Rayon automatically distributes work across CPU cores using a work-stealing thread pool.</p>

                    <pre><code>// Cargo.toml:
// [dependencies]
// rayon = "1"

use rayon::prelude::*;

// par_iter() &mdash; parallel immutable iteration
let numbers: Vec&lt;u64&gt; = (0..1_000_000).collect();
let sum: u64 = numbers.par_iter().sum();
println!("Sum: {sum}");

// par_iter() with map and filter
let results: Vec&lt;u64&gt; = numbers.par_iter()
    .filter(|&amp;&amp;n| n % 2 == 0)
    .map(|&amp;n| n * n)
    .collect();

// par_iter_mut() &mdash; parallel mutable iteration
let mut data: Vec&lt;f64&gt; = vec![1.0; 1_000_000];
data.par_iter_mut().for_each(|x| {
    *x = (*x * 2.5).sqrt();
});

// par_chunks() &mdash; process in parallel chunks
let pixels: Vec&lt;u8&gt; = vec![0; 1920 * 1080 * 4];
let brightened: Vec&lt;u8&gt; = pixels.par_chunks(4)
    .flat_map(|rgba| {
        [rgba[0].saturating_add(10),
         rgba[1].saturating_add(10),
         rgba[2].saturating_add(10),
         rgba[3]]
    })
    .collect();

// par_sort &mdash; parallel sorting
let mut data: Vec&lt;i32&gt; = (0..1_000_000).rev().collect();
data.par_sort(); // significantly faster than data.sort() for large collections

// Parallel string processing
let words = vec!["hello", "world", "foo", "bar", "baz"];
let upper: Vec&lt;String&gt; = words.par_iter()
    .map(|w| w.to_uppercase())
    .collect();</code></pre>
                </div>

                <!-- When to Use What -->
                <div class="subsection">
                    <h3 class="subsection-title">Threads vs Async vs Rayon</h3>
                    <p class="subsection-description">Choosing the right concurrency model depends on your workload. Here is a guide for when to reach for each approach.</p>

                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Approach</th>
                                    <th>Best For</th>
                                    <th>Overhead</th>
                                    <th>Scales To</th>
                                    <th>Example Use Cases</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>std::thread</code></td>
                                    <td>Simple parallel work, background tasks</td>
                                    <td>~8 KB stack per thread</td>
                                    <td>Dozens of threads</td>
                                    <td>Background file watcher, producer/consumer</td>
                                </tr>
                                <tr>
                                    <td><code>Tokio (async)</code></td>
                                    <td>I/O-bound work: network, disk, timers</td>
                                    <td>~200 bytes per task</td>
                                    <td>Millions of tasks</td>
                                    <td>Web servers, HTTP clients, database queries</td>
                                </tr>
                                <tr>
                                    <td><code>Rayon</code></td>
                                    <td>CPU-bound data parallelism</td>
                                    <td>Thread pool (num CPUs)</td>
                                    <td>All CPU cores</td>
                                    <td>Image processing, number crunching, sorting</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <div class="alert alert-warning">
                        <h4>Choosing Your Concurrency Model</h4>
                        <p><strong>CPU-bound work</strong> (computation, data processing) &rarr; <strong>Rayon</strong>. <strong>I/O-bound work</strong> (networking, file I/O, databases) &rarr; <strong>Tokio</strong>. <strong>Simple parallel work</strong> (a few background threads) &rarr; <strong>std::thread</strong>. When in doubt: if you are processing a collection in parallel, use Rayon. If you are waiting on external resources, use Tokio. If you just need one or two background workers, use <code>std::thread</code>.</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- ============================================
             SECTION 11: CARGO & ECOSYSTEM
             ============================================ -->
        <section id="ecosystem" class="section">
            <div class="container">
                <div class="section-header">
                    <div class="section-number">11</div>
                    <h2 class="section-title">Cargo &amp; Ecosystem</h2>
                    <div class="section-line"></div>
                    <p class="section-description">Cargo is Rust's build system, package manager, and project orchestrator. Combined with the rich crate ecosystem on crates.io, it provides everything from testing and documentation to workspaces and feature flags.</p>
                </div>

                <!-- Cargo Deep Dive -->
                <div class="subsection">
                    <h3 class="subsection-title">Cargo Deep Dive: Features, Workspaces &amp; Profiles</h3>
                    <p class="subsection-description">Cargo supports workspaces for multi-crate projects, build profiles for optimization control, and a feature system for conditional compilation.</p>

                    <pre><code># Build profiles &mdash; dev (debug) and release are built-in
cargo build              # dev profile: fast compile, no optimizations
cargo build --release    # release profile: slow compile, full optimizations

# Custom profile in Cargo.toml
# [profile.dev]
# opt-level = 0          # no optimization (fast compile)
# debug = true           # include debug info
#
# [profile.release]
# opt-level = 3          # maximum optimization
# lto = true             # link-time optimization
# codegen-units = 1      # slower compile, better optimization
# strip = true           # strip debug symbols from binary

# Workspaces &mdash; multiple crates in one repository
# Root Cargo.toml:
# [workspace]
# members = [
#     "crates/core",
#     "crates/api",
#     "crates/cli",
# ]
# [workspace.dependencies]
# serde = { version = "1", features = ["derive"] }
# tokio = { version = "1", features = ["full"] }

# Member crates inherit workspace dependencies:
# [dependencies]
# serde = { workspace = true }

# Build specific workspace member
cargo build -p core
cargo test -p api
cargo run -p cli</code></pre>
                </div>

                <!-- Feature Flags -->
                <div class="subsection">
                    <h3 class="subsection-title">Cargo.toml Features System</h3>
                    <p class="subsection-description">Features let you conditionally compile code and enable optional dependencies. Users of your crate choose which features to activate.</p>

                    <pre><code># Cargo.toml &mdash; defining features
# [features]
# default = ["json"]        # enabled unless the user opts out
# json = ["dep:serde_json"] # enables the serde_json dependency
# xml = ["dep:quick-xml"]   # enables the quick-xml dependency
# full = ["json", "xml"]    # meta-feature that enables others
#
# [dependencies]
# serde = "1"
# serde_json = { version = "1", optional = true }
# quick-xml = { version = "0.31", optional = true }

# Using features in code with cfg attributes
#[cfg(feature = "json")]
pub fn parse_json(input: &amp;str) -&gt; serde_json::Value {
    serde_json::from_str(input).unwrap()
}

#[cfg(feature = "xml")]
pub fn parse_xml(input: &amp;str) -&gt; String {
    // XML parsing logic
    todo!()
}

// Conditional compilation in expressions
fn serialize(data: &amp;MyStruct) -&gt; String {
    #[cfg(feature = "json")]
    { return serde_json::to_string(data).unwrap(); }

    #[cfg(not(feature = "json"))]
    { return format!("{data:?}"); }
}

# Adding a crate with specific features
# cargo add tokio --features full
# cargo add serde --features derive
# cargo add my-crate --no-default-features --features json</code></pre>
                </div>

                <!-- Testing -->
                <div class="subsection">
                    <h3 class="subsection-title">Testing</h3>
                    <p class="subsection-description">Rust has first-class testing built into the language and toolchain. Unit tests live alongside your code, integration tests go in a <code>tests/</code> directory, and doc tests run code examples from documentation comments.</p>

                    <pre><code>// Unit tests &mdash; live in the same file as the code they test
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

pub fn divide(a: f64, b: f64) -&gt; Result&lt;f64, String&gt; {
    if b == 0.0 {
        Err("Division by zero".into())
    } else {
        Ok(a / b)
    }
}

#[cfg(test)]  // only compiled when running tests
mod tests {
    use super::*; // import everything from parent module

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
    }

    #[test]
    fn test_add_negative() {
        assert_eq!(add(-1, 1), 0);
    }

    #[test]
    fn test_divide() {
        let result = divide(10.0, 3.0).unwrap();
        assert!((result - 3.333).abs() &lt; 0.01);
    }

    #[test]
    fn test_divide_by_zero() {
        assert!(divide(1.0, 0.0).is_err());
    }

    #[test]
    #[should_panic(expected = "index out of bounds")]
    fn test_panic() {
        let v = vec![1, 2, 3];
        let _ = v[99]; // panics
    }

    #[test]
    fn test_with_result() -&gt; Result&lt;(), String&gt; {
        let result = divide(10.0, 2.0)?;
        assert_eq!(result, 5.0);
        Ok(()) // test passes if Ok is returned
    }
}</code></pre>

                    <pre><code>// Integration tests &mdash; live in tests/ directory (separate crate)
// tests/integration_test.rs
use my_crate::add;

#[test]
fn test_add_integration() {
    assert_eq!(add(100, 200), 300);
}

// Doc tests &mdash; code in documentation comments is tested automatically
/// Adds two numbers together.
///
/// # Examples
///
/// ```
/// let result = my_crate::add(2, 3);
/// assert_eq!(result, 5);
/// ```
///
/// ```
/// // Negative numbers work too
/// assert_eq!(my_crate::add(-1, 1), 0);
/// ```
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

// Running tests:
// cargo test                     &mdash; run all tests
// cargo test test_add            &mdash; run tests matching "test_add"
// cargo test --lib               &mdash; only unit tests
// cargo test --test integration  &mdash; only integration tests
// cargo test --doc               &mdash; only doc tests
// cargo test -- --nocapture      &mdash; show println! output</code></pre>
                </div>

                <!-- Modules and Visibility -->
                <div class="subsection">
                    <h3 class="subsection-title">Modules &amp; Visibility</h3>
                    <p class="subsection-description">Rust's module system controls code organization and visibility. Items are private by default. Use <code>pub</code> and its variants to expose what you need.</p>

                    <pre><code>// Declaring modules
mod math {
    // Everything inside is private by default
    fn internal_helper() -&gt; i32 { 42 }

    pub fn add(a: i32, b: i32) -&gt; i32 { a + b }

    // pub(crate) &mdash; visible within the entire crate but not to external users
    pub(crate) fn crate_only() -&gt; &amp;'static str { "internal API" }

    // pub(super) &mdash; visible to the parent module only
    pub(super) fn parent_only() -&gt; &amp;'static str { "parent can see me" }

    // Nested modules
    pub mod advanced {
        pub fn multiply(a: i32, b: i32) -&gt; i32 { a * b }

        // Can access parent's private items with super::
        pub fn add_and_multiply(a: i32, b: i32) -&gt; i32 {
            super::add(a, b) * 2
        }
    }
}

// Using modules
use math::add;
use math::advanced::multiply;
let sum = add(1, 2);
let product = multiply(3, 4);

// Module file structure (modern style &mdash; preferred since Rust 2018)
// src/
// ├── main.rs           (or lib.rs)
// ├── math.rs           &larr; mod math;
// └── math/
//     └── advanced.rs   &larr; pub mod advanced; (inside math.rs)

// Legacy style (still works, less preferred)
// src/
// ├── main.rs
// └── math/
//     ├── mod.rs        &larr; mod math;
//     └── advanced.rs   &larr; pub mod advanced; (inside mod.rs)

// Re-exporting with pub use
mod internal {
    pub struct Config { pub name: String }
}
pub use internal::Config; // users can import Config directly</code></pre>
                </div>

                <!-- Smart Pointers -->
                <div class="subsection">
                    <h3 class="subsection-title">Smart Pointers</h3>
                    <p class="subsection-description">Smart pointers own heap data and provide extra capabilities beyond regular references. Each serves a different use case for ownership, sharing, and interior mutability.</p>

                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Type</th>
                                    <th>Purpose</th>
                                    <th>Thread Safe?</th>
                                    <th>When to Use</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>Box&lt;T&gt;</code></td>
                                    <td>Heap allocation, single owner</td>
                                    <td><span class="badge badge-verdigris">Yes</span> (if T: Send)</td>
                                    <td>Recursive types, large data, trait objects</td>
                                </tr>
                                <tr>
                                    <td><code>Rc&lt;T&gt;</code></td>
                                    <td>Reference-counted shared ownership</td>
                                    <td><span class="badge badge-copper">No</span></td>
                                    <td>Multiple owners, single thread only</td>
                                </tr>
                                <tr>
                                    <td><code>Arc&lt;T&gt;</code></td>
                                    <td>Atomic reference-counted sharing</td>
                                    <td><span class="badge badge-verdigris">Yes</span></td>
                                    <td>Multiple owners across threads</td>
                                </tr>
                                <tr>
                                    <td><code>RefCell&lt;T&gt;</code></td>
                                    <td>Interior mutability (runtime borrow check)</td>
                                    <td><span class="badge badge-copper">No</span></td>
                                    <td>Mutate through shared references (single thread)</td>
                                </tr>
                                <tr>
                                    <td><code>Cell&lt;T&gt;</code></td>
                                    <td>Interior mutability for Copy types</td>
                                    <td><span class="badge badge-copper">No</span></td>
                                    <td>Simple counters, flags in shared contexts</td>
                                </tr>
                                <tr>
                                    <td><code>Cow&lt;'a, T&gt;</code></td>
                                    <td>Clone-on-write: borrowed or owned</td>
                                    <td><span class="badge badge-verdigris">Yes</span> (if T: Send)</td>
                                    <td>Avoid cloning when mutation is rare</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <pre><code>use std::cell::RefCell;
use std::rc::Rc;
use std::borrow::Cow;

// Box &mdash; heap allocation, recursive types
enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}
let list = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));

// Box for trait objects
let shapes: Vec&lt;Box&lt;dyn Shape&gt;&gt; = vec![
    Box::new(Circle { radius: 5.0 }),
    Box::new(Rect { w: 3.0, h: 4.0 }),
];

// Rc &mdash; shared ownership (single-threaded)
let data = Rc::new(vec![1, 2, 3]);
let clone1 = Rc::clone(&amp;data); // increment ref count, not deep copy
let clone2 = Rc::clone(&amp;data);
println!("Ref count: {}", Rc::strong_count(&amp;data)); // 3

// Rc&lt;RefCell&lt;T&gt;&gt; &mdash; shared + mutable (single-threaded)
let shared = Rc::new(RefCell::new(vec![1, 2, 3]));
shared.borrow_mut().push(4);          // runtime borrow check
println!("{:?}", shared.borrow());     // [1, 2, 3, 4]

// Cow &mdash; clone only when needed
fn process(input: &amp;str) -&gt; Cow&lt;'_, str&gt; {
    if input.contains("bad") {
        Cow::Owned(input.replace("bad", "good")) // allocates only if needed
    } else {
        Cow::Borrowed(input) // zero-cost: just borrows the input
    }
}</code></pre>
                </div>

                <!-- Collections -->
                <div class="subsection">
                    <h3 class="subsection-title">Collections Overview</h3>
                    <p class="subsection-description">Rust's standard library provides several high-performance collection types. Here are the most commonly used ones.</p>

                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Collection</th>
                                    <th>Description</th>
                                    <th>Access</th>
                                    <th>Use When</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>Vec&lt;T&gt;</code></td>
                                    <td>Growable array (contiguous memory)</td>
                                    <td>O(1) index, O(1) amortized push</td>
                                    <td>Default sequential collection</td>
                                </tr>
                                <tr>
                                    <td><code>HashMap&lt;K, V&gt;</code></td>
                                    <td>Hash table (key-value pairs)</td>
                                    <td>O(1) average lookup/insert</td>
                                    <td>Key-value lookups, counting, caching</td>
                                </tr>
                                <tr>
                                    <td><code>HashSet&lt;T&gt;</code></td>
                                    <td>Hash set (unique values)</td>
                                    <td>O(1) average contains/insert</td>
                                    <td>Membership testing, deduplication</td>
                                </tr>
                                <tr>
                                    <td><code>BTreeMap&lt;K, V&gt;</code></td>
                                    <td>Sorted map (B-tree)</td>
                                    <td>O(log n) lookup/insert</td>
                                    <td>Need sorted keys, range queries</td>
                                </tr>
                                <tr>
                                    <td><code>VecDeque&lt;T&gt;</code></td>
                                    <td>Double-ended queue (ring buffer)</td>
                                    <td>O(1) push/pop front and back</td>
                                    <td>Queue or deque semantics</td>
                                </tr>
                                <tr>
                                    <td><code>BinaryHeap&lt;T&gt;</code></td>
                                    <td>Max-heap priority queue</td>
                                    <td>O(log n) push/pop, O(1) peek</td>
                                    <td>Priority queues, top-N problems</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <pre><code>use std::collections::{HashMap, HashSet, BTreeMap, VecDeque, BinaryHeap};

// Vec &mdash; the workhorse collection
let mut v = vec![1, 2, 3];
v.push(4);
v.extend([5, 6, 7]);
let third = v[2];           // panics if out of bounds
let safe = v.get(99);       // returns Option&lt;&amp;T&gt;

// HashMap &mdash; key-value store
let mut scores: HashMap&lt;&amp;str, i32&gt; = HashMap::new();
scores.insert("Alice", 100);
scores.insert("Bob", 85);
scores.entry("Charlie").or_insert(0); // insert if absent
*scores.entry("Alice").or_insert(0) += 10; // modify in place

// HashSet &mdash; unique values
let mut seen = HashSet::new();
seen.insert("apple");
seen.insert("banana");
seen.insert("apple"); // no effect &mdash; already present
println!("Contains apple: {}", seen.contains("apple"));

// BTreeMap &mdash; sorted by key
let mut ordered = BTreeMap::new();
ordered.insert(3, "three");
ordered.insert(1, "one");
ordered.insert(2, "two");
for (k, v) in &amp;ordered {
    println!("{k}: {v}"); // prints in key order: 1, 2, 3
}

// VecDeque &mdash; efficient push/pop at both ends
let mut deque = VecDeque::new();
deque.push_back(1);
deque.push_front(0);
deque.push_back(2);
println!("{:?}", deque); // [0, 1, 2]

// BinaryHeap &mdash; max-heap
let mut heap = BinaryHeap::from(vec![3, 1, 4, 1, 5]);
println!("Max: {:?}", heap.peek()); // Some(5)
while let Some(val) = heap.pop() {
    print!("{val} "); // 5 4 3 1 1
}</code></pre>
                </div>

                <!-- Essential Crates -->
                <div class="subsection">
                    <h3 class="subsection-title">Essential Crates</h3>
                    <p class="subsection-description">The Rust ecosystem has a rich set of high-quality crates for common tasks. These are the most widely used and recommended libraries.</p>

                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Crate</th>
                                    <th>Purpose</th>
                                    <th>Key Feature</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>serde</code></td>
                                    <td>Serialization / deserialization framework</td>
                                    <td><code>#[derive(Serialize, Deserialize)]</code> for JSON, TOML, YAML, etc.</td>
                                </tr>
                                <tr>
                                    <td><code>tokio</code></td>
                                    <td>Async runtime (networking, I/O, timers)</td>
                                    <td><code>#[tokio::main]</code>, spawn, channels, timers</td>
                                </tr>
                                <tr>
                                    <td><code>clap</code></td>
                                    <td>Command-line argument parsing</td>
                                    <td><code>#[derive(Parser)]</code> for declarative CLI definitions</td>
                                </tr>
                                <tr>
                                    <td><code>reqwest</code></td>
                                    <td>HTTP client (async and blocking)</td>
                                    <td>Ergonomic API for GET, POST, JSON, file uploads</td>
                                </tr>
                                <tr>
                                    <td><code>sqlx</code></td>
                                    <td>Async SQL toolkit (compile-time checked queries)</td>
                                    <td><code>sqlx::query!</code> verifies SQL at compile time against your DB</td>
                                </tr>
                                <tr>
                                    <td><code>axum</code></td>
                                    <td>Web framework (built on Tokio + Tower)</td>
                                    <td>Ergonomic routing, extractors, middleware via Tower</td>
                                </tr>
                                <tr>
                                    <td><code>tracing</code></td>
                                    <td>Structured logging and diagnostics</td>
                                    <td>Spans, events, async-aware structured logs</td>
                                </tr>
                                <tr>
                                    <td><code>rayon</code></td>
                                    <td>Data parallelism</td>
                                    <td><code>.par_iter()</code> for effortless parallel processing</td>
                                </tr>
                                <tr>
                                    <td><code>regex</code></td>
                                    <td>Regular expressions</td>
                                    <td>Fast, safe regex engine with compile-time validation via <code>Regex::new</code></td>
                                </tr>
                                <tr>
                                    <td><code>chrono</code></td>
                                    <td>Date and time handling</td>
                                    <td>Timezone-aware datetime, parsing, formatting</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Macros -->
                <div class="subsection">
                    <h3 class="subsection-title">Macros</h3>
                    <p class="subsection-description">Macros generate code at compile time. Declarative macros (<code>macro_rules!</code>) use pattern matching on syntax. Derive macros automatically implement traits for your types.</p>

                    <pre><code>// macro_rules! &mdash; declarative macros
macro_rules! say_hello {
    () =&gt; {
        println!("Hello!");
    };
    ($name:expr) =&gt; {
        println!("Hello, {}!", $name);
    };
}
say_hello!();          // "Hello!"
say_hello!("Ferris");  // "Hello, Ferris!"

// Repetition with $(...)*
macro_rules! vec_of_strings {
    ($($s:expr),* $(,)?) =&gt; {
        vec![$($s.to_string()),*]
    };
}
let names = vec_of_strings!["Alice", "Bob", "Charlie"];

// A more useful example: a hashmap literal macro
macro_rules! hashmap {
    ($($key:expr =&gt; $val:expr),* $(,)?) =&gt; {{
        let mut map = std::collections::HashMap::new();
        $(map.insert($key, $val);)*
        map
    }};
}
let scores = hashmap! {
    "Alice" =&gt; 100,
    "Bob" =&gt; 85,
    "Charlie" =&gt; 92,
};

// Common fragment specifiers:
// $x:expr   &mdash; expression (1 + 2, foo(), "hello")
// $x:ident  &mdash; identifier (variable name, function name)
// $x:ty     &mdash; type (i32, Vec&lt;String&gt;)
// $x:pat    &mdash; pattern (Some(x), (a, b))
// $x:stmt   &mdash; statement (let x = 5;)
// $x:tt     &mdash; single token tree (most flexible)</code></pre>

                    <pre><code>// Derive macros &mdash; auto-implement traits
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
struct User {
    name: String,
    age: u32,
}

// Common derives and what they give you:
// Debug         &mdash; {:?} formatting for println!/dbg!
// Clone         &mdash; .clone() deep copy
// Copy          &mdash; implicit bitwise copy (only for small stack types)
// PartialEq     &mdash; == and != comparison
// Eq            &mdash; marker that PartialEq is total (reflexive)
// Hash          &mdash; can be used as HashMap/HashSet key
// Default       &mdash; Type::default() returns a zero/empty value
// PartialOrd    &mdash; &lt;, &gt;, &lt;=, &gt;= comparison
// Ord           &mdash; total ordering (required for BTreeMap keys)

// Serde derives (from the serde crate)
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize)]
struct Config {
    name: String,
    port: u16,
    #[serde(default)]
    debug: bool,
    #[serde(rename = "maxRetries")]
    max_retries: u32,
}

let json = r#"{"name":"app","port":8080,"maxRetries":3}"#;
let config: Config = serde_json::from_str(json).unwrap();
let back_to_json = serde_json::to_string_pretty(&amp;config).unwrap();</code></pre>
                </div>
            </div>
        </section>

        <!-- ============================================
             SECTION 12: TIPS & TRICKS
             ============================================ -->
        <section id="tips" class="section">
            <div class="container">
                <div class="section-header">
                    <div class="section-number">12</div>
                    <h2 class="section-title">Tips &amp; Tricks</h2>
                    <div class="section-line"></div>
                    <p class="section-description">Practical tips, useful patterns, and productivity boosters for writing idiomatic and performant Rust code.</p>
                </div>

                <!-- Turbofish -->
                <div class="subsection">
                    <h3 class="subsection-title">Turbofish Syntax (<code>::&lt;&gt;</code>)</h3>
                    <p class="subsection-description">The turbofish <code>::&lt;&gt;</code> lets you explicitly specify type parameters on functions and methods when the compiler cannot infer them. The name comes from its resemblance to a fish: <code>::&lt;&gt;</code>.</p>

                    <pre><code>// When the compiler can't infer the type, use turbofish
let numbers = "1 2 3 4 5";
let parsed: Vec&lt;i32&gt; = numbers.split(' ')
    .map(|s| s.parse::&lt;i32&gt;().unwrap())  // turbofish on parse
    .collect();

// Equivalent: specify the collection type instead
let parsed = numbers.split(' ')
    .map(|s| s.parse::&lt;i32&gt;().unwrap())
    .collect::&lt;Vec&lt;_&gt;&gt;();  // turbofish on collect

// You need turbofish when:
// 1. The return type alone can't determine the generic parameter
let x = "42".parse::&lt;i32&gt;().unwrap();
let y = "3.14".parse::&lt;f64&gt;().unwrap();

// 2. Calling a generic function with ambiguous type
fn create&lt;T: Default&gt;() -&gt; T { T::default() }
let s = create::&lt;String&gt;();
let n = create::&lt;i32&gt;();

// 3. On collect when the target type isn't otherwise constrained
let set = vec![1, 2, 2, 3].into_iter().collect::&lt;std::collections::HashSet&lt;_&gt;&gt;();</code></pre>
                </div>

                <!-- dbg! macro -->
                <div class="subsection">
                    <h3 class="subsection-title">dbg!() Macro for Quick Debugging</h3>
                    <p class="subsection-description"><code>dbg!()</code> prints the file, line number, expression, and its value to stderr, then returns the value. It is perfect for quick debugging without disrupting data flow.</p>

                    <pre><code>let a = 2;
let b = dbg!(a * 3);      // prints: [src/main.rs:2] a * 3 = 6
// b is now 6 &mdash; dbg! returns the value

// Works in chains without breaking them
let result = dbg!(vec![1, 2, 3])
    .iter()
    .map(|x| dbg!(x * 2))
    .sum::&lt;i32&gt;();
dbg!(result);

// Multiple values
dbg!(a, b, result);
// [src/main.rs:10] a = 2
// [src/main.rs:10] b = 6
// [src/main.rs:10] result = 12

// Tip: dbg! requires Debug trait. It goes to stderr (not stdout)
// so it won't interfere with program output.
// Remove all dbg!() calls before committing!</code></pre>
                </div>

                <!-- Useful Attributes -->
                <div class="subsection">
                    <h3 class="subsection-title">Useful Attributes</h3>
                    <p class="subsection-description">Attributes annotate items with metadata that affects compilation, linting, and behavior. Here are the most practical ones.</p>

                    <pre><code>// #[must_use] &mdash; warn if the return value is ignored
#[must_use = "this Result may contain an error that should be handled"]
fn connect(url: &amp;str) -&gt; Result&lt;Connection, Error&gt; { /* ... */ }

connect("localhost"); // WARNING: unused Result that must be used

// #[non_exhaustive] &mdash; prevent external code from exhaustively matching
#[non_exhaustive]
pub enum Error {
    NotFound,
    PermissionDenied,
    // Future variants can be added without breaking external code
}
// External match must have a _ wildcard arm

// #[allow(...)] / #[deny(...)] / #[warn(...)] &mdash; control lints
#[allow(dead_code)]        // suppress unused code warnings
#[allow(unused_variables)] // suppress unused variable warnings
fn experimental() { let x = 42; }

#[deny(unsafe_code)]       // make any unsafe code a compile error
mod safe_module { /* ... */ }

// #[cfg(...)] &mdash; conditional compilation
#[cfg(target_os = "linux")]
fn linux_only() { println!("Linux!"); }

#[cfg(test)]
mod tests { /* ... */ }

#[cfg(debug_assertions)]
fn debug_only_check() { /* runs only in debug builds */ }

#[cfg(feature = "advanced")]
pub mod advanced { /* compiled only when feature is enabled */ }

// #[inline] &mdash; hint the compiler to inline a function
#[inline]
fn small_helper(x: i32) -&gt; i32 { x + 1 }

#[inline(always)] // force inlining (use sparingly)
fn critical_path(x: i32) -&gt; i32 { x * 2 }</code></pre>
                </div>

                <!-- Cargo Aliases & Flags -->
                <div class="subsection">
                    <h3 class="subsection-title">Cargo Aliases &amp; RUSTFLAGS</h3>
                    <p class="subsection-description">Configure Cargo with custom aliases and compiler flags for a smoother development workflow.</p>

                    <pre><code># .cargo/config.toml &mdash; project-level Cargo configuration
# [alias]
# t = "test"
# r = "run"
# c = "check"
# cl = "clippy -- -W clippy::pedantic"
# b = "build --release"
# w = "watch -x check -x test"    # requires cargo-watch

# Now you can run:
# cargo t          &rarr; cargo test
# cargo cl         &rarr; cargo clippy with pedantic lints

# RUSTFLAGS &mdash; pass flags to the Rust compiler
# RUSTFLAGS="-D warnings" cargo build    # treat all warnings as errors
# RUSTFLAGS="-C target-cpu=native" cargo build --release  # optimize for your CPU

# Useful clippy flags
cargo clippy -- -W clippy::pedantic           # enable pedantic lints
cargo clippy -- -W clippy::nursery            # experimental lints
cargo clippy -- -A clippy::must_use_candidate # allow specific lint
cargo clippy --fix                             # auto-fix what it can

# Per-project lint configuration in Cargo.toml:
# [lints.clippy]
# pedantic = "warn"
# cast_possible_truncation = "allow"
# module_name_repetitions = "allow"</code></pre>
                </div>

                <!-- Performance Tips -->
                <div class="subsection">
                    <h3 class="subsection-title">Performance Tips</h3>
                    <p class="subsection-description">Squeezing maximum performance from Rust requires the right build settings and awareness of common optimization opportunities.</p>

                    <pre><code># Cargo.toml &mdash; release profile for maximum performance
# [profile.release]
# opt-level = 3          # max optimization
# lto = true             # link-time optimization (slower build, faster binary)
# codegen-units = 1      # single codegen unit (slower build, better optimization)
# panic = "abort"        # smaller binary, no unwinding overhead
# strip = true           # strip debug symbols

# Build with native CPU instructions
# RUSTFLAGS="-C target-cpu=native" cargo build --release

# Profile-guided optimization (PGO)
# 1. Build instrumented binary:
#    RUSTFLAGS="-Cprofile-generate=/tmp/pgo" cargo build --release
# 2. Run with typical workload to generate profile data
# 3. Build optimized binary:
#    RUSTFLAGS="-Cprofile-use=/tmp/pgo/merged.profdata" cargo build --release</code></pre>

                    <pre><code>// Code-level performance tips

// Preallocate collections when size is known
let mut v = Vec::with_capacity(1000); // avoid repeated reallocations
for i in 0..1000 { v.push(i); }

// Use iterators instead of index loops (often optimized better)
let sum: i32 = v.iter().sum();        // idiomatic, vectorizable
// vs: for i in 0..v.len() { sum += v[i]; }  // bounds checks each access

// Avoid unnecessary clones
fn process(data: &amp;str) { /* ... */ }  // borrow instead of clone
// fn process(data: String) { ... }   // forces caller to clone or give up ownership

// Use &amp;str instead of &amp;String in function params
fn greet(name: &amp;str) {}               // accepts both &amp;String and &amp;str

// Prefer stack allocation (arrays) over heap (Vec) for small fixed sizes
let buffer: [u8; 256] = [0; 256];    // stack allocated
// let buffer = vec![0u8; 256];      // heap allocated

// Use Box&lt;[T]&gt; instead of Vec&lt;T&gt; for fixed-size heap data
let boxed: Box&lt;[i32]&gt; = vec![1, 2, 3].into_boxed_slice(); // no capacity overhead</code></pre>
                </div>

                <!-- Design Patterns -->
                <div class="subsection">
                    <h3 class="subsection-title">Common Design Patterns</h3>
                    <p class="subsection-description">Idiomatic Rust patterns that leverage the type system for safer, more expressive APIs.</p>

                    <pre><code>// Builder Pattern &mdash; ergonomic construction of complex objects
struct Server {
    host: String,
    port: u16,
    max_connections: usize,
    timeout_secs: u64,
}

struct ServerBuilder {
    host: String,
    port: u16,
    max_connections: usize,
    timeout_secs: u64,
}

impl ServerBuilder {
    fn new(host: impl Into&lt;String&gt;) -&gt; Self {
        ServerBuilder {
            host: host.into(),
            port: 8080,          // sensible defaults
            max_connections: 100,
            timeout_secs: 30,
        }
    }
    fn port(mut self, port: u16) -&gt; Self { self.port = port; self }
    fn max_connections(mut self, n: usize) -&gt; Self { self.max_connections = n; self }
    fn timeout(mut self, secs: u64) -&gt; Self { self.timeout_secs = secs; self }
    fn build(self) -&gt; Server {
        Server {
            host: self.host,
            port: self.port,
            max_connections: self.max_connections,
            timeout_secs: self.timeout_secs,
        }
    }
}

let server = ServerBuilder::new("localhost")
    .port(3000)
    .max_connections(500)
    .timeout(60)
    .build();</code></pre>

                    <pre><code>// Newtype Pattern &mdash; type safety through wrapping
struct UserId(u64);
struct OrderId(u64);

// These are different types &mdash; can't accidentally mix them!
fn get_user(id: UserId) { /* ... */ }
fn get_order(id: OrderId) { /* ... */ }
// get_user(OrderId(42));  // ERROR: expected UserId, found OrderId

// Typestate Pattern &mdash; encode state in the type system
struct Locked;
struct Unlocked;

struct Door&lt;State&gt; {
    _state: std::marker::PhantomData&lt;State&gt;,
}

impl Door&lt;Locked&gt; {
    fn unlock(self) -&gt; Door&lt;Unlocked&gt; {
        println!("Door unlocked");
        Door { _state: std::marker::PhantomData }
    }
}

impl Door&lt;Unlocked&gt; {
    fn open(&amp;self) { println!("Door opened"); }
    fn lock(self) -&gt; Door&lt;Locked&gt; {
        println!("Door locked");
        Door { _state: std::marker::PhantomData }
    }
}

let door: Door&lt;Locked&gt; = Door { _state: std::marker::PhantomData };
// door.open();          // ERROR: no method `open` for Door&lt;Locked&gt;
let door = door.unlock(); // transition to Unlocked state
door.open();              // OK: Door&lt;Unlocked&gt; has open()</code></pre>
                </div>

                <!-- unsafe -->
                <div class="subsection">
                    <h3 class="subsection-title">unsafe Basics</h3>
                    <p class="subsection-description"><code>unsafe</code> does not disable the borrow checker &mdash; it unlocks five specific capabilities that the compiler cannot verify. Use it only when necessary, and keep unsafe blocks as small as possible.</p>

                    <pre><code>// What unsafe permits (and ONLY these five things):
// 1. Dereference raw pointers
// 2. Call unsafe functions or methods
// 3. Access mutable static variables
// 4. Implement unsafe traits
// 5. Access fields of unions

// Raw pointers &mdash; *const T and *mut T
let mut x = 42;
let r1 = &amp;x as *const i32;       // creating raw pointer is safe
let r2 = &amp;mut x as *mut i32;
unsafe {
    println!("r1 = {}", *r1);    // dereferencing requires unsafe
    *r2 = 99;                     // writing through raw pointer
    println!("r2 = {}", *r2);
}

// Calling unsafe functions (e.g., FFI)
extern "C" {
    fn abs(input: i32) -&gt; i32;
}
let result = unsafe { abs(-42) }; // calling C function

// Safe wrapper around unsafe code (common pattern)
fn safe_abs(x: i32) -&gt; i32 {
    unsafe { abs(x) }
}

// When you need unsafe:
// - FFI (calling C libraries)
// - Performance-critical code where bounds checks are too expensive
// - Implementing low-level data structures (e.g., linked lists)
// - Interfacing with hardware or OS APIs

// Golden rule: encapsulate unsafe in a safe API
// and document the safety invariants</code></pre>
                </div>

                <!-- Edition Migration -->
                <div class="subsection">
                    <h3 class="subsection-title">Rust Edition Migration</h3>
                    <p class="subsection-description">Rust editions (2015, 2018, 2021, 2024) introduce new syntax and behavior. Editions are opt-in and backward-compatible &mdash; crates on different editions interoperate seamlessly.</p>

                    <pre><code># Check your current edition in Cargo.toml:
# [package]
# edition = "2021"

# Migrate to a new edition
cargo fix --edition          # auto-fix code for the next edition
# Then manually update Cargo.toml:
# edition = "2024"

# Key edition changes:
# 2018: module path changes, async/await, dyn Trait required
# 2021: disjoint capture in closures, IntoIterator for arrays
# 2024: gen blocks, unsafe_op_in_unsafe_fn lint, RPITIT refinement

# Edition does NOT affect the language version &mdash; only syntax/semantics
# A Rust 1.85 compiler can build crates using edition 2015, 2018, 2021, or 2024
# Different crates in a workspace can use different editions</code></pre>
                </div>

                <!-- Cargo Subcommands -->
                <div class="subsection">
                    <h3 class="subsection-title">Useful Cargo Subcommands</h3>
                    <p class="subsection-description">Extend Cargo with community-built tools. Install with <code>cargo install</code>.</p>

                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Command</th>
                                    <th>Install</th>
                                    <th>Purpose</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>cargo expand</code></td>
                                    <td><code>cargo install cargo-expand</code></td>
                                    <td>Show expanded macro output (see what macros generate)</td>
                                </tr>
                                <tr>
                                    <td><code>cargo tree</code></td>
                                    <td>Built-in</td>
                                    <td>Visualize dependency tree, find duplicate deps</td>
                                </tr>
                                <tr>
                                    <td><code>cargo audit</code></td>
                                    <td><code>cargo install cargo-audit</code></td>
                                    <td>Check dependencies for known security vulnerabilities</td>
                                </tr>
                                <tr>
                                    <td><code>cargo deny</code></td>
                                    <td><code>cargo install cargo-deny</code></td>
                                    <td>Lint dependencies for licenses, bans, advisories</td>
                                </tr>
                                <tr>
                                    <td><code>cargo watch</code></td>
                                    <td><code>cargo install cargo-watch</code></td>
                                    <td>Auto-rebuild on file changes (<code>cargo watch -x check</code>)</td>
                                </tr>
                                <tr>
                                    <td><code>cargo flamegraph</code></td>
                                    <td><code>cargo install flamegraph</code></td>
                                    <td>Generate flamegraph profiles for performance analysis</td>
                                </tr>
                                <tr>
                                    <td><code>cargo nextest</code></td>
                                    <td><code>cargo install cargo-nextest</code></td>
                                    <td>Faster test runner with better output and parallelism</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <pre><code># Useful cargo tree commands
cargo tree                          # full dependency tree
cargo tree -d                       # show only duplicate dependencies
cargo tree -i regex                 # show what depends on regex
cargo tree --depth 1                # top-level dependencies only

# cargo watch examples
cargo watch -x check                # recheck on save
cargo watch -x "test -- --nocapture"  # retest with output
cargo watch -x run                  # rerun on save

# cargo audit
cargo audit                         # check for vulnerabilities
cargo audit fix                     # auto-fix where possible</code></pre>
                </div>

                <!-- Clippy Lints -->
                <div class="subsection">
                    <h3 class="subsection-title">Common Clippy Lints to Enable</h3>
                    <p class="subsection-description">Clippy provides hundreds of lints beyond what <code>rustc</code> checks. Here are high-value lint groups and individual lints to consider enabling project-wide.</p>

                    <pre><code>// In main.rs or lib.rs &mdash; enable lints globally
#![warn(clippy::pedantic)]          // stricter style lints
#![warn(clippy::nursery)]           // newer, possibly unstable lints
#![warn(clippy::cargo)]             // Cargo.toml best practices

// Or in Cargo.toml (Rust 1.74+):
// [lints.clippy]
// pedantic = "warn"
// nursery = "warn"
// unwrap_used = "warn"             // prefer ? or expect() over unwrap()
// expect_used = "warn"             // be explicit about panic points
// dbg_macro = "warn"               // catch leftover dbg!() calls
// todo = "warn"                    // catch leftover todo!() macros
// print_stdout = "warn"            // use tracing/log instead of println!
// cast_possible_truncation = "allow"  # too noisy for many projects
// module_name_repetitions = "allow"   # allow module::ModuleThing naming

// Commonly allowed pedantic lints (too strict for most projects):
#![allow(clippy::must_use_candidate)]
#![allow(clippy::module_name_repetitions)]
#![allow(clippy::missing_errors_doc)]
#![allow(clippy::missing_panics_doc)]</code></pre>
                </div>

                <!-- Community Resources -->
                <div class="subsection">
                    <h3 class="subsection-title">Community Resources</h3>
                    <p class="subsection-description">The Rust community maintains excellent learning resources, from beginner-friendly tutorials to advanced references.</p>

                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Resource</th>
                                    <th>URL</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>The Rust Programming Language</strong></td>
                                    <td><code>doc.rust-lang.org/book</code></td>
                                    <td>The official book &mdash; best starting point for learning Rust</td>
                                </tr>
                                <tr>
                                    <td><strong>Rust by Example</strong></td>
                                    <td><code>doc.rust-lang.org/rust-by-example</code></td>
                                    <td>Learn Rust through annotated, runnable code examples</td>
                                </tr>
                                <tr>
                                    <td><strong>Rustlings</strong></td>
                                    <td><code>github.com/rust-lang/rustlings</code></td>
                                    <td>Small exercises to practice Rust syntax and concepts</td>
                                </tr>
                                <tr>
                                    <td><strong>This Week in Rust</strong></td>
                                    <td><code>this-week-in-rust.org</code></td>
                                    <td>Weekly newsletter covering Rust news, crates, and blog posts</td>
                                </tr>
                                <tr>
                                    <td><strong>Rust Reference</strong></td>
                                    <td><code>doc.rust-lang.org/reference</code></td>
                                    <td>Precise language specification and grammar details</td>
                                </tr>
                                <tr>
                                    <td><strong>std Library Docs</strong></td>
                                    <td><code>doc.rust-lang.org/std</code></td>
                                    <td>Complete API documentation for the standard library</td>
                                </tr>
                                <tr>
                                    <td><strong>crates.io</strong></td>
                                    <td><code>crates.io</code></td>
                                    <td>The Rust package registry &mdash; search and discover crates</td>
                                </tr>
                                <tr>
                                    <td><strong>Rust Playground</strong></td>
                                    <td><code>play.rust-lang.org</code></td>
                                    <td>Run Rust code in the browser &mdash; great for quick experiments</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </section>

    </main>

    <footer class="site-footer">
        <p class="footer-logo">Rust Tech Guide</p>
        <p class="footer-text">Built with the <a href="../styles/copper-verdigris.html">Copper &amp; Verdigris</a> design system</p>
        <p class="footer-text" style="font-size: 0.8125rem; color: var(--text-muted);">Systems programming with safety, speed, and concurrency</p>
        <div class="footer-ornament">
            <span class="dot"></span>
            <span class="dot"></span>
            <span class="dot"></span>
            <span class="dot"></span>
            <span class="dot"></span>
        </div>
        <p style="margin-top: var(--space-5);"><a href="index.html">Back to Tech Guides</a></p>
    </footer>
</body>
</html>
